<!doctype html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8">
    <meta name="baidu-site-verification" content="dIcXMeY8Ya">
    
    <title>`MySQL`分类下的文章 | 软件开发吧</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="keywords" content="SQL云,SQL云开发,SQL笔记,SQL开发,云开发,MySQL,Oralce,数据库,数据库云,数据库开发,数据库云开发,SQL教程,数据库教程,开发笔记,MySQL笔记,MySQL教程">
    <meta name="description" content="为满足广大程序猿兄弟对日常工作中学习数据库、使用使用数据库资料查询需求，SQL云开发免费将自己整理的各种数据库技术资料分享出来，并希望与广大猿兄一起讨论学习与进步,致力于一起更方便、快捷资料学习查询,实现更安全、高效的数据存储.">

    
    <link rel="alternative" href="/atom.xml" title="软件开发吧" type="application/atom+xml">
    
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
</html>
<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">软件开发吧</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/categories/MySQL/page/6/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/categories/MySQL/page/6/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/categories/MySQL/page/6/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/categories/MySQL/page/6/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/cdneitui" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.github.com/" target="_blank">Hosted by GitHub Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon">
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 文章分类 -->

    <h3 class="widget-hd">
        <strong>
            
                `MySQL`分类下的文章
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/22/2019030500009/">
    		使用消息系统避免分布式事务
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-22T02:17:09.000Z">2015-09-22</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/事务/" title="事务">事务</a> / 
    
        <a href="/tags/分布式/" title="分布式">分布式</a> / 
    
        <a href="/tags/消息/" title="消息">消息</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>首先举个例子：比如通过支付宝向余额宝转账1000元，这样一种生活中很平凡的事情，却可以引出很多问题：如果系统宕机挂掉，交易没有完成？那么数据就出现了不一致。等等类似的事情，在各类系统中都能找到类似情形。那么也可以换句专业的说法：当一个表update之后，如何保证另外一个与之关联的表也能完成update。 1、本地事务： 支付宝账户表：A  id uid amount 余额宝账户表：B  id uid amount 用户id：uid = 100 执行上面的过程分两部分： 1、支付宝账户表-1000：update A set amount=amount - 1000 where uid = 100； 2、余额宝账户表+1000：update B set amount=amount + 1000 where uid = 100； 如何保证两部分都能够完成，保证两部分“收支平衡” 对数据库熟悉的同学会那么我们使用transaction（事务）不就解决了 BEGIN TRANSACTION update A set amount=amount - 1000 where uid = 100； update B set amount=amount + 1000 where uid = 100； END TRANSACTION COMMIT; OK,上面的操作是没有问题的 那么对spring熟悉的同学也知道 其实在spring只需要使用注解就OK了 @Transactional(rollbackFor=Exception.class) public void updateAmount(){ updateA(); updateB(); } 是的，没有错的。能够完成。但是这些情况只是针对系统规模小，数据表在一个数据库实例上的；那么系统规模大，对应的数据表分布在不同的数据库实例上，分布在不同的物理节点上，前面采用的本地事务的方式就无用武之地了。 2、分布式事务（两阶段提交协议） 两阶段提交协议经常用来实现分布式事务;一般需要两个角色：协调器C和若干个事务执行者Si；那么事务执行者多半是具体的数据库，同时协调器和事务执行器可在一台机器上。 1、应用程序application发起一个请求到TC（事务协调器） 2、TC(事务协调器)将消息写到本地日志，再向所有的SI（事务执行者）的发送消息。 3、Si（事务执行者）接受到消息之后，执行本地事务但是不commit，如果成功返回yes否则no；同样返回      之前仍要进行日志记录。 4、Tc（事务协调器）接受到所有执行器返回的结果，如果所有的执行全部返回yes，那么发送commit消息给各个执行器，本地事务执行commit；若是有一个返回no，那么tc就会发送abort消息给各个执行器 注：tc和si把发送和接收到的消息存放到本地日志里，主要为了故障恢复复用，如若某一个si从故障中恢复后，先检查本地日志的内容，如果已接收到commit则本地事务执行器commit；若是abort，则回滚； 若是yes则在tc询问，确定下一步；若是什么都没有则可能前面执行已经崩溃，需要回滚。 熟悉java的同学可以看：<a href="http://acen-chen.iteye.com/blog/1055481" target="_blank" rel="noopener">http://acen-chen.iteye.com/blog/1055481</a> 采用分布式事务，也满足了我们前面的需求，同时新的问题随之而来 1、两阶段提交涉及多个节点的网络通信，通信时间如果过长 2、事务的相对时间长了，那么锁定资源的时间也就长了 那么在高并发的服务中，就会存在严重的性能问题。 3、消息队列 在高并发的环境中，我们一般会采用消息队列来避免分布式事务的执行 这和实际生活中，我们去饭店吃饭很类似，首先点单，这时服务员给你一张小票，等待服务器给你端上你的饭菜。 在使用消息队列我们需要做到可靠凭证的保存(分布式事务的消息)，有如下两种方式 方式1、支付宝完成扣钱的动作时，并记录消息数据，消息数据和业务数据在同一个数据库实例 BEGIN TRANSACTION update A set amount=amount - 1000 where uid = 100； INSERT INTO MESSAGE(UID，AMOUNT,STATUS) VALUES(1，1000，1) END TRANSACTION COMMIT; 那么我们可以将支付宝完成扣钱操作的消息通过及时服务发给余额宝，余额宝完成处理返回成功消息，支付宝收到消息，清除消息表中对应的消息记录，即完成本次扣钱操作。 方式2、 1）支付宝在扣款事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消       息数据，而不真正发送，只有消息发送成功后才会提交事务； 2）当支付宝扣款事务被提交成功后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才真正发送该消息； 3）当支付宝扣款事务提交失败回滚后，向实时消息服务取消发送。在得到取消发送指令后，该消息将不会被发送； 4）对于那些未确认的消息或者取消的消息，需要有一个消息状态确认系统定时去支付宝系统查询这个消息的状态并进行更新。为什么需要这一步骤，举个例子：假设在第2步支付宝扣款事务被成功提交后，系统挂了，此时消息状态并未被更新为“确认发送”，从而导致消息不能被发送。 优点：消息数据独立存储，降低业务系统与消息系统间的耦合； 缺点：一次消息发送需要两次请求；业务处理服务需要实现消息状态回查接口 ———————————————————————————————————————————— 那么如上的消息队列也就解决了我们实际业务中的高并发情况下分布式事务处理性能低下的问题 在使用消息队列防止重复投递消息 解决方法很简单，增加消息应用状态表（message_apply），通俗来说就是个账本，用于记录消息的消费情况，每次来一个消息，在真正执行之前，先去消息应用状态表中查询一遍，如果找到说明是重复消息，丢弃即可，如果没找到才执行，同时插入到消息应用状态表（同一事务）。 for each msg in queue Begin transaction select count(*) as cnt from message_apply where msg_id=msg.msg_id; if cnt==0 then update B set amount=amount+10000 where userId=1; insert into message_apply(msg_id) values(msg.msg_id); End transaction commit;</p>

            
            <p class="more">
                <a href="/2015/09/22/2019030500009/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/22/2019030500009/" title="使用消息系统避免分布式事务">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/21/2019030500075/">
    		mysql启动的四种方式
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-21T08:30:04.000Z">2015-09-21</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>在创建库的时候指定字符集 GBK: create database  database_name  DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci; UTF8: CREATE DATABASE `test2` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; 在创建表的时候你可以通过添加一个ENGINE 或TYPE 选项到CREATE TABLE语句来告诉MySQL你要创建什么类表并指定表的存储引擎： CREATE TABLE t (i INT) ENGINE = INNODB; CREATE TABLE t (i INT) TYPE = MEMORY; 要把一个表从一个类型转到另一个类型，可使用ALTER TABLE语句，这个语句指明新的类型： ALTER TABLE t ENGINE = MYISAM; ALTER TABLE t TYPE = BDB mysql 建表字符集 1.列出MYSQL支持的所有字符集： SHOW CHARACTER SET; 2.当前MYSQL服务器字符集设置 SHOW VARIABLES LIKE ‘character_set_%’; 3.当前MYSQL服务器字符集校验设置 SHOW VARIABLES LIKE ‘collation_%’; 4.显示某数据库字符集设置 show create database 数据库名; 5.显示某数据表字符集设置 show create table 表名; 6.修改数据库字符集 alter database 数据库名 default character set ‘utf8’; 7.修改数据表字符集 alter table 表名 default character set ‘utf8’; 8.建库时指定字符集 create database 数据库名 character set gbk collate gbk_chinese_ci; 9.建表时指定字符集 CREATE TABLE `mysqlcode` ( `id` TINYINT( 255 ) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY , `content` VARCHAR( 255 ) NOT NULL  <a href="http://www.2cto.com" target="_blank" rel="noopener">www.2cto.com</a> ) TYPE = MYISAM CHARACTER SET gbk COLLATE gbk_chinese_ci; 库字符集，在my.cnf中缺少了如下代码： [client] default-character-set=utf8 [mysqld] default-character-set=utf8 10.修改数据库的字符集 mysql&gt;use mydb mysql&gt;alter database mydb character set utf-8; 创建数据库指定数据库的字符集 mysql&gt;create database mydb character set utf-8; 通过配置文件修改: 修改/var/lib/mysql/mydb/db.opt default-character-set=latin1 default-collation=latin1_swedish_ci 为  <a href="http://www.2cto.com" target="_blank" rel="noopener">www.2cto.com</a> default-character-set=utf8 default-collation=utf8_general_ci 11.MySQL服务器能够支持多种字符集。可以使用SHOW CHARACTER SET语句列出可用的字符集： mysql&gt; SHOW CHARACTER SET; 如果不加以上代码，那么即便MYSQL编译安装时指定的编码是UTF8，那么在建库时其默认编码仍是LATIN1，而由于字符集的继承性，库中的表也是LATIN1的了。mysql的四种启动方式: 1、mysqld 启动mysql服务器:./mysqld –defaults-file=/etc/my.cnf –user=root 客户端连接: mysql –defaults-file=/etc/my.cnf or mysql -S /tmp/mysql.sock 2、mysqld_safe 启动mysql服务器:./mysqld_safe –defaults-file=/etc/my.cnf –user=root &amp; 客户端连接: mysql –defaults-file=/etc/my.cnf or mysql -S /tm/mysql.sock 3、mysql.server cp -v /usr/local/mysql/support-files/mysql.server /etc/init.d/ chkconfig –add mysql.server 启动mysql服务器:service mysql.server {start|stop|restart|reload|force-reload|status} 客户端连接:同1、2 4、mysqld_multi mkdir $MYSQL_BASE/data2 cat &lt;<-eof>&gt; /etc/my.cnf [mysqld_multi] mysqld    = /usr/local/mysql/bin/mysqld_safe mysqladmin = /user/local/mysql/bin/mysqladmin user = mysqladmin password = mysqladmin [mysqld3306] port            = 3306 socket          = /tmp/mysql3306.sock pid-file    = /tmp/mysql3306.pid skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M basedir        = /usr/local/mysql datadir        = /usr/local/mysql/data [mysqld3307] port            = 3307 socket          = /tmp/mysql3307.sock pid-file    = /tmp/mysql3307.pid skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M basedir        = /usr/local/mysql datadir        = /usr/local/mysql/data2 EOF #mysql -S /tmp/mysql3306.sock mysql&gt;GRANT SHUTDOWN ON <em>.</em> TO ‘mysqladmin‘@’localhost’ identified by ‘mysqladmin’ with grant option; #mysql -S /tmp/mysql3307.sock mysql&gt;GRANT SHUTDOWN ON <em>.</em> TO ‘mysqladmin‘@’localhost’ identified by ‘mysqladmin’ with grant option; 启动mysql服务器:./mysqld_multi –defaults-file=/etc/my.cnf start 3306-3307 关闭mysql服务器:mysqladmin shutdown</-eof></p>

            
            <p class="more">
                <a href="/2015/09/21/2019030500075/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/21/2019030500075/" title="mysql启动的四种方式">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/21/2019030500037/">
    		死锁的预防和解除
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-21T08:26:38.000Z">2015-09-21</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/死锁/" title="死锁">死锁</a> / 
    
        <a href="/tags/解除/" title="解除">解除</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>产生死锁的原因主要是： （1）系统资源不足。 （2） 进程运行推进的顺序不合适。 （3）资源分配不当等。 如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。 产生死锁的四个必要条件： （1） 互斥条件：一个资源每次只能被一个进程使用。 （2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 （3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 （4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 死锁的预防和解除： 理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源,在系统运行过程中，对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，若分配后系统可能发生死锁，则不予分配，否则予以分配 。因此，对资源的分配要给予合理的规划。 如何将死锁减至最少 虽然不能完全避免死锁，但可以使死锁的数量减至最少。将死锁减至最少可以增加事务的吞吐量并减少系统开销，因为只有很少的事务回滚，而回滚会取消事务执行的所有工作。由于死锁时回滚而由应用程序重新提交。 下列方法有助于最大限度地降低死锁： （1）按同一顺序访问对象。 （2）避免事务中的用户交互。 （3）保持事务简短并在一个批处理中。 （4）使用低隔离级别。 （5）使用绑定连接。 按同一顺序访问对象 如果所有并发事务按同一顺序访问对象，则发生死锁的可能性会降低。例如，如果两个并发事务获得 Supplier 表上的锁，然后获得 Part 表上的锁，则在其中一个事务完成之前，另一个事务被阻塞在 Supplier 表上。第一个事务提交或回滚后，第二个事务继续进行。不发生死锁。将存储过程用于所有的数据修改可以标准化访问对象的顺序。 避免事务中的用户交互 避免编写包含用户交互的事务，因为运行没有用户交互的批处理的速度要远远快于用户手动响应查询的速度，例如答复应用程序请求参数的提示。例如，如果事务正在等待用户输入，而用户去吃午餐了或者甚至回家过周末了，则用户将此事务挂起使之不能完成。这样将降低系统的吞吐量，因为事务持有的任何锁只有在事务提交或回滚时才会释放。即使不出现死锁的情况，访问同一资源的其它事务也会被阻塞，等待该事务完成。 保持事务简短并在一个批处理中 在同一数据库中并发执行多个需要长时间运行的事务时通常发生死锁。事务运行时间越长，其持有排它锁或更新锁的时间也就越长，从而堵塞了其它活动并可能导致死锁。 保持事务在一个批处理中，可以最小化事务的网络通信往返量，减少完成事务可能的延迟并释放锁。 使用低隔离级别 确定事务是否能在更低的隔离级别上运行。执行提交读允许事务读取另一个事务已读取（未修改）的数据，而不必等待第一个事务完成。使用较低的隔离级别（例如提交读）而不使用较高的隔离级别（例如可串行读）可以缩短持有共享锁的时间，从而降低了锁定争夺。 使用绑定连接 使用绑定连接使同一应用程序所打开的两个或多个连接可以相互合作。次级连接所获得的任何锁可以象由主连接获得的锁那样持有，反之亦然，因此不会相互阻塞。 用存储过程查出引起死锁的进程和SQL语句 假如发生了死锁，我们怎么去检测具体发生死锁的是哪条SQL语句或存储过程？此时我们可以使用以下存储过程来检测，就可以查出引起死锁的进程和SQL语句。</p>

            
            <p class="more">
                <a href="/2015/09/21/2019030500037/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/21/2019030500037/" title="死锁的预防和解除">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/21/2019030500038/">
    		浅谈事务隔离级别
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-21T08:25:01.000Z">2015-09-21</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/事务/" title="事务">事务</a> / 
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>一、对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题: 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的. 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了. 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行. 二、数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题. 三、一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱. 四、数据库提供的 4 种事务隔离级别: ●READ UNCOMMITTED(读未提交数据)：允许事物读取未被其他事物提交的变更、脏读、不可重复读和幻读的问题都会出现。 ●READ COMMITED(读已提交数据)：只允许事物读取已经被其他事物提交的变更，可以避免脏读，但不可重复读和幻读问题仍然可能出现。 ●REPEATABLE READ(可重复读)：确保一个事物可以多次从一个字段中读取相同的值，在合格事物持续期间，禁止其他事物岁这个字段进行更新，可以避免脏读和不可重复读，但幻读问题仍然存在。 ●SERIALIZABLE(串行化)：确保事物可以从一个表中读取相同的行，在这个事物持续期间，禁止其他事物对该表执行插入、更新和删除操作。所有并发问题都可以避免，但性能十分低下。 五、Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED 六、Mysql 支持 4 种事务隔离级别. Mysql 默认的事务隔离级别为: REPEATABLE READ</p>

            
            <p class="more">
                <a href="/2015/09/21/2019030500038/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/21/2019030500038/" title="浅谈事务隔离级别">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/11/2019030500067/">
    		MYSQL主备复制结构搭建与切换
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-11T05:01:22.000Z">2015-09-11</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p><strong>1 选择两个服务器，分别作为主备数据库</strong> <strong>2 登陆到服务器，安装相同版本mysql</strong></p>
<p><strong>[sql]</strong></p>
<ol>
<li>yum install mysql ;</li>
<li>yum install mysql-server;</li>
</ol>
<p><strong>3 启动mysql服务器 </strong> service  mysqld start <strong>4 分别root登陆mysql 执行如下命令</strong> 增加复制用户并授权（主备都在192.168.119.*网段，为了方便主备切换，两边都建立）</p>
<p><strong>[sql]</strong></p>
<ol>
<li>GRANT  REPLICATION SLAVE,REPLICATION CLIENT on <em>.</em> to repl@’192.168.119.%’ identified by ‘1234’;</li>
</ol>
<p><strong>5 配置/etc/my.cnf</strong> 第一服务器（主）</p>
<p><strong>[sql]</strong></p>
<ol>
<li>log_bin=mysql-bin</li>
<li>server_id=1</li>
</ol>
<p>第二个服务器（备）</p>
<p><strong>[sql]</strong></p>
<ol>
<li>log_bin=mysql-bin</li>
<li>server_id=2</li>
<li>read_only=1</li>
</ol>
<p><strong>6 重启两个mysql服务器**</strong>7 登陆主（root）执行**</p>
<p><strong>[sql]</strong></p>
<ol>
<li>show master status\G;</li>
</ol>
<p>显示 File: mysql-bin.000001 Position: 106 <strong>8 登陆备(root) 执行</strong> 测试 mysql -urepl -h192.168.119.128 -p1234 是否能连接到主库，不能需要检查防火墙或者/etc/my.cnf是否有访问限制，修改配置 mysql -uroot登陆本地库执行：</p>
<p><strong>[sql]</strong></p>
<ol>
<li>CHANGE MASTER TO</li>
<li>MASTER_HOST=’192.168.119.128’,</li>
<li>MASTER_USER=’repl’,</li>
<li>MASTER_PASSWORD=’1234’,</li>
<li>MASTER_LOG_FILE=’mysql-bin.000001’,</li>
<li>MASTER_LOG_POS=106;</li>
</ol>
<p><strong>[sql]</strong></p>
<ol>
<li>start slave;</li>
<li>show slave status\G;</li>
</ol>
<p><strong>9，验证</strong> 主库上创建表，备库上查看，可以看到 备库上repl创建表，显示The MySQL server is running with the –read-only option so it cannot execute this statement 因为配置了备库为read_only <strong>10，后续关注</strong> 以后重启主备库，不用再配置change master。每重启一次主库会发现logfile 变成一个新的文件mysql-bin.000004 <strong>11 ,主从切换</strong> 11.1 修改配置文件/etc/my.cnf</p>
<p><strong>[sql]</strong></p>
<ol>
<li>read-only=1（主库）</li>
<li>#read-only=1（备库）</li>
</ol>
<p>11.2 从库上执行</p>
<p><strong>[sql]</strong></p>
<ol>
<li>STOP SLAVE IO_THREAD;</li>
<li>SHOW PROCESSLIST;</li>
</ol>
<p>system user 线程确保状态为：has read all relay log 或者消失 再执行</p>
<p><strong>[sql]</strong></p>
<ol>
<li>STOP SLAVE;</li>
<li>RESET MASTER;</li>
<li>RESET SLAVE;</li>
<li>show master status \G；</li>
</ol>
<p>结果 File: mysql-bin.000001 Position: 106 11.3 主库上执行</p>
<p><strong>[sql]</strong></p>
<ol>
<li>RESET MASTER;</li>
<li>RESET SLAVE;</li>
</ol>
<p><strong>[sql]</strong></p>
<ol>
<li>CHANGE MASTER TO</li>
<li>MASTER_HOST=’192.168.119.129’,</li>
<li>MASTER_USER=’repl’,</li>
<li>MASTER_PASSWORD=’1234’,</li>
<li>MASTER_LOG_FILE=’mysql-bin.000001’,</li>
<li>MASTER_LOG_POS=106;</li>
</ol>
<p><strong>[sql]</strong></p>
<ol>
<li>start slave</li>
</ol>
<p>11.4 重启主备库，注意先重启新的主库，再启动新的备库</p>
<p><strong>[sql]</strong></p>
<ol>
<li>service mysqld restart</li>
</ol>
<p>11.5 验证 原来的主库已经变成从库，从库变成主库。</p>
</blockquote>

            
            <p class="more">
                <a href="/2015/09/11/2019030500067/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/11/2019030500067/" title="MYSQL主备复制结构搭建与切换">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/11/2019030500011/">
    		加快mydumper与myloader导出导入
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-11T04:58:23.000Z">2015-09-11</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/数据库/" title="数据库">数据库</a> / 
    
        <a href="/tags/SQL/" title="SQL">SQL</a> / 
    
        <a href="/tags/Database/" title="Database">Database</a> / 
    
        <a href="/tags/dba/" title="dba">dba</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>mydumper与myloader是一个优秀的第三方mysql数据库逻辑备份恢复工具，使用多线程的导出与导入。弥补了mysqldump单线程的不足。本文描述的是如何加快mydumper与myloader的导出与导入供大家参考。 1、基于MyIsam引擎导出导入 a、表不分块导出及导入 [root@GZAPP tmp]# mydumper -u inno -p xxx -B bsom -T tb_access_log -o /backup/tmp/ [root@GZAPP tmp]# ls -hltr   ###导出的数据文件为单个文件，大小在2.6GB total 2.6G -rw-r–r– 1 root root 1.6K Jul 24 08:51 bsom.tb_access_log-schema.sql -rw-r–r– 1 root root  214 Jul 24 08:52 metadata -rw-r–r– 1 root root 2.6G Jul 24 08:52 bsom.tb_access_log.sql ###基于缺省线程数导入，且设定每个事务查询数为10000，此参数此时其实作用不大，因为表为myisam引擎 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -d /backup/tmp -v 3 -q 10000 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -d /backup/tmp -v 3 -q 10000 <strong> Message: 4 threads created </strong> Message: Creating table `tempdb`.`tb_access_log` <strong> Message: Thread 4 shutting down </strong> Message: Thread 1 restoring `bsom`.`tb_access_log` part 0 <strong> Message: Thread 3 shutting down </strong> Message: Thread 2 shutting down root@localhost[tempdb]&gt; show processlist; +———+———+———-+——–+———+——–+———+————————————————+ | Id      | User    | Host     | db     | Command | Time   | State   | Info                                           | +———+———+———-+——–+———+——–+———+————————————————+ | 4452079 | root    | localhost| tempdb | Query   |      0 | init    | show processlist                               | | 4453793 | inno    | localhost| tempdb | Sleep   |    420 |         | NULL                                           | | 4453794 | inno    | localhost| tempdb | Query   |      4 | update  | INSERT INTO `tb_access_log` VALUES (506873,”325| +———+———+———-+——–+———+——–+———+————————————————+ ###从上面的线程数可以看出只有一个单线程在执行insert操作 b、表分块导出及导入 ###下面的示例中使用500MB进行分块 [root@GZAPP tmp]# mydumper -u inno -p xxx -B bsom -T tb_access_log -F 500 -o /backup/tmp/ [root@GZAPP tmp]# ls -hltr total 2.6G -rw-r–r– 1 root root 1.6K Jul 24 08:21 bsom.tb_access_log-schema.sql -rw-r–r– 1 root root 478M Jul 24 08:21 bsom.tb_access_log.00001.sql -rw-r–r– 1 root root 478M Jul 24 08:21 bsom.tb_access_log.00002.sql -rw-r–r– 1 root root 478M Jul 24 08:21 bsom.tb_access_log.00003.sql -rw-r–r– 1 root root 478M Jul 24 08:21 bsom.tb_access_log.00004.sql -rw-r–r– 1 root root 478M Jul 24 08:22 bsom.tb_access_log.00005.sql -rw-r–r– 1 root root  214 Jul 24 08:22 metadata -rw-r–r– 1 root root 241M Jul 24 08:22 bsom.tb_access_log.00006.sql ###由上可知，大表tb_access_log按接近500M被分割成了多个文件 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -t 6 -d /backup/tmp -v 3 <strong> Message: 6 threads created </strong> Message: Creating database `tempdb` <strong> Message: Creating table `tempdb`.`tb_access_log` </strong> Message: Thread 1 restoring `bsom`.`tb_access_log` part 3 <strong> Message: Thread 2 restoring `bsom`.`tb_access_log` part 5 </strong> Message: Thread 5 restoring `bsom`.`tb_access_log` part 4 <strong> Message: Thread 3 restoring `bsom`.`tb_access_log` part 6 </strong> Message: Thread 4 restoring `bsom`.`tb_access_log` part 1 <strong> Message: Thread 6 restoring `bsom`.`tb_access_log` part 2 #在下面的processlist可以看到，存在表级锁等待 +———+——-+———–+———+———+——–+—————————–+————————————————+ | Id      | User  | Host      | db      | Command | Time   | State                       | Info                                           | +———+——-+———–+———+———+——–+—————————–+————————————————+ | 4452079 | root  | localhost | bsom    | Query   |      0 | init                        | show processlist                               | | 4452167 | inno  | localhost | tempdb  | Sleep   |    769 |                             | NULL                                           | | 4452168 | inno  | localhost | tempdb  | Query   |     36 | update                      | INSERT INTO `tb_access_log` VALUES (6367402,”0,| | 4452169 | inno  | localhost | tempdb  | Query   |     21 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (12593865,” | | 4452170 | inno  | localhost | tempdb  | Query   |     26 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (15643029,””| | 4452171 | inno  | localhost | tempdb  | Query   |      6 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (173947,”70 | | 4452172 | inno  | localhost | tempdb  | Query   |     15 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (9490507,”7 | | 4452173 | inno  | localhost | tempdb  | Query   |     30 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (3271602,”4 | +———+———+———–+———+———+——–+—————————–+———————————————-+ c、调整myisam有关参数后导入 [root@GZ-APP-BAK01 tmp]# time myloader -u innobk -p InnoBK -B tempdb -t 6 -d /backup/tmp -v 3 </strong> Message: 6 threads created <strong> Message: Creating table `tempdb`.`tb_mobile_access_log` </strong> Message: Thread 1 restoring `blossom`.`tb_mobile_access_log` part 3 <strong> Message: Thread 6 restoring `blossom`.`tb_mobile_access_log` part 6 </strong> Message: Thread 2 restoring `blossom`.`tb_mobile_access_log` part 5 <strong> Message: Thread 3 restoring `blossom`.`tb_mobile_access_log` part 4 </strong> Message: Thread 4 restoring `blossom`.`tb_mobile_access_log` part 1 <strong> Message: Thread 5 restoring `blossom`.`tb_mobile_access_log` part 2 </strong> Message: Thread 6 shutting down <strong> Message: Thread 5 shutting down </strong> Message: Thread 1 shutting down <strong> Message: Thread 2 shutting down </strong> Message: Thread 4 shutting down <strong> Message: Thread 3 shutting down real    266m28.903s user    0m6.008s sys     0m1.681s ###调整以下相关参数，后尝试再次导入， concurrent_insert  AUTO 改成 ALWAYS bulk_insert_buffer_size 8388608 改成 256M myisam_sort_buffer_size 67108864 改成 128M [root@GZ-APP-BAK01 tmp]# time myloader -u innobk -p InnoBK -B tempdb -t 6 -o -d /backup/tmp -v 3 </strong> Message: 6 threads created <strong> Message: Dropping table (if exists) `tempdb`.`tb_mobile_access_log` </strong> Message: Creating table `tempdb`.`tb_mobile_access_log` <strong> Message: Thread 1 restoring `blossom`.`tb_mobile_access_log` part 3 </strong> Message: Thread 2 restoring `blossom`.`tb_mobile_access_log` part 6 <strong> Message: Thread 3 restoring `blossom`.`tb_mobile_access_log` part 5 </strong> Message: Thread 4 restoring `blossom`.`tb_mobile_access_log` part 4 <strong> Message: Thread 6 restoring `blossom`.`tb_mobile_access_log` part 1 </strong> Message: Thread 5 restoring `blossom`.`tb_mobile_access_log` part 2 <strong> Message: Thread 2 shutting down </strong> Message: Thread 1 shutting down <strong> Message: Thread 6 shutting down </strong> Message: Thread 5 shutting down <strong> Message: Thread 3 shutting down </strong> Message: Thread 4 shutting down real    253m42.460s   ###此时导入时间并无明显减少 user    0m5.924s sys     0m1.637s 2、基于innodb引擎的导出导入 a、表未分块导出，数据文件大小为3.9GB [root@GZAPP tmp]# ls -hltr total 3.9G -rw-r–r– 1 root root 1.8K Jul 24 00:09 bscom.tb_message-schema.sql -rw-r–r– 1 root root 3.9G Jul 24 00:25 bscom.tb_message.sql -rw-r–r– 1 root root  215 Jul 24 09:14 metadata ###下面使用6个线程导入，实际上可以看到，只有1个线程在工作，因为数据文件只有1个 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -t 6 -d /backup/tmp -v 3 <strong> Message: 6 threads created </strong> Message: Creating table `tempdb`.`tb_message` <strong> Message: Thread 1 restoring `bscom`.`tb_message` part 0 </strong> Message: Thread 5 shutting down <strong> Message: Thread 2 shutting down </strong> Message: Thread 6 shutting down <strong> Message: Thread 3 shutting down </strong> Message: Thread 4 shutting down b、表分块导出 [root@GZAPP tmp]# mydumper -u inno -p xxx -B bscom -T tb_message -F 500 -o /backup/tmp/ [root@GZAPP tmp]# ls -hltr total 3.9G -rw-r–r– 1 root root 1.8K Jul 24 09:55 bscom.tb_message-schema.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00001.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00002.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00003.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00004.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00005.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00006.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00007.sql -rw-r–r– 1 root root 481M Jul 24 09:55 bscom.tb_message.00008.sql -rw-r–r– 1 root root  135 Jul 24 09:55 metadata -rw-r–r– 1 root root  93M Jul 24 09:55 bscom.tb_message.00009.sql ###下面尝试使用6线程导入，可以看到有6个线程在并发导入 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -t 6 -d /backup/tmp/ -v 3 <strong> Message: 6 threads created </strong> Message: Creating database `tempdb` <strong> Message: Creating table `tempdb`.`tb_message` </strong> Message: Thread 2 restoring `bscom`.`tb_message` part 5 <strong> Message: Thread 1 restoring `bscom`.`tb_message` part 9 </strong> Message: Thread 3 restoring `bscom`.`tb_message` part 1 <strong> Message: Thread 4 restoring `bscom`.`tb_message` part 8 </strong> Message: Thread 5 restoring `bscom`.`tb_message` part 4 <strong> Message: Thread 6 restoring `bscom`.`tb_message` part 6 </strong> Message: Thread 1 restoring `bscom`.`tb_message` part 7 <strong> Message: Thread 6 restoring `bscom`.`tb_message` part 3 </strong> Message: Thread 2 restoring `bscom`.`tb_message` part 2 <strong> Message: Thread 3 shutting down </strong> Message: Thread 5 shutting down <strong> Message: Thread 4 shutting down </strong> Message: Thread 1 shutting down <strong> Message: Thread 2 shutting down </strong> Message: Thread 6 shutting down 3、小结 a、mydumper在导出的时候可以根据服务器可用资源来合理地设置线程数。 b、mydumper在导出的时候尽可能地指定chunk-filesize或者rows参数以分块导出。 c、myloader在针对myisam引擎时建议调整相关参数至合理值以提高无法提高性能，主要是表级锁的问题。 d、myloader在针对innodb引擎时建议调整参数至合理值以提高性能，如以下参数等： innodb_buffer_pool_size innodb_flush_log_at_trx_commit innodb_log_buffer_size e、通过使用分块导出与导入可以显著利用并发来加快inndbo表导入。 f、注意mydumper导出时不会导出存储过程，函数，触发器等。</p>

            
            <p class="more">
                <a href="/2015/09/11/2019030500011/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/11/2019030500011/" title="加快mydumper与myloader导出导入">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/07/2019030500076/">
    		Mysql复合主键中自增长字段
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-07T04:51:47.000Z">2015-09-07</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/复合主键/" title="复合主键">复合主键</a> / 
    
        <a href="/tags/自增长/" title="自增长">自增长</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>Google Analytics的ID一般形如：UA-18xxxxx-<strong>1</strong>，UA-18xxxxx-<strong>4</strong>, 我们可以将它分成两段来看：字段1：UA-18XXXXX是指帐户的ID；字段2：字段1后附加的1、4，刚分别是指该帐户名下的两个网站。有一段时间很 纠结这样的ID怎么去维护，直到最近查阅到Mysql手册才发现，原来Mysql原生就很好的支持了这种含自动增长字段的复合主键，所以字段2是存储引擎 自动计算出来的。计算方式：MAX(_auto_increment_column_) + 1 WHERE prefix=<em>given-prefix</em> <a href="https://xiaobin.net/200905/mysql-auto-increasement-and-multi-primary-key/#fn:mysql_manual" target="_blank" rel="noopener">[1]</a>。 不多说，直接看SQL：</p>
<p>mysql&gt; CREATE TABLE `_test` (<br>    -&gt; `c1` varchar(20) NOT NULL DEFAULT ‘’, – 主键一：varchar<br>    -&gt; `c2` int(11) NOT NULL AUTO_INCREMENT, – 主键二：自增序列<br>    -&gt; `c3` varchar(255) ,<br>    -&gt; PRIMARY KEY (`c1`,`c2`) – 注意这里的先后顺序<br>    -&gt; ) ENGINE=MyISAM DEFAULT CHARSET=latin1;<br>Query OK, 0 rows affected (0.04 sec)</p>
<p>mysql&gt;<br>mysql&gt; INSERT INTO `_test` (`c1`,`c3`) VALUES (‘AAA’,’Robin Home’),<br>    -&gt; (‘AAA’,’Robin Blog’),<br>    -&gt; (‘AAA’,’Robin Resume’),<br>    -&gt; (‘BBB’,’Lily Home’),<br>    -&gt; (‘BBB’,’Lily Blog’);<br>Query OK, 5 rows affected (0.00 sec)<br>Records: 5  Duplicates: 0  Warnings: 0</p>
<p>mysql&gt;<br>mysql&gt; SELECT * FROM `_test`;<br>+—–+—-+————–+<br>| c1  | c2 | c3           |<br>+—–+—-+————–+<br>| AAA |  1 | Robin Home   |<br>| AAA |  2 | Robin Blog   |<br>| AAA |  3 | Robin Resume |<br>| BBB |  1 | Lily Home    |<br>| BBB |  2 | Lily Blog    |<br>+—–+—-+————–+<br>5 rows in set (0.00 sec)</p>
<p>mysql&gt;</p>
<p>值得注意的是，MySQL的这种特性只适用于MyISAM和BDB引擎。</p>

            
            <p class="more">
                <a href="/2015/09/07/2019030500076/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/07/2019030500076/" title="Mysql复合主键中自增长字段">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/7.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/07/2019030500086/">
    		mysql 常见错误解决方式
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-07T04:48:47.000Z">2015-09-07</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/mysql-1449/" title="mysql 1449">mysql 1449</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>mysql 1449 ： The user specified as a definer (‘root‘@’%’) does not exist 分析: 一般是由于root用户对全局host无访问权限。因此只要给root用户添加一个访问权限即可。 解决方式: <strong>grant all privileges on <em>.</em> to root@”%” identified by “.”;</strong> <strong>flush privileges;</strong> 参考: <a href="http://bbs.csdn.net/topics/390339729" target="_blank" rel="noopener">http://bbs.csdn.net/topics/390339729</a> 扩展: 阿里云数据库访问存储/视图时出现”mysql 1449”错误,解决方式, 1.使用阿里云自带的图形化界面访问数据库. 2.编辑视图/存储过程 3.设置安全性为INVOKER 4.重新保存</p>

            
            <p class="more">
                <a href="/2015/09/07/2019030500086/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/07/2019030500086/" title="mysql 常见错误解决方式">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/7.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/01/2019030500117/">
    		mysql5.6和mysql5.7分配undo回滚段的区别
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-01T07:36:52.000Z">2015-09-01</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/mysql5-6/" title="mysql5.6">mysql5.6</a> / 
    
        <a href="/tags/mysql5-7/" title="mysql5.7">mysql5.7</a> / 
    
        <a href="/tags/undo/" title="undo">undo</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>1、mysql5.7中分为2类：临时表空间回滚段和普通回滚段。 2、mysql5.6中没有区分。 As of <strong>MySQL 5.7.2</strong>, 32 undo logs are reserved for use by temporary tables and are hosted in the temporary table tablespace (<code>ibtmp1</code>). To allocate additional undo logs for data-modifying transactions that generate undo records,<code>innodb_undo_logs</code> must be set to a value greater than 32 if undo logs are stored in the system tablespace only. If you have configured separate undo tablespaces, <code>innodb_undo_logs</code> must be set to a value greater than 33 to allocate additional undo logs for data-modifying transactions. Each undo log can host up to a maximum of 1024 transactions. 如果undo log存储在系统表空间，innodb_undo_logs值必须大于32 否则独立存储的话必须大于3。 参考： <a href="http://www.tuicool.com/articles/IzQNRrz" target="_blank" rel="noopener">http://www.tuicool.com/articles/IzQNRrz</a> <a href="http://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar\_innodb\_undo\_logs" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.7/en/innodb-parameters.html#sysvar\_innodb\_undo\_logs</a> <a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar\_innodb\_undo\_logs" target="_blank" rel="noopener">http://dev.mysql.com/doc/refman/5.6/en/innodb-parameters.html#sysvar\_innodb\_undo\_logs</a> <a href="http://bbs.aliyun.com/read/244045.html?spm=5176.7189909.0.0.AB00as" target="_blank" rel="noopener">http://bbs.aliyun.com/read/244045.html?spm=5176.7189909.0.0.AB00as</a></p>

            
            <p class="more">
                <a href="/2015/09/01/2019030500117/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/01/2019030500117/" title="mysql5.6和mysql5.7分配undo回滚段的区别">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/01/2019030500077/">
    		mysql备份与还原
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-01T07:35:13.000Z">2015-09-01</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/数据库/" title="数据库">数据库</a> / 
    
        <a href="/tags/mysqldump/" title="mysqldump">mysqldump</a> / 
    
        <a href="/tags/mysql备份/" title="mysql备份">mysql备份</a> / 
    
        <a href="/tags/mysql还原/" title="mysql还原">mysql还原</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<h1 id="1-mysqldump"><a href="#1-mysqldump" class="headerlink" title="1.mysqldump"></a>1.mysqldump</h1><h2 id="1-1-备份方法："><a href="#1-1-备份方法：" class="headerlink" title="1.1.备份方法："></a>1.1.备份方法：</h2><p>（1）导出整个数据库并指定字符集(包括数据库中的数据）</p>
<pre><code>mysqldump -u root -p --default-character-set=utf8 dbname &gt; 存放路径 
</code></pre><p>（2）导出数据库结构（不含数据）</p>
<pre><code>mysqldump -u username -p -d dbname &gt; dbname.sql    
</code></pre><p>（3）导出数据库中的某张数据表（包含数据）</p>
<pre><code>mysqldump -u username -p dbname tablename &gt; tablename.sql    
</code></pre><p>（4）导出数据库中的某张数据表的表结构（不含数据）</p>
<pre><code>mysqldump -u username -p -d dbname tablename &gt; tablename.sql
</code></pre><h2 id="1-2-mysqldump常用参数"><a href="#1-2-mysqldump常用参数" class="headerlink" title="1.2.mysqldump常用参数"></a>1.2.mysqldump常用参数</h2><blockquote>
<p>–compatible=name 它告诉 mysqldump，导出的数据将和哪种数据库或哪个旧版本的 MySQL 服务器相兼容。值可以为 ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options、no_field_options 等，要使用几个值，用逗号将它们隔开。当然了，它并不保证能完全兼容，而是尽量兼容。</p>
<hr>
<p>–all-databases , -A 导出全部数据库mysqldump -uroot -p –all-databases</p>
<hr>
<p>–all-tablespaces , -Y导出全部表空间。mysqldump -uroot -p –all-databases</p>
<hr>
<p>–all-tablespaces–no-tablespaces , -y不导出任何表空间信息。mysqldump -uroot -p –all-databases –no-tablespaces</p>
<hr>
<p>–add-drop-database每个数据库创建之前添加drop数据库语句。mysqldump -uroot -p –all-databases –add-drop-database</p>
<hr>
<p>–add-drop-table每个数据表创建之前添加drop数据表语句。(默认为打开状态，使用–skip-add-drop-table取消选项)mysqldump -uroot -p –all-databases (默认添加drop语句)mysqldump -uroot -p –all-databases –skip-add-drop-table (取消drop语句)</p>
<hr>
<p>–add-locks在每个表导出之前增加LOCK TABLES并且之后UNLOCK TABLE。(默认为打开状态，使用–skip-add-locks取消选项)mysqldump -uroot -p –all-databases (默认添加LOCK语句)mysqldump -uroot -p –all-databases –skip-add-locks (取消LOCK语句)</p>
<hr>
<p>–comments附加注释信息。默认为打开，可以用–skip-comments取消mysqldump -uroot -p –all-databases (默认记录注释)mysqldump -uroot -p –all-databases –skip-comments (取消注释)</p>
<hr>
<p>–compact导出更少的输出信息(用于调试)。去掉注释和头尾等结构。可以使用选项：–skip-add-drop-table –skip-add-locks –skip-comments –skip-disable-keysmysqldump -uroot -p –all-databases –compact</p>
<hr>
<p>–complete-insert, -c使用完整的insert语句(包含列名称)。这么做能提高插入效率，但是可能会受到max_allowed_packet参数的影响而导致插入失败。mysqldump -uroot -p –all-databases –complete-insert</p>
<hr>
<p>–compress, -C在客户端和服务器之间启用压缩传递所有信息mysqldump -uroot -p –all-databases –compress</p>
<hr>
<p>–databases, -B导出几个数据库。参数后面所有名字参量都被看作数据库名。mysqldump -uroot -p –databases test mysql</p>
<hr>
<p>–debug输出debug信息，用于调试。默认值为：d:t:o,/tmp/mysqldump.tracemysqldump -uroot -p –all-databases –debugmysqldump -uroot -p –all-databases –debug=” d:t:o,/tmp/debug.trace”</p>
<hr>
<p>–debug-info输出调试信息并退出mysqldump -uroot -p –all-databases –debug-info</p>
<hr>
<p>–default-character-set设置默认字符集，默认值为utf8mysqldump -uroot -p –all-databases –default-character-set=latin1</p>
<hr>
<p>–delayed-insert采用延时插入方式（INSERT DELAYED）导出数据mysqldump -uroot -p –all-databases –delayed-insert</p>
<hr>
<p>–events, -E导出事件。mysqldump -uroot -p –all-databases –events</p>
<hr>
<p>–flush-logs开始导出之前刷新日志。请注意：假如一次导出多个数据库(使用选项–databases或者–all-databases)，将会逐个数据库刷新日志。除使用–lock-all-tables或者–master-data外。在这种情况下，日志将会被刷新一次，相应的所以表同时被锁定。因此，如果打算同时导出和刷新日志应该使用–lock-all-tables 或者–master-data 和–flush-logs。mysqldump -uroot -p –all-databases –flush-logs</p>
<hr>
<p>–flush-privileges在导出mysql数据库之后，发出一条FLUSH PRIVILEGES 语句。为了正确恢复，该选项应该用于导出mysql数据库和依赖mysql数据库数据的任何时候。mysqldump -uroot -p –all-databases –flush-privileges</p>
<hr>
<p>–force在导出过程中忽略出现的SQL错误。mysqldump -uroot -p –all-databases –force</p>
<hr>
<p>–host, -h需要导出的主机信息mysqldump -uroot -p –host=localhost –all-databases</p>
<hr>
<p>–ignore-table不导出指定表。指定忽略多个表时，需要重复多次，每次一个表。每个表必须同时指定数据库和表名。例如：–ignore-table=database.table1 –ignore-table=database.table2 ……mysqldump -uroot -p –host=localhost –all-databases –ignore-table=mysql.user</p>
<hr>
<p>–lock-all-tables, -x提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭–single-transaction 和–lock-tables 选项。mysqldump -uroot -p –host=localhost –all-databases –lock-all-tables</p>
<hr>
<p>–lock-tables, -l开始导出前，锁定所有表。用READ LOCAL锁定表以允许MyISAM表并行插入。对于支持事务的表例如InnoDB和BDB，–single-transaction是一个更好的选择，因为它根本不需要锁定表。请注意当导出多个数据库时，–lock-tables分别为每个数据库锁定表。因此，该选项不能保证导出文件中的表在数据库之间的逻辑一致性。不同数据库表的导出状态可以完全不同。mysqldump -uroot -p –host=localhost –all-databases –lock-tables</p>
<hr>
<p>–no-create-db, -n只导出数据，而不添加CREATE DATABASE 语句。mysqldump -uroot -p –host=localhost –all-databases –no-create-db</p>
<hr>
<p>–no-create-info, -t只导出数据，而不添加CREATE TABLE 语句。mysqldump -uroot -p –host=localhost –all-databases –no-create-info</p>
<hr>
<p>–no-data, -d不导出任何数据，只导出数据库表结构。mysqldump -uroot -p –host=localhost –all-databases –no-data</p>
<hr>
<p>–opt 这只是一个快捷选项，等同于同时添加 –add-drop-tables –add-locking –create-option –disable-keys –extended-insert –lock-tables –quick –set-charset 选项。本选项能让 mysqldump 很快的导出数据，并且导出的数据能很快导回。该选项默认开启，但可以用 –skip-opt 禁用。注意，如果运行 mysqldump 没有指定 –quick 或 –opt 选项，则会将整个结果集放在内存中。如果导出大数据库的话可能会出现问题</p>
</blockquote>
<h2 id="1-3-还原"><a href="#1-3-还原" class="headerlink" title="1.3.还原"></a>1.3.还原</h2><p>转载或分享请标明地址:<a href="http://blog.csdn.net/w19981220" target="_blank" rel="noopener">http://blog.csdn.net/w19981220</a> mysqldump -u用户名 -p密码 数据库 &lt; 路径 mysql -uroot -p1234 数据库名称&lt;路径 还可以使用这一种方法 首先先use 那一个数据库</p>
<pre><code>mysql&gt; source sql文件路径
</code></pre></blockquote>

            
            <p class="more">
                <a href="/2015/09/01/2019030500077/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/01/2019030500077/" title="mysql备份与还原">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <a class="extend prev" rel="prev" href="/categories/MySQL/page/5/">前一页</a><a class="page-number" href="/categories/MySQL/">1</a><span class="space">&hellip;</span><a class="page-number" href="/categories/MySQL/page/4/">4</a><a class="page-number" href="/categories/MySQL/page/5/">5</a><span class="page-number current">6</span><a class="page-number" href="/categories/MySQL/page/7/">7</a><a class="page-number" href="/categories/MySQL/page/8/">8</a><span class="space">&hellip;</span><a class="page-number" href="/categories/MySQL/page/10/">10</a><a class="extend next" rel="next" href="/categories/MySQL/page/7/">后一页</a>
    </nav>
    


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/MySQL/">MySQL</a>
        <span class="badge">(92)</span>
    </li>
    
    <li>
        <a href="/categories/开发语言/">开发语言</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="/categories/Oracle/">Oracle</a>
        <span class="badge">(40)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/">NOSQL</a>
        <span class="badge">(17)</span>
    </li>
    
    <li>
        <a href="/categories/其他数据库/">其他数据库</a>
        <span class="badge">(4)</span>
    </li>
    
    <li>
        <a href="/categories/SQL-Server/">SQL Server</a>
        <span class="badge">(13)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/">Oracle</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/SQL-Server/">SQL Server</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/开发语言/">开发语言</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/MySQL/" title="MySQL">MySQL (71)</a>
  
    <a class="tag-item" href="/tags/位运算/" title="位运算">位运算 (0)</a>
  
    <a class="tag-item" href="/tags/allow/" title="allow">allow (1)</a>
  
    <a class="tag-item" href="/tags/Apache/" title="Apache">Apache (1)</a>
  
    <a class="tag-item" href="/tags/deny/" title="deny">deny (1)</a>
  
    <a class="tag-item" href="/tags/sqlplus/" title="sqlplus">sqlplus (1)</a>
  
    <a class="tag-item" href="/tags/CentOS/" title="CentOS">CentOS (2)</a>
  
    <a class="tag-item" href="/tags/redis/" title="redis">redis (6)</a>
  
    <a class="tag-item" href="/tags/druid/" title="druid">druid (1)</a>
  
    <a class="tag-item" href="/tags/心跳/" title="心跳">心跳 (1)</a>
  
    <a class="tag-item" href="/tags/事务/" title="事务">事务 (5)</a>
  
    <a class="tag-item" href="/tags/分布式/" title="分布式">分布式 (1)</a>
  
    <a class="tag-item" href="/tags/消息/" title="消息">消息 (1)</a>
  
    <a class="tag-item" href="/tags/Oracle/" title="Oracle">Oracle (30)</a>
  
    <a class="tag-item" href="/tags/schedule-job/" title="schedule job">schedule job (1)</a>
  
    <a class="tag-item" href="/tags/KeepAlived/" title="KeepAlived">KeepAlived (1)</a>
  
    <a class="tag-item" href="/tags/分库/" title="分库">分库 (1)</a>
  
    <a class="tag-item" href="/tags/分库分表/" title="分库分表">分库分表 (1)</a>
  
    <a class="tag-item" href="/tags/分表/" title="分表">分表 (1)</a>
  
    <a class="tag-item" href="/tags/数据库/" title="数据库">数据库 (7)</a>
  
    <a class="tag-item" href="/tags/结构同步/" title="结构同步">结构同步 (1)</a>
  
    <a class="tag-item" href="/tags/truncate/" title="truncate">truncate (1)</a>
  
    <a class="tag-item" href="/tags/SQL/" title="SQL">SQL (17)</a>
  
    <a class="tag-item" href="/tags/批量/" title="批量">批量 (1)</a>
  
    <a class="tag-item" href="/tags/Excel/" title="Excel">Excel (1)</a>
  
    <a class="tag-item" href="/tags/Sqlite/" title="Sqlite">Sqlite (1)</a>
  
    <a class="tag-item" href="/tags/FineReport/" title="FineReport">FineReport (1)</a>
  
    <a class="tag-item" href="/tags/报表/" title="报表">报表 (1)</a>
  
    <a class="tag-item" href="/tags/数据集/" title="数据集">数据集 (1)</a>
  
    <a class="tag-item" href="/tags/Hash索引/" title="Hash索引">Hash索引 (1)</a>
  
    <a class="tag-item" href="/tags/InnoDB/" title="InnoDB">InnoDB (3)</a>
  
    <a class="tag-item" href="/tags/MyISAM/" title="MyISAM">MyISAM (3)</a>
  
    <a class="tag-item" href="/tags/索引优化/" title="索引优化">索引优化 (1)</a>
  
    <a class="tag-item" href="/tags/Linux/" title="Linux">Linux (2)</a>
  
    <a class="tag-item" href="/tags/Character-set/" title="Character set">Character set (1)</a>
  
    <a class="tag-item" href="/tags/NLS-LANG/" title="NLS_LANG">NLS_LANG (1)</a>
  
    <a class="tag-item" href="/tags/rowid/" title="rowid">rowid (2)</a>
  
    <a class="tag-item" href="/tags/重复/" title="重复">重复 (1)</a>
  
    <a class="tag-item" href="/tags/mysqldump/" title="mysqldump">mysqldump (2)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="http://www.devba.com" target="_blank" title="软件开发吧">软件开发吧</a>
        </li>
    
        <li>
            <a href="https://www.sqlyun.cn" target="_blank" title="SQL云笔记">SQL云</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>