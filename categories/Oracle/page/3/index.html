<!doctype html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8">
    <meta name="baidu-site-verification" content="dIcXMeY8Ya">
    
    <title>`Oracle`分类下的文章 | 软件开发吧</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="keywords" content="SQL云,SQL云开发,SQL笔记,SQL开发,云开发,MySQL,Oralce,数据库,数据库云,数据库开发,数据库云开发,SQL教程,数据库教程,开发笔记,MySQL笔记,MySQL教程">
    <meta name="description" content="为满足广大程序猿兄弟对日常工作中学习数据库、使用使用数据库资料查询需求，SQL云开发免费将自己整理的各种数据库技术资料分享出来，并希望与广大猿兄一起讨论学习与进步,致力于一起更方便、快捷资料学习查询,实现更安全、高效的数据存储.">

    
    <link rel="alternative" href="/atom.xml" title="软件开发吧" type="application/atom+xml">
    
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
</html>
<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">软件开发吧</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/categories/Oracle/page/3/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/categories/Oracle/page/3/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/categories/Oracle/page/3/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/categories/Oracle/page/3/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/sxyyhj" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.coding.me" target="_blank">Hosted by Coding Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon">
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 文章分类 -->

    <h3 class="widget-hd">
        <strong>
            
                `Oracle`分类下的文章
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/17/2019030500039/">
    		用plsql连接数据库创建视图
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-17T09:00:26.000Z">2015-09-17</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/数据库/" title="数据库">数据库</a> / 
    
        <a href="/tags/PL-SQL/" title="PL/SQL">PL/SQL</a> / 
    
        <a href="/tags/视图/" title="视图">视图</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>1 视图介绍 视图是一个逻辑表，也是一个非常重要的方案对象。实际上，视图是查看表的一种方式。视图是对根据预定义的选择标准由一个或多个行的集合建立起来的动态表的静态定义。视图可以用来定义来自一个或多个表的行和列的多种连接。通过视图，可以查看到表中的数据。 视图是查看数据库表中的数据的一种方法。视图提供了存储预定义的查询语句作为数据库中的对象以备以后使用的能力。视图只是一种逻辑对象，是一种虚拟表，并不是物理对象，因为视图不占物理存储空间。在视图中被查询的表称为视图的基表。 通常通过它就像使用表一样访问数据。要记住通过视图引用的数据通常来自它后面的基表。视图应该使用一致的命名约定。例如，给所有的视图增加一个前缀，如每一个视图都以v_、view_或vw_开头。这样，可以使用户在看到名称时就立即知道它代表的对象是视图。 2 视图好处 使用视图的优点，如集中用户使用的数据、掩码数据的复杂性、简化权限管理以及为向其他应用程序输出而重新组织数据等。 集中用户使用的数据： 视图创建了一种可以控制的环境，即表中的一部分数据允许访问，而另外一部分数据则不允许访问。那些没有必要的，敏感的或不适合的数据都从视图中排除掉了。 掩盖数据库的复杂性： 视图把数据库设计的复杂性与用户屏蔽分开。这样就为数据库开发人员提供了一种改变数据库的设计而不影响用户使用的能力。用户只需要查询视图就可以得到所需的数据，而不用编写复杂的查询语句或者执行脚本。 简化用户权限的管理：   数据库所有者可以把视图的权限授予需要查询的用户，而不必将基表中某些列的查询权限授予用户。 3 视图创建 可以使用3种方法创建视图，一种方法是使用create view 语句，另一种方法是使用DBA studio 图形工具，还可以使用创建视图向导来创建。 使用create view 语句创建视图 create [or replace][force | noforce] view [user.] viewName (column [,column2]…) as query [with check option[Constraint constraint]] [with read only] or replace 表示如果同名的视图存在，则使用新视图替代已有的视图。 force 强制创建视图，不考虑基表是否存在，是否具有使用基表数据的权限。 noforce 只有基表存在且具有权限，才可以创建视图。 user    表示创建视图的用户名。 viewName  表示将要在数据库上创建的视图名称。 column  指定视图中的列名。 query 表示生成视图的select语句。 with check option 指定强制检查通过视图修改数据的操作。 constraint  表示指定的约束名称。 with read only： 表示创建的视图只能检索数据，不能修改数据。   <img src="/uploads/2015/09/0_1315294657xlxy.bmp" alt>   4 视图和表的关系 视图和表是两种不同的数据库对象，其中的区别之一是在修改数据方面。修改表中的数据是直接修改数据，而修改视图中的数据是间接修改数据。因为视图本身并不包含数据，修改视图中的数据就是通过视图修改表中的数据。因此，修改视图中的数据有许多特殊的限制。 <img src="/uploads/2015/09/0_1315294856I5t5.bmp" alt></p>

            
            <p class="more">
                <a href="/2015/09/17/2019030500039/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/17/2019030500039/" title="用plsql连接数据库创建视图">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/7.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/16/2019030500150/">
    		PL/SQL Developer配置使用说明
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-16T07:26:42.000Z">2015-09-16</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a> / 
    
        <a href="/tags/PL-SQL/" title="PL/SQL">PL/SQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>PL/SQL Developer是一个集成开发环境，专门面向Oracle数据库存储程序单元的开发。如今，有越来越多的商业逻辑和应用逻辑转向了Oracle Server，因此，PL/SQL编程也成了整个开发过程的一个重要组成部分。PL/SQL Developer侧重于易用性、代码品质和生产力，充分发挥Oracle应用程序开发过程中的主要优势。 <strong>以下测试环境为 windows 7 32位。</strong> PL/SQL Developer绿色版 下载链接：<a href="http://pan.baidu.com/s/1hqwDToo" target="_blank" rel="noopener">http://pan.baidu.com/s/1hqwDToo</a> Oracle9i客户端精简版下载链接：<a href="http://pan.baidu.com/s/1mgL8pXu" target="_blank" rel="noopener">http://pan.baidu.com/s/1mgL8pXu</a> <strong>详细配置说明：</strong> 1）解压 PLSQLDeveloper.zip，此为绿色包，解压即可用： <img src="http://img.blog.csdn.net/20150914215145422" alt> 2）进入解压后的文件夹，plsqldev.exe 即为其可执行程序，暂时不能使用，还得相应配置，请看后面介绍： <img src="http://img.blog.csdn.net/20150914215245113" alt> 3）解压 Oracle9i客户端精简版.rar ： <img src="http://img.blog.csdn.net/20150914215437897" alt> 4）解压后，双击安装其中的安装包，默认只能安装在 C 盘： <img src="http://img.blog.csdn.net/20150914215631435" alt> 5）安装成功，C 盘多出一个Oracle文件夹： <img src="http://img.blog.csdn.net/20150914215824988" alt> 6）给 oracle 客户端设置 Path 环境变量： a)先拷贝需要设置环境变量的那个路径： <img src="http://img.blog.csdn.net/20150914220149021" alt> b)右击电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 高级 -&gt; 环境变量： <img src="http://img.blog.csdn.net/20150914220356736" alt> <img src="http://img.blog.csdn.net/20150914220443731" alt> <img src="http://img.blog.csdn.net/20150914220537246" alt> <img src="http://img.blog.csdn.net/20150914220629589" alt> Path 开头添加如下路径，路径和路径之间以分号分割： <img src="http://img.blog.csdn.net/20150914220847220" alt> 7)配置 PL/SQL Developer，打开时会跳出一个登陆窗口，取消即可，然后跳进一个 Developer 界面（没有登录）： <img src="http://img.blog.csdn.net/20150914221600770" alt> <img src="http://img.blog.csdn.net/20150914221657105" alt> 8）工具 -&gt; 首选项：</p>
<blockquote>
<blockquote>
<p>Oracle 主目录名 -&gt; C:\Oracle\ora90\BIN</p>
</blockquote>
<blockquote>
<p>OCI 库 -&gt; C:\Oracle\ora90\BIN\oci.dll</p>
</blockquote>
</blockquote>
<p><img src="http://img.blog.csdn.net/20150914221939746" alt> <img src="http://img.blog.csdn.net/20150914222054689" alt> 9）应用 -&gt; 确定 -&gt; 重新运行软件，发现比之前的登录界面多了一个选项“连接为”： <img src="http://img.blog.csdn.net/20150914222432701" alt> 10）添加数据库服务器信息，在 tnsnames.ora 配置文件，添加服务器信息： <img src="http://img.blog.csdn.net/20150914222647347" alt> 11）本示例中，在 tnsnames.ora 的最后添加如下内容：</p>
<p><strong>[plain]</strong></p>
<ol>
<li>ORA90 =</li>
<li>(DESCRIPTION =</li>
<li>(ADDRESS_LIST =</li>
<li>(ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.161.90)(PORT = 1521))</li>
<li>)</li>
<li>(CONNECT_DATA =</li>
<li>(SERVICE_NAME = ora11)</li>
<li>)</li>
<li>)</li>
</ol>
<p><img src="http://img.blog.csdn.net/20150914222848472" alt> 12）登录数据库服务器，填写登录信息： <img src="http://img.blog.csdn.net/20150914222940988" alt> 13）成功登录后的操作界面： <img src="http://img.blog.csdn.net/20150914223251032" alt> <img src="http://img.blog.csdn.net/20150914223359442" alt></p>

            
            <p class="more">
                <a href="/2015/09/16/2019030500150/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/16/2019030500150/" title="PL/SQL Developer配置使用说明">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/6.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/06/2019030500025/">
    		打开pl/sql developer出现NLS_LANG和字符集(Character set)问题
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-06T09:29:48.000Z">2015-09-06</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Character-set/" title="Character set">Character set</a> / 
    
        <a href="/tags/NLS-LANG/" title="NLS_LANG">NLS_LANG</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<h1 id="打开pl-sql-developer出现NLS-LANG和字符集-Character-set-问题"><a href="#打开pl-sql-developer出现NLS-LANG和字符集-Character-set-问题" class="headerlink" title="打开pl/sql developer出现NLS_LANG和字符集(Character  set)问题"></a>打开pl/sql developer出现NLS_LANG和字符集(Character  set)问题</h1><pre><code>公司最近培训pl/sql，我安装完毕后打开，遇到如图问题。
</code></pre><p><img src="http://img.blog.csdn.net/20150904093840189?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p>
<pre><code>PS：我的操作系统是英文的。

这是因为系统没有设置NLS_LANG系统变量。有两种方式查看。
</code></pre><p>1. 查看电脑属性。</p>
<p><img src="http://img.blog.csdn.net/20150904094431591?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p>
<p>2. 命令行查看。</p>
<p><img src="http://img.blog.csdn.net/20150904094853527?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p>
<pre><code>PS：这里我已经设置过了，所以仅仅是作个示意。

如果遇到如下图中的问题，说明客户端字符集与Oracle数据库的字符集不同。
</code></pre><p><img src="http://img.blog.csdn.net/20150904104459368?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p>
<pre><code>查看数据库的字符集的方法：
</code></pre><p><img src="http://img.blog.csdn.net/20150904104606224?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p>
<pre><code>对方的pl/sql语句是：
</code></pre><p><strong>[sql]</strong></p>
<ol>
<li>Select * from V$NLS_PARAMETERS where PARAMETER=’NLS_CHARACTERSET’;</li>
<li>Select USERENV(‘LANGUAGE’) from DUAL;</li>
</ol>
<p>将NLS_LANG的值改为所查到的SIMPLIFIED CHINESE_CHINA.UTF8即可。</p>
<p>PS：我们简介一下字符集的含义。以SIMPLIFIED CHINESE_CHINA.UTF8为例。</p>
<ul>
<li>SIMPLIFIED CHINESE为语言（简体中文）；</li>
<li>CHINA为国家（中国）；</li>
<li>UTF8为字符编码；</li>
</ul>
</blockquote>

            
            <p class="more">
                <a href="/2015/09/06/2019030500025/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/06/2019030500025/" title="打开pl/sql developer出现NLS_LANG和字符集(Character set)问题">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/6.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/01/2019030500151/">
    		plsql导出导入
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-01T07:29:02.000Z">2015-09-01</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/PL-SQL/" title="PL/SQL">PL/SQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>导出步骤： 1 tools -&gt;export user object 选择选项，导出.sql文件 2 tools -&gt;export tables-&gt; Oracle Export 选择选项导出.dmp文件 导入步骤： 1 tools-&gt;import tables-&gt;SQL Inserts 导入.sql文件 2 tools-&gt;import talbes-&gt;Oracle Import然后再导入dmp文件 数据库的导入导出成功 =======================解释===================================================================== Tools-&gt;Export User Objects导出的是建表语句（包括存储结构） Tools-&gt;Export Tables里面包含三种导出方式： 三种方式都能导出表结构以及数据，网上说三种方法有区别，如下： Oracle Export，Sql Insert，pl/sql developer 第一种是导出为.dmp的文件格式，.dmp文件是二进制的，可以跨平台，还能包含权限，效率也很不错，用得最广 第二种是导出为.sql文件的，可用文本编辑器查看，通用性比较好，但效率不如第一种，适合小数据量导入导出。尤其注意的是表中不能有大字段（blob,clob,long），如果有，会提示不能导出(提示如下： table contains one or more LONG columns cannot export in sql format,user Pl/sql developer format instead)，可以用第一种和第三种方式导出。 第三种是导出为.pde格式的，.pde为Pl/sql developer自有的文件格式，只能用Pl/sql developer自己导入导出；不能用编辑器查看。</p>

            
            <p class="more">
                <a href="/2015/09/01/2019030500151/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/01/2019030500151/" title="plsql导出导入">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/08/31/2019030500130/">
    		oracle创建外部表
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-08-31T08:56:59.000Z">2015-08-31</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p>oracle db允许以只读的形式查询外部表。外部表可以存储在任何oracle db可以读取的存储设备中，其内容不在db中保存，db只保存external table的metadata，db可以查询（join、sort）external table，可以创建view、synonym，但不可以执行DML语句。 创建外部表语法create table ……orginzition external，可以把外部表假想为一个view，可以正常的做select。 analyze 和 虚拟列 表分析不使用与外部表 创建外部表语法 外部表文件： example1.txt 360,Jane,Janus,ST_CLERK,121,17-MAY-2001,3000,0,50,jjanus 361,Mark,Jasper,SA_REP,145,17-MAY-2001,8000,.1,80,mjasper 362,Brenda,Starr,AD_ASST,200,17-MAY-2001,5500,0,10,bstarr 363,Alex,Alda,AC_MGR,145,17-MAY-2001,9000,.15,80,aalda example2.txt 401,Jesse,Cromwell,HR_REP,203,17-MAY-2001,7000,0,40,jcromwel 402,Abby,Applegate,IT_PROG,103,17-MAY-2001,9000,.2,60,aapplega 403,Carol,Cousins,AD_VP,100,17-MAY-2001,27000,.3,90,ccousins 404,John,Richardson,AC_ACCOUNT,205,17-MAY-2001,5000,0,110,jrichard 创建外部表oracle可识别路径：</p>
<pre><code>SQL&gt; conn / as sysdba
SQL&gt; create directory external_dir as &apos;/u01/app/oracle/oradata/external&apos;;

Directory created.

SQL&gt; grant read，write on directory external_dir to kevin;

Grant succeeded.
</code></pre><p>外部表的使用用户kevin，创建外部表</p>
<pre><code>SQL&gt; CREATE TABLE   ex_employees
  2                     (employee_id       NUMBER(4),
  3                      first_name        VARCHAR2(20),
  4                      last_name         VARCHAR2(25),
  5                      job_id            VARCHAR2(10),
  6                      manager_id        NUMBER(4),
  7                      hire_date         DATE,
  8                      salary            NUMBER(8,2),
  9                      commission_pct    NUMBER(2,2),
10                      department_id     NUMBER(4),
11                      email             VARCHAR2(25)
12                     )
13       ORGANIZATION EXTERNAL
14       (
15         TYPE ORACLE_LOADER
16         DEFAULT DIRECTORY external_dir
17         ACCESS PARAMETERS
18         (
19           records delimited by newline
20           badfile external_dir:&apos;empxt%a_%p.bad&apos;
21           logfile  external_dir:&apos;empxt%a_%p.log&apos;
22           fields terminated by &apos;,&apos;
23           missing field values are null
24           ( employee_id, first_name, last_name, job_id, manager_id,
25             hire_date char date_format date mask &quot;dd-mon-yyyy&quot;,
26             salary, commission_pct, department_id, email
27           )
28         )
29         LOCATION (&apos;example1.txt&apos;, &apos;example2.txt&apos;)
30       )
31       PARALLEL
32       REJECT LIMIT UNLIMITED;

Table created.
</code></pre><p>创建完成后可以可以通过cats把数据导入至数据库的表中，如果数据比较多，可以开启session level parallel导入</p>
<pre><code>alter session enable parallel；
create table employee as select * from ex_employee;

EMPLOYEE_ID FIRST_NAME           LAST_NAME                 JOB_ID     MANAGER_ID HIRE_DATE     SALARY COMMISSION_PCT DEPARTMENT_ID EMAIL
----------- -------------------- ------------------------- ---------- ---------- --------- ---------- -------------- ------------- -------------------------
        360 Jane                 Janus                     ST_CLERK          121 17-MAY-01       3000              0            50 jjanus
        361 Mark                 Jasper                    SA_REP            145 17-MAY-01       8000             .1            80 mjasper
        362 Brenda               Starr                     AD_ASST           200 17-MAY-01       5500              0            10 bstarr
        363 Alex                 Alda                      AC_MGR            145 17-MAY-01       9000            .15            80 aalda

        401 Jesse                Cromwell                  HR_REP            203 17-MAY-01       7000              0            40 jcromwel
        402 Abby                 Applegate                 IT_PROG           103 17-MAY-01       9000             .2            60 aapplega
        403 Carol                Cousins                   AD_VP             100 17-MAY-01      27000             .3            90 ccousins
        404 John                 Richardson                AC_ACCOUNT        205 17-MAY-01       5000              0           110 jrichard


10 rows selected.
</code></pre></blockquote>

            
            <p class="more">
                <a href="/2015/08/31/2019030500130/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/08/31/2019030500130/" title="oracle创建外部表">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/08/24/2019030500160/">
    		SQL-PL/SQL基础操作知识
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-08-24T04:58:11.000Z">2015-08-24</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/SQL/" title="SQL">SQL</a> / 
    
        <a href="/tags/SQL-PL/" title="SQL-PL">SQL-PL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>SQL的4GL，对流程控制的支持不够，Oracle的PL/SQL是3GL，添加了流程控制、变量等支持可以在数据库层面上进行程序的设计。</p>
<ul>
<li>PL/SQL的特点 1.支持事务控制和SQL. 2.数据类型在SQL的基础上进行了扩展。 3.PL/SQL可存储在Oracle数据库上。 4.可以对PL/SQL进行权限控制。</li>
<li>PL/SQL的优势 1.可以提高横向的运行性能。 2.可以使程序模块化。 3.可以采用逻辑控制语句来控制程序的结构。 4.利用运行时的错误信息，做日志记录。 5.良好的移植性。</li>
<li><p>PL/SQL的结构 pl/sql的基本单位是块，分为三部分：声明部分，执行部分和异常处理部分。 以declare作为开始标记，执行部分用begin作为标志，异常处理部分以exception作为标志，其中执行部分是必须有的。</p>
<p>[declare]<br>….<br>begin</p>
<pre><code>...
</code></pre><p>[exception]</p>
<pre><code>...
</code></pre><p>end;</p>
</li>
</ul>
<p>例如： 只包含执行体</p>
<pre><code>begin
    dbms.output.put_lin(&apos;执行体...&apos;);
end;
</code></pre><p>注意，在使用dbms_output之前要打开控制器输出开关:set serveroutput on; 包含声明和执行体两部分：</p>
<pre><code>declare
     v_result number(8,2);
begin
     v_result = 100 / 6;
     dbms_output.put_line(&apos;结果是：&apos;||v_result);
end;
</code></pre><p>包含声明、执行体和异常处理三部分</p>
<pre><code>declare
     v_ename varchar2(20);
begin
     select ename into v_ename from emp where empno=7369;
     dbms_output.put_line(&apos;姓名：&apos;||v_ename);
exception
     when no_data_found then
          dbms_output.put_line(&apos;没有该员工&apos;);
     when too_many_rows_exeption then
          dbms_output.put_line(&apos;数据过多&apos;);
end；
</code></pre><ul>
<li><p>PL/SQL中变量的使用 1.声明变量的语法结构</p>
<p>variable_name datatype[ [not null] {:=|default} expression];</p>
</li>
</ul>
<p>2.常量声明</p>
<pre><code>constant_name constant datatype
[not null]
{:=default} expression;
</code></pre><p>常量的datatype有以下三种： 1）标量类型：单一类型，不存在组合 2）复合类型：由几种单一类型组成 3）引用类型：使用其他数据项的引用 标量类型： 数值 number(pression,scade) binary_integer pls_integer simple_integer 字符 char varchar2 nvarchar long 布尔类型 true/false/null 日期类型 date/datestamp 复合类型（先定义后声明变量） 记录类型声明语法</p>
<pre><code>type type_name is recode
(
     field_name datatype
     [ [not null] {:=|default} expression]
     [,field_name datatype
       [not null]
       {:=|default} expression
     ]
);
</code></pre><p>VARRAY变长数组：它是一个存储有序元素的集合，适合较少的数据使用。 声明语法：</p>
<pre><code>type type_name is {varray} (size_limit) of element_type [not null]
</code></pre><ul>
<li>PL/SQL中的结构控制语句</li>
</ul>
<p>1.IF条件语句 ①</p>
<pre><code>IF condition THEN
     statement;
END IF;
</code></pre><p>②</p>
<pre><code>IF condition THEN
    statement;
ELSE
    statement;
ENDF IF;
</code></pre><p>③</p>
<pre><code>IF condition THEN
     statement;
ELSE IF condition THEN
     statement;
ELSE
     statement;
END IF;
</code></pre><p>2.CASE语句 ①简单case</p>
<pre><code>[&lt;&lt;label_name&gt;&gt;]

CASE case_operate
WHEN condition THEN
     statement;
[WHEN condition THEN
     statement;]
[ELSE 
     statement;]     

END CASE[&lt;&lt;label_name&gt;&gt;]
</code></pre><p>②搜索case</p>
<pre><code>[&lt;&lt;label_name&gt;&gt;]
CASE
  WHEN boolean_exp THEN statement;
  [WHEN boolean_exp THEN statement;]
  ...
  [ELSE statement;]

END CASE[&lt;&lt;label_name&gt;&gt;]
</code></pre><ul>
<li><p>LOOP循环控制语句 1.基本LOOP</p>
<p>[&lt;&lt;label_name&gt;&gt;]<br>LOOP</p>
<pre><code>statement;
</code></pre><p>END LOOP [&lt;&lt;label_name&gt;&gt;];</p>
</li>
</ul>
<p>基本loop语句通常和exit连用，否则会出现死循环</p>
<pre><code>[&lt;&lt;label_name&gt;&gt;]
loop
     ....
     exit when ...
     | if ... exit;
</code></pre><p>2.WHILE..LOOP</p>
<pre><code>[&lt;&lt;label_name&gt;&gt;]
when boolean_exp
loop
     statement;
end loop[&lt;&lt;label_name&gt;&gt;]
</code></pre><p>3.FOR…LOOP</p>
<pre><code>[&lt;&lt;label_name&gt;&gt;]
for index_name in 
[REVERSE]  //反向
lower_bound, upper_bound
loop
    statement;
end loop[&lt;&lt;label_name&gt;&gt;]
</code></pre>
            
            <p class="more">
                <a href="/2015/08/24/2019030500160/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/08/24/2019030500160/" title="SQL-PL/SQL基础操作知识">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/4.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/29/2019030500148/">
    		oracle11g exp导出问题：部分表导不出来
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-29T04:35:48.000Z">2015-07-29</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/exp/" title="exp">exp</a> / 
    
        <a href="/tags/oracle11g/" title="oracle11g">oracle11g</a> / 
    
        <a href="/tags/导出/" title="导出">导出</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>在oracle导出表的命令exp时候发现一个问题，就是部分表完全的导不出来，经检查发现只要是表为空的都会导不出来。 在如下表中发现segment_created都为NO的是导不出来的，经查询后，将语句提取出来执行即可。 select ‘alter table ‘|| table_name ||’ allocate extent;’ from user_tables where segment_created=’NO’; alter table table allocate extent; 备注：在11g中有一个特性就是参数deferred_segment_creation，默认是true的，表示段延迟创建。当创建一个新的表，并且该表还没有数据的情况</p>
<p>下，该表是不会分配extent的，所以说该表不占数据空间，此时没有分配segment，导致exp导不出来。因此，根据上述方法，查询user_tables表，如果segment_created为NO的，说明该表没有分配segment，查询出来执行下即可。</p>

            
            <p class="more">
                <a href="/2015/07/29/2019030500148/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/29/2019030500148/" title="oracle11g exp导出问题：部分表导不出来">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/9.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/21/2019030500149/">
    		PL/SQL Developer各个Window的功能
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-21T07:28:52.000Z">2015-07-21</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/PL-SQL/" title="PL/SQL">PL/SQL</a> / 
    
        <a href="/tags/Developer/" title="Developer">Developer</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>了解每个窗口的功能是正确使用PL/SQL Developer的首要条件，下边简要说明了PL/SQL Developer各个窗口的功能，希望能够理解： -<strong>程序窗口(program window) ：</strong>可以执行 sql,sqlplus 相关的语句，例如存储过程，方法，一般用来开发程序用的. 测试窗口(test window)：一般是用来测试存储过程等的debug。 -<strong>SQL窗口(sql window)：</strong>执行的是dml,ddl语句,主要用户语句的查询和显示（应用最多的一个窗口）。 -<strong>报告窗口(report window)：</strong>就是可以方便用于展示有聚合查询的用图表形式展示的窗口，例如sum(),count()等，有x,y轴的。 -<strong>命令窗口(command window)：</strong>除了可以执行sql, sqlplus 相关的命令，还可以执行更多的命令，例如call 等。 -<strong>解释计划窗口(plan window)：</strong>就是解释执行计划的，调优时，经常用到。 -<strong>图表窗口(diagram)：</strong>没有用过，不知道如何画图表的。</p>

            
            <p class="more">
                <a href="/2015/07/21/2019030500149/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/21/2019030500149/" title="PL/SQL Developer各个Window的功能">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/09/2019030500012/">
    		关于Oracle 10g的schedule job
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-09T05:35:10.000Z">2015-07-09</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a> / 
    
        <a href="/tags/schedule-job/" title="schedule job">schedule job</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>– job 权限 grant create job to somebody; – job 创建 begin dbms_scheduler.create_job ( job_name =&gt; ‘AGENT_LIQUIDATION_JOB’, job_type =&gt; ‘STORED_PROCEDURE’, job_action =&gt; ‘AGENT_LIQUIDATION.LIQUIDATION’, –存储过程名 start_date =&gt; sysdate, repeat_interval =&gt; ‘FREQ=MONTHLY; INTERVAL=1; BYMONTHDAY=1;BYHOUR=1;BYMINUTE=0;BYSECOND=0’,  – 按月，间隔为1个(月),每月1号,凌晨1点 comments =&gt; ‘执行代理商清分程序’ ); end; / – job 执行时间测试 DECLARE start_date date; return_date_after date; next_run_date date; BEGIN start_date := sysdate;–to_timestamp_tz(‘10-OCT-2004 10:00:00’,’DD-MM-YYYY HH24:MI:SS’); return_date_after := start_date; FOR i IN <strong>1</strong>..<strong>10</strong> LOOP DBMS_SCHEDULER.EVALUATE_CALENDAR_STRING(‘FREQ=MONTHLY; INTERVAL=1; BYMONTHDAY=1;BYHOUR=1;BYMINUTE=0;BYSECOND=0’,start_date, return_date_after, next_run_date); DBMS_OUTPUT.PUT_LINE(‘next_run_date: ‘ || to_char(next_run_date,’yyyy-mm-dd HH24:MI:SS’)); return_date_after := next_run_date; END LOOP; END; / – job 查询 select owner, job_name, state from dba_scheduler_jobs; select job_name, state from user_scheduler_jobs; – job 启用 begin dbms_scheduler.enable(‘BACKUP_JOB’); end; / – job 运行 begin dbms_scheduler.run_job(‘COLA_JOB’,TRUE); – true代表同步执行 end; / – job 停止(不太好用) begin dbms_scheduler.stop_job(job_name =&gt; ‘COLA_JOB’,force =&gt; TRUE); end; / – job 删除(对停job来说好用) begin dbms_scheduler.drop_job(job_name =&gt; ‘COLA_JOB’,force =&gt; TRUE);) end; /</p>

            
            <p class="more">
                <a href="/2015/07/09/2019030500012/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/09/2019030500012/" title="关于Oracle 10g的schedule job">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/9.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/02/2019030500127/">
    		Oracle中Hint深入理解
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-02T09:05:01.000Z">2015-07-02</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a> / 
    
        <a href="/tags/Hint/" title="Hint">Hint</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p><strong>Hint概述</strong> 基于代价的优化器是很聪明的，在绝大多数情况下它会选择正确的优化器，减轻了DBA的负担。但有时它也聪明反被聪明误，选择了很差的执行计划，使某个语句的执行变得奇慢无比。 此时就需要DBA进行人为的干预，告诉优化器使用我们指定的存取路径或连接类型生成执行计划，从 而使语句高效的运行。例如，如果我们认为对于一个特定的语句，执行全表扫描要比执行索引扫描更有效，则我们就可以指示优化器使用全表扫描。在Oracle 中，是通过为语句添加 Hints(提示)来实现干预优化器优化的目的。 不建议在代码中使用hint，在代码使用hint使得CBO无法根据实际的数据状态选择正确的执行计划。毕竟 数据是不断变化的， 10g以后的CBO也越来越完善，大多数情况下我们该让Oracle自行决定采用什么执行计划。 Oracle Hints是一种机制，用来告诉优化器按照我们的告诉它的方式生成执行计划。我们可以用Oracle Hints来实现： 1) 使用的优化器的类型 2) 基于代价的优化器的优化目标，是all_rows还是first_rows。 3) 表的访问路径，是全表扫描，还是索引扫描，还是直接利用rowid。 4) 表之间的连接类型 5) 表之间的连接顺序 6) 语句的并行程度 除了”RULE”提示外，一旦使用的别的提示，语句就会自动的改为使用CBO优化器，此时如果你的数据字典中没有统计数据，就会使用缺省的统计数据。所以建议大家如果使用CBO或Hints提示，则最好对表和索引进行定期的分析。 如何使用Hints: Hints只应用在它们所在sql语句块(statement block，由select、update、delete关键字标识)上，对其它SQL语句或语句的其它部分没有影响。如：对于使用union操作的2个sql语句，如果只在一个sql语句上有Hints，则该Hints不会影响另一个sql语句。 我们可以使用注释(comment)来为一个语句添加Hints，一个语句块只能有一个注释，而且注释只能放在SELECT, UPDATE, or DELETE关键字的后面 使用Oracle Hints的语法： {DELETE|INSERT|SELECT|UPDATE} /<em>+ hint [text] [hint[text]]… </em>/ or {DELETE|INSERT|SELECT|UPDATE} –+ hint [text] [hint[text]]… 注解： 1) DELETE、INSERT、SELECT和UPDATE是标识一个语句块开始的关键字，包含提示的注释只能出现在这些关键字的后面，否则提示无效。 2) “+”号表示该注释是一个Hints，该加号必须立即跟在”/<em>”的后面，中间不能有空格。 3) hint是下面介绍的具体提示之一，如果包含多个提示，则每个提示之间需要用一个或多个空格隔开。 4) text 是其它说明hint的注释性文本 5)使用表别名。如果在查询中指定了表别名，那么提示必须也使用表别名。例如：select /</em>+ index(e,dept_idx) <em>/ </em> from emp e; 6)不要在提示中使用模式名称：如果在提示中指定了模式的所有者，那么提示将被忽略。例如： select /<em>+ index(scott.emp,dept_idx) </em>/ <em> from emp 注意：如果你没有正确的指定Hints，Oracle将忽略该Hints，并且不会给出任何错误。 <strong>hint被忽略</strong> 如果CBO认为使用hint会导致错误的结果时，hint将被忽略，详见下例 SQL&gt; select /</em>+ index(t t_ind) <em>/ count(</em>) from t; Execution Plan ———————————————————- Plan hash value: 2966233522 ——————————————————————- | Id  | Operation          | Name | Rows  | Cost (%CPU)| Time     | ——————————————————————- |   0 | SELECT STATEMENT   |      |     1 |    57   (2)| 00:00:01 | |   1 |  SORT AGGREGATE    |      |     1 |            |          | |   2 |   TABLE ACCESS FULL| T    | 50366 |    57   (2)| 00:00:01 | ——————————————————————- 因为我们是对记录求总数，且我们并没有在建立索引时指定不能为空，索引如果CBO选择在索引上进行count时，但索引字段上的值为空时，结果将不准确，故CBO没有选择索引。 SQL&gt;  select /<em>+ index(t t_ind) </em>/ count(id) from t; Execution Plan ———————————————————- Plan hash value: 646498162 ————————————————————————– | Id  | Operation        | Name  | Rows  | Bytes | Cost (%CPU)| Time     | ————————————————————————– |   0 | SELECT STATEMENT |       |     1 |     5 |   285   (1)| 00:00:04 | |   1 |  SORT AGGREGATE  |       |     1 |     5 |            |          | |   2 |   INDEX FULL SCAN| T_IND | 50366 |   245K|   285   (1)| 00:00:04 | ————————————————————————– 因为我们只对id进行count，这个动作相当于count索引上的所有id值，这个操作和对表上的id字段进行count是一样的(组函数会忽略null值) <strong>Hint的具体用法</strong> <strong>和优化器相关的hint</strong> 1、/<em>+ ALL_ROWS </em>/ 表明对语句块选择基于开销的优化方法,并获得最佳吞吐量,使资源消耗最小化. SELECT /<em>+ ALL+_ROWS</em>/ EMP_NO,EMP_NAM,DAT_IN FROM BSEMPMS WHERE EMP_NO=’SCOTT’; 2、/<em>+ FIRST_ROWS(n) </em>/ 表明对语句块选择基于开销的优化方法,并获得最佳响应时间,使资源消耗最小化. SELECT /<em>+FIRST_ROWS(20) </em>/ EMP_NO,EMP_NAM,DAT_IN FROM BSEMPMS WHERE EMP_NO=’SCOTT’; 3、/<em>+ RULE</em>/ 表明对语句块选择基于规则的优化方法. SELECT /<em>+ RULE </em>/ EMP_NO,EMP_NAM,DAT_IN FROM BSEMPMS WHERE EMP_NO=’SCOTT’; <strong>和访问路径相关的hint</strong> 1、/<em>+ FULL(TABLE)</em>/ 表明对表选择全局扫描的方法. SELECT /<em>+FULL(A)</em>/ EMP_NO,EMP_NAM FROM BSEMPMS A WHERE EMP_NO=’SCOTT’; 2、/<em>+ INDEX(TABLE INDEX_NAME) </em>/ 表明对表选择索引的扫描方法. SELECT /<em>+INDEX(BSEMPMS SEX_INDEX) </em>/ <em> FROM BSEMPMS WHERE SEX=’M’; 5、/</em>+ INDEX_ASC(TABLE INDEX_NAME)<em>/ 表明对表选择索引升序的扫描方法. SELECT /</em>+INDEX_ASC(BSEMPMS PK_BSEMPMS) <em>/ </em> FROM BSEMPMS WHERE DPT_NO=’SCOTT’; 6、/<em>+ INDEX_COMBINE</em>/ 为指定表选择位图访问路经,如果INDEX_COMBINE中没有提供作为参数的索引,将选择出位图索引的布尔组合方式. SELECT /<em>+INDEX_COMBINE(BSEMPMS SAL_BMI HIREDATE_BMI) </em>/  <em> FROM BSEMPMS WHERE SAL&lt;5000000 AND HIREDATE 7、/</em>+ INDEX_JOIN(TABLE INDEX_NAME1 INDEX_NAME2) <em>/ 当谓词中引用的列都有索引的时候，可以通过指定采用索引关联的方式，来访问数据 select /</em>+ index_join(t t_ind t_bm) <em>/ id from t where id=100 and object_name=’EMPLOYEES’ 8、/</em>+ INDEX_DESC(TABLE INDEX_NAME)<em>/ 表明对表选择索引降序的扫描方法. SELECT /</em>+INDEX_DESC(BSEMPMS PK_BSEMPMS) <em>/ </em> FROM BSEMPMS WHERE DPT_NO=’SCOTT’; 9、/<em>+ INDEX_FFS(TABLE INDEX_NAME) </em>/ 对指定的表执行快速全索引扫描,而不是全表扫描的办法. SELECT /<em> + INDEX_FFS(BSEMPMS IN_EMPNAM)</em>/ <em> FROM BSEMPMS WHERE DPT_NO=’TEC305’; 10、/</em>+ INDEX_SS(T T_IND) <em>/ 从9i开始，oracle引入了这种索引访问方式。当在一个联合索引中，某些谓词条件并不在联合索引的第一列时，可以通过Index Skip Scan来访问索引获得数据。当联合索引第一列的唯一值个数很少时，使用这种方式比全表扫描效率高。 SQL&gt; create table t as select 1 id,object_name from dba_objects; Table created. SQL&gt; insert into t select 2,object_name from dba_objects; 50366 rows created. SQL&gt; insert into t select 3,object_name from dba_objects; 50366 rows created. SQL&gt; insert into t select 4,object_name from dba_objects; 50366 rows created. SQL&gt; commit; Commit complete. SQL&gt; create index t_ind on t(id,object_name); Index created. SQL&gt; exec dbms_stats.gather_table_stats(‘HR’,’T’,cascade=&gt;true); PL/SQL procedure successfully completed. 执行全表扫描 SQL&gt; select /</em>+ full(t) <em>/ </em> from t where object_name=’EMPLOYEES’; 6 rows selected. Execution Plan ———————————————————- Plan hash value: 1601196873 ————————————————————————– | Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     | ————————————————————————– |   0 | SELECT STATEMENT  |      |     5 |   135 |   215   (3)| 00:00:03 | |<em>  1 |  TABLE ACCESS FULL| T    |     5 |   135 |   215   (3)| 00:00:03 | ————————————————————————– Predicate Information (identified by operation id): ————————————————— 1 - filter(“OBJECT_NAME”=’EMPLOYEES’) Statistics ———————————————————- 0  recursive calls 0  db block gets 942  consistent gets 0  physical reads 0  redo size 538  bytes sent via SQL\</em>Net to client 385  bytes received via SQL*Net from client 2  SQL*Net roundtrips to/from client 0  sorts (memory) 0  sorts (disk) 6  rows processed 不采用hint SQL&gt;  select * from t where object_name=’EMPLOYEES’; 6 rows selected. Execution Plan ———————————————————- Plan hash value: 2869677071 ————————————————————————– | Id  | Operation        | Name  | Rows  | Bytes | Cost (%CPU)| Time     | ————————————————————————– |   0 | SELECT STATEMENT |       |     5 |   135 |     5   (0)| 00:00:01 | |<em>  1 |  INDEX SKIP SCAN | T_IND |     5 |   135 |     5   (0)| 00:00:01 | ————————————————————————– Predicate Information (identified by operation id): ————————————————— 1 - access(“OBJECT_NAME”=’EMPLOYEES’) filter(“OBJECT_NAME”=’EMPLOYEES’) Statistics ———————————————————- 1  recursive calls 0  db block gets 17  consistent gets 1  physical reads 0  redo size 538  bytes sent via SQL\</em>Net to client 385  bytes received via SQL*Net from client 2  SQL<em>Net roundtrips to/from client 0  sorts (memory) 0  sorts (disk) 6  rows processed 当全表扫描扫描了942个块，联合索引只扫描了17个数据块。可以看到联合索引的第一个字段的值重复率很高时，即使谓词中没有联合索引的第一个字段，依然会使用index_ss方式，效率远远高于全表扫描效率。但当 第一个字段的值重复率很低时，使用 index_ss的效率要低于 全表扫描，读者可以自行实验 <strong>和表的关联相关的hint</strong> /\</em>+ leading(table_1,table_2) <em>/ 在多表关联查询中，指定哪个表作为驱动表，即告诉优化器首先要访问哪个表上的数据。 select /</em>+ leading(t,t1) <em>/ t.</em> from t,t1 where t.id=t1.id; /<em>+ order </em>/ 让Oracle根据from后面表的顺序来选择驱动表，oracle建议使用leading，他更为灵活 select /<em>+ order </em>/ t.<em> from t,t1 where t.id=t1.id; /</em>+ use_nl(table_1,table_2) <em>/ 在多表关联查询中，指定使用nest loops方式进行多表关联。 select /</em>+ use_nl(t,t1) <em>/ t.</em> from t,t1 where t.id=t1.id; /<em>+ use_hash(table_1,table_2) </em>/ 在多表关联查询中，指定使用hash join方式进行多表关联。 select /<em>+ use_hash(t,t1) </em>/ t.<em> from t,t1 where t.id=t1.id; 在多表关联查询中，指定使用hash join方式进行多表关联，并指定表t为驱动表。 select /</em>+ use_hash(t,t1) leading(t,t1) <em>/ t.</em> from t,t1 where t.id=t1.id; /<em>+ use_merge(table_1,table_2) </em>/ 在多表关联查询中，指定使用merge join方式进行多表关联。 select /<em>+ use_merge(t,t1) </em>/ t.<em> from t,t1 where t.id=t1.id; /</em>+ no_use_nl(table_1,table_2) <em>/ 在多表关联查询中，指定不使用nest loops方式进行多表关联。 select /</em>+ no_use_nl(t,t1) <em>/ t.</em> from t,t1 where t.id=t1.id; /<em>+ no_use_hash(table_1,table_2) </em>/ 在多表关联查询中，指定不使用hash join方式进行多表关联。 select /<em>+ no_use_hash(t,t1) </em>/ t.<em> from t,t1 where t.id=t1.id; /</em>+ no_use_merge(table_1,table_2) <em>/ 在多表关联查询中，指定不使用merge join方式进行多表关联。 select /</em>+ no_use_merge(t,t1) <em>/ t.</em> from t,t1 where t.id=t1.id; <strong>其他常用的hint</strong> /*+ parallel(table_name n) <em>/ 在sql中指定执行的并行度，这个值将会覆盖自身的并行度 select /</em>+ parallel(t 4) <em>/ count(</em>)  from t; /<em>+ no_parallel(table_name) </em>/ 在sql中指定执行的不使用并行 select /<em>+ no_parallel(t) </em>/ count(<em>)  from t; /</em>+ append <em>/以直接加载的方式将数据加载入库 insert into t /</em>+ append <em>/ select </em> from t; /<em>+ dynamic_sampling(table_name n) </em>/ 设置sql执行时动态采用的级别，这个级别为0~10 select /<em>+ dynamic_sampling(t 4) </em>/ <em> from t where id &gt; 1234 /</em>+ cache(table_name) <em>/ 进行全表扫描时将table置于LRU列表的最活跃端，类似于table的cache属性 select /</em>+ full(employees) cache(employees) */ last_name from employees <strong>附录hint表格</strong></p>
<p><strong>Hints for Optimization Approaches and Goals</strong></p>
<p>ALL_ROWS</p>
<p>The ALL_ROWS hint explicitly chooses the cost-based approach to optimize a statement block with a goal of best throughput (that is, minimum total resource consumption).</p>
<p>FIRST_ROWS</p>
<p>The FIRST_ROWS hint explicitly chooses the cost-based approach to optimize a statement block with a goal of best response time (minimum resource usage to return first row). In newer Oracle version you should give a parameter with this hint: FIRST_ROWS(n) means that the optimizer will determine an executionplan to give a fast response for returning the first n rows.</p>
<p>CHOOSE</p>
<p>The CHOOSE hint causes the optimizer to choose between the rule-based approach and the cost-based approach for a SQL statement based on the presence of statistics for the tables accessed by the statement</p>
<p>RULE</p>
<p>The RULE hint explicitly chooses rule-based optimization for a statement block. This hint also causes the optimizer to ignore any other hints specified for the statement block. The RULE hint does not work any more in Oracle 10g.</p>
<p><strong>Hints for Access Paths</strong></p>
<p>FULL</p>
<p>The FULL hint explicitly chooses a full table scan for the specified table. The syntax of the FULL hint is FULL(table) where table specifies the alias of the table (or table name if alias does not exist) on which the full table scan is to be performed.</p>
<p>ROWID</p>
<p>The ROWID hint explicitly chooses a table scan by ROWID for the specified table. The syntax of the ROWID hint is ROWID(table) where table specifies the name or alias of the table on which the table access by ROWID is to be performed. (This hint depricated in Oracle 10g)</p>
<p>CLUSTER</p>
<p>The CLUSTER hint explicitly chooses a cluster scan to access the specified table. The syntax of the CLUSTER hint is CLUSTER(table) where table specifies the name or alias of the table to be accessed by a cluster scan.</p>
<p>HASH</p>
<p>The HASH hint explicitly chooses a hash scan to access the specified table. The syntax of the HASH hint is HASH(table) where table specifies the name or alias of the table to be accessed by a hash scan.</p>
<p>HASH_AJ</p>
<p>The HASH_AJ hint transforms a NOT IN subquery into a hash anti-join to access the specified table. The syntax of the HASH_AJ hint is HASH_AJ(table) where table specifies the name or alias of the table to be accessed.(depricated in Oracle 10g)</p>
<p>INDEX</p>
<p>The INDEX hint explicitly chooses an index scan for the specified table. The syntax of the INDEX hint is INDEX(table index) where:table specifies the name or alias of the table associated with the index to be scanned and index specifies an index on which an index scan is to be performed. This hint may optionally specify one or more indexes:</p>
<p>NO_INDEX</p>
<p>The NO_INDEX hint explicitly disallows a set of indexes for the specified table. The syntax of the NO_INDEX hint is NO_INDEX(table index)</p>
<p>INDEX_ASC</p>
<p>The INDEX_ASC hint explicitly chooses an index scan for the specified table. If the statement uses an index range scan, Oracle scans the index entries in ascending order of their indexed values.</p>
<p>INDEX_COMBINE</p>
<p>If no indexes are given as arguments for the INDEX_COMBINE hint, the optimizer will use on the table whatever boolean combination of bitmap indexes has the best cost estimate. If certain indexes are given as arguments, the optimizer will try to use some boolean combination of those particular bitmap indexes. The syntax of INDEX_COMBINE is INDEX_COMBINE(table index).</p>
<p>INDEX_JOIN</p>
<p>Explicitly instructs the optimizer to use an index join as an access path. For the hint to have a positive effect, a sufficiently small number of indexes must exist that contain all the columns required to resolve the query.</p>
<p>INDEX_DESC</p>
<p>The INDEX_DESC hint explicitly chooses an index scan for the specified table. If the statement uses an index range scan, Oracle scans the index entries in descending order of their indexed values.</p>
<p>INDEX_FFS</p>
<p>This hint causes a fast full index scan to be performed rather than a full table.</p>
<p>NO_INDEX_FFS</p>
<p>Do not use fast full index scan (from Oracle 10g)</p>
<p>INDEX_SS</p>
<p>Exclude range scan from query plan (from Oracle 10g)</p>
<p>INDEX_SS_ASC</p>
<p>Exclude range scan from query plan (from Oracle 10g)</p>
<p>INDEX_SS_DESC</p>
<p>Exclude range scan from query plan (from Oracle 10g)</p>
<p>NO_INDEX_SS</p>
<p>The NO_INDEX_SS hint causes the optimizer to exclude a skip scan of the specified indexes on the specified table. (from Oracle 10g)</p>
<p><strong>Hints for Query Transformations</strong></p>
<p>NO_QUERY_TRANSFORMATION</p>
<p>Prevents the optimizer performing query transformations. (from Oracle 10g)</p>
<p>USE_CONCAT</p>
<p>The USE_CONCAT hint forces combined OR conditions in the WHERE clause of a query to be transformed into a compound query using the UNION ALL set operator. Normally, this transformation occurs only if the cost of the query using the concatenations is cheaper than the cost without them.</p>
<p>NO_EXPAND</p>
<p>The NO_EXPAND hint prevents the optimizer from considering OR-expansion for queries having OR conditions or IN-lists in the WHERE clause. Usually, the optimizer considers using OR expansion and uses this method if it decides that the cost is lower than not using it.</p>
<p>REWRITE</p>
<p>The REWRITE hint forces the optimizer to rewrite a query in terms of materialized views, when possible, without cost consideration. Use the REWRITE hint with or without a view list. If you use REWRITE with a view list and the list contains an eligible materialized view, then Oracle uses that view regardless of its cost.</p>
<p>NOREWRITE / NO_REWRITE</p>
<p>In Oracle 10g renamed to NO_REWRITE. The NOREWRITE/NO_REWRITE hint disables query rewrite for the query block, overriding the setting of the parameter QUERY_REWRITE_ENABLED.</p>
<p>MERGE</p>
<p>The MERGE hint lets you merge views in a query.</p>
<p>NO_MERGE</p>
<p>The NO_MERGE hint causes Oracle not to merge mergeable views. This hint is most often used to reduce the number of possible permutations for a query and make optimization faster.</p>
<p>FACT</p>
<p>The FACT hint indicated that the table should be considered as a fact table. This is used in the context of the star transformation.</p>
<p>NO_FACT</p>
<p>The NO_FACT hint is used in the context of the star transformation to indicate to the transformation that the hinted table should not be considered as a fact table.</p>
<p>STAR_TRANSFORMATION</p>
<p>The STAR_TRANSFORMATION hint makes the optimizer use the best plan in which the transformation has been used. Without the hint, the optimizer could make a query optimization decision to use the best plan generated without the transformation, instead of the best plan for the transformed query.</p>
<p>NO_STAR_TRANSFORMATION</p>
<p>Do not use star transformation (from Oracle 10g)</p>
<p>UNNEST</p>
<p>The UNNEST hint specifies subquery unnesting.</p>
<p>NO_UNNEST</p>
<p>Use of the NO_UNNEST hint turns off unnesting for specific subquery blocks.</p>
<p><strong>Hints for Join Orders</strong></p>
<p>LEADING</p>
<p>Give this hint to indicate the leading table in a join. This will indicate only 1 table. If you want to specify the whole order of tables, you can use the ORDERED hint. Syntax: LEADING(table)</p>
<p>ORDERED</p>
<p>The ORDERED hint causes Oracle to join tables in the order in which they appear in the FROM clause. If you omit the ORDERED hint from a SQL statement performing a join , the optimizer chooses the order in which to join the tables. You may want to use the ORDERED hint to specify a join order if you know something about the number of rows selected from each table that the optimizer does not. Such information would allow you to choose an inner and outer table better than the optimizer could.</p>
<p><strong>Hints for Join Operations</strong></p>
<p>USE_NL</p>
<p>The USE_NL hint causes Oracle to join each specified table to another row source with a nested loops join using the specified table as the inner table. The syntax of the USE_NL hint is USE_NL(table table) where table is the name or alias of a table to be used as the inner table of a nested loops join.</p>
<p>NO_USE_NL</p>
<p>Do not use nested loop (from Oracle 10g)</p>
<p>USE_NL_WITH_INDEX</p>
<p>Specifies a nested loops join. (from Oracle 10g)</p>
<p>USE_MERGE</p>
<p>The USE_MERGE hint causes Oracle to join each specified table with another row source with a sort-merge join. The syntax of the USE_MERGE hint is USE_MERGE(table table) where table is a table to be joined to the row source resulting from joining the previous tables in the join order using a sort-merge join.</p>
<p>NO_USE_MERGE</p>
<p>Do not use merge (from Oracle 10g)</p>
<p>USE_HASH</p>
<p>The USE_HASH hint causes Oracle to join each specified table with another row source with a hash join. The syntax of the USE_HASH hint is USE_HASH(table table) where table is a table to be joined to the row source resulting from joining the previous tables in the join order using a hash join.</p>
<p>NO_USE_HASH</p>
<p>Do not use hash (from Oracle 10g)</p>
<p>Hints for Parallel Execution</p>
<p>PARALLEL</p>
<p>The PARALLEL hint allows you to specify the desired number of concurrent query servers that can be used for the query. The syntax is PARALLEL(table number number). The PARALLEL hint must use the table alias if an alias is specified in the query. The PARALLEL hint can then take two values separated by commas after the table name. The first value specifies the degree of parallelism for the given table, the second value specifies how the table is to be split among the instances of a parallel server. Specifying DEFAULT or no value signifies the query coordinator should examine the settings of the initialization parameters (described in a later section) to determine the default degree of parallelism.</p>
<p>NOPARALLEL / NO_PARALLEL</p>
<p>The NOPARALLEL hint allows you to disable parallel scanning of a table, even if the table was created with a PARALLEL clause. In Oracle 10g this hint was renamed to NO_PARALLEL.</p>
<p>PQ_DISTRIBUTE</p>
<p>The PQ_DISTRIBUTE hint improves the performance of parallel join operations. Do this by specifying how rows of joined tables should be distributed among producer and consumer query servers. Using this hint overrides decisions the optimizer would normally make.</p>
<p>NO_PARALLEL_INDEX</p>
<p>The NO_PARALLEL_INDEX hint overrides a PARALLEL attribute setting on an index to avoid a parallel index scan operation.</p>
<p>Additional Hints</p>
<p>APPEND</p>
<p>When the APPEND hint is used with the INSERT statement, data is appended to the table. Existing free space in the block is not used. If a table or an index is specified with nologging, this hint applied with an insert statement produces a direct path insert which reduces generation of redo.</p>
<p>NOAPPEND</p>
<p>Overrides the append mode.</p>
<p>CACHE</p>
<p>The CACHE hint specifies that the blocks retrieved for the table in the hint are placed at the most recently used end of the LRU list in the buffer cache when a full table scan is performed. This option is useful for small lookup tables. In the following example, the CACHE hint overrides the table default caching specification.</p>
<p>NOCACHE</p>
<p>The NOCACHE hint specifies that the blocks retrieved for this table are placed at the least recently used end of the LRU list in the buffer cache when a full table scan is performed. This is the normal behavior of blocks in the buffer cache.</p>
<p>PUSH_PRED</p>
<p>The PUSH_PRED hint forces pushing of a join predicate into the view.</p>
<p>NO_PUSH_PRED</p>
<p>The NO_PUSH_PRED hint prevents pushing of a join predicate into the view.</p>
<p>PUSH_SUBQ</p>
<p>The PUSH_SUBQ hint causes nonmerged subqueries to be evaluated at the earliest possible place in the execution plan.</p>
<p>NO_PUSH_SUBQ</p>
<p>The NO_PUSH_SUBQ hint causes non-merged subqueries to be evaluated as the last step in the execution plan.</p>
<p>QB_NAME</p>
<p>Specifies a name for a query block. (from Oracle 10g)</p>
<p>CURSOR_SHARING_EXACT</p>
<p>Oracle can replace literals in SQL statements with bind variables, if it is safe to do so. This is controlled with the CURSOR_SHARING startup parameter. The CURSOR_SHARING_EXACT hint causes this behavior to be switched off. In other words, Oracle executes the SQL statement without any attempt to replace literals by bind variables.</p>
<p>DRIVING_SITE</p>
<p>The DRIVING_SITE hint forces query execution to be done for the table at a different site than that selected by Oracle</p>
<p>DYNAMIC_SAMPLING</p>
<p>The DYNAMIC_SAMPLING hint lets you control dynamic sampling to improve server performance by determining more accurate predicate selectivity and statistics for tables and indexes. You can set the value of DYNAMIC_SAMPLING to a value from 0 to 10. The higher the level, the more effort the compiler puts into dynamic sampling and the more broadly it is applied. Sampling defaults to cursor level unless you specify a table.</p>
<p>SPREAD_MIN_ANALYSIS</p>
<p>This hint omits some of the compile time optimizations of the rules, mainly detailed dependency graph analysis, on spreadsheets. Some optimizations such as creating filters to selectively populate spreadsheet access structures and limited rule pruning are still used. (from Oracle 10g)</p>
<p><strong>Hints with unknown status</strong></p>
<p>MERGE_AJ</p>
<p>The MERGE_AJ hint transforms a NOT IN subquery into a merge anti-join to access the specified table. The syntax of the MERGE_AJ hint is MERGE_AJ(table) where table specifies the name or alias of the table to be accessed.(depricated in Oracle 10g)</p>
<p>AND_EQUAL</p>
<p>The AND_EQUAL hint explicitly chooses an execution plan that uses an access path that merges the scans on several single-column indexes. The syntax of the AND_EQUAL hint is AND_EQUAL(table index index) where table specifies the name or alias of the table associated with the indexes to be merged. and index specifies an index on which an index scan is to be performed. You must specify at least two indexes. You cannot specify more than five. (depricated in Oracle 10g)</p>
<p>STAR</p>
<p>The STAR hint forces the large table to be joined last using a nested loops join on the index. The optimizer will consider different permutations of the small tables. (depricated in Oracle 10g)</p>
<p>BITMAP</p>
<p>Usage: BITMAP(table_name index_name) Uses a bitmap index to access the table. (depricated ?)</p>
<p>HASH_SJ</p>
<p>Use a Hash Anti-Join to evaluate a NOT IN sub-query. Use this hint in the sub-query, not in the main query. Use this when your high volume NOT IN sub-query is using a FILTER or NESTED LOOPS join. Try MERGE_AJ if HASH_AJ refuses to work.(depricated in Oracle 10g)</p>
<p>NL_SJ</p>
<p>Use a Nested Loop in a sub-query. (depricated in Oracle 10g)</p>
<p>NL_AJ</p>
<p>Use an anti-join in a sub-query. (depricated in Oracle 10g)</p>
<p>ORDERED_PREDICATES</p>
<p>(depricated in Oracle 10g)</p>
<p>EXPAND_GSET_TO_UNION</p>
<p>(depricated in Oracle 10g)</p>
</blockquote>

            
            <p class="more">
                <a href="/2015/07/02/2019030500127/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/02/2019030500127/" title="Oracle中Hint深入理解">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <a class="extend prev" rel="prev" href="/categories/Oracle/page/2/">前一页</a><a class="page-number" href="/categories/Oracle/">1</a><a class="page-number" href="/categories/Oracle/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/categories/Oracle/page/4/">4</a><a class="extend next" rel="next" href="/categories/Oracle/page/4/">后一页</a>
    </nav>
    


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/MySQL/">MySQL</a>
        <span class="badge">(92)</span>
    </li>
    
    <li>
        <a href="/categories/开发语言/">开发语言</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="/categories/Oracle/">Oracle</a>
        <span class="badge">(40)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/">NOSQL</a>
        <span class="badge">(17)</span>
    </li>
    
    <li>
        <a href="/categories/SQL-Server/">SQL Server</a>
        <span class="badge">(13)</span>
    </li>
    
    <li>
        <a href="/categories/其他数据库/">其他数据库</a>
        <span class="badge">(4)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/">Oracle</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/SQL-Server/">SQL Server</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/开发语言/">开发语言</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/MySQL/" title="MySQL">MySQL (71)</a>
  
    <a class="tag-item" href="/tags/位运算/" title="位运算">位运算 (0)</a>
  
    <a class="tag-item" href="/tags/allow/" title="allow">allow (1)</a>
  
    <a class="tag-item" href="/tags/Apache/" title="Apache">Apache (1)</a>
  
    <a class="tag-item" href="/tags/deny/" title="deny">deny (1)</a>
  
    <a class="tag-item" href="/tags/sqlplus/" title="sqlplus">sqlplus (1)</a>
  
    <a class="tag-item" href="/tags/CentOS/" title="CentOS">CentOS (2)</a>
  
    <a class="tag-item" href="/tags/druid/" title="druid">druid (1)</a>
  
    <a class="tag-item" href="/tags/心跳/" title="心跳">心跳 (1)</a>
  
    <a class="tag-item" href="/tags/redis/" title="redis">redis (6)</a>
  
    <a class="tag-item" href="/tags/分库/" title="分库">分库 (1)</a>
  
    <a class="tag-item" href="/tags/分库分表/" title="分库分表">分库分表 (1)</a>
  
    <a class="tag-item" href="/tags/分表/" title="分表">分表 (1)</a>
  
    <a class="tag-item" href="/tags/Oracle/" title="Oracle">Oracle (30)</a>
  
    <a class="tag-item" href="/tags/schedule-job/" title="schedule job">schedule job (1)</a>
  
    <a class="tag-item" href="/tags/事务/" title="事务">事务 (5)</a>
  
    <a class="tag-item" href="/tags/分布式/" title="分布式">分布式 (1)</a>
  
    <a class="tag-item" href="/tags/消息/" title="消息">消息 (1)</a>
  
    <a class="tag-item" href="/tags/KeepAlived/" title="KeepAlived">KeepAlived (1)</a>
  
    <a class="tag-item" href="/tags/数据库/" title="数据库">数据库 (7)</a>
  
    <a class="tag-item" href="/tags/结构同步/" title="结构同步">结构同步 (1)</a>
  
    <a class="tag-item" href="/tags/truncate/" title="truncate">truncate (1)</a>
  
    <a class="tag-item" href="/tags/FineReport/" title="FineReport">FineReport (1)</a>
  
    <a class="tag-item" href="/tags/SQL/" title="SQL">SQL (17)</a>
  
    <a class="tag-item" href="/tags/报表/" title="报表">报表 (1)</a>
  
    <a class="tag-item" href="/tags/数据集/" title="数据集">数据集 (1)</a>
  
    <a class="tag-item" href="/tags/Excel/" title="Excel">Excel (1)</a>
  
    <a class="tag-item" href="/tags/Sqlite/" title="Sqlite">Sqlite (1)</a>
  
    <a class="tag-item" href="/tags/批量/" title="批量">批量 (1)</a>
  
    <a class="tag-item" href="/tags/Linux/" title="Linux">Linux (2)</a>
  
    <a class="tag-item" href="/tags/Character-set/" title="Character set">Character set (1)</a>
  
    <a class="tag-item" href="/tags/NLS-LANG/" title="NLS_LANG">NLS_LANG (1)</a>
  
    <a class="tag-item" href="/tags/rowid/" title="rowid">rowid (2)</a>
  
    <a class="tag-item" href="/tags/重复/" title="重复">重复 (1)</a>
  
    <a class="tag-item" href="/tags/Hash索引/" title="Hash索引">Hash索引 (1)</a>
  
    <a class="tag-item" href="/tags/InnoDB/" title="InnoDB">InnoDB (3)</a>
  
    <a class="tag-item" href="/tags/MyISAM/" title="MyISAM">MyISAM (3)</a>
  
    <a class="tag-item" href="/tags/索引优化/" title="索引优化">索引优化 (1)</a>
  
    <a class="tag-item" href="/tags/mysqldump/" title="mysqldump">mysqldump (2)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="http://www.devba.com" target="_blank" title="软件开发吧">软件开发吧</a>
        </li>
    
        <li>
            <a href="https://www.sqlyun.cn" target="_blank" title="SQL云笔记">SQL云</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>