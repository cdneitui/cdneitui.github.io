<!doctype html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8">
    <meta name="baidu-site-verification" content="dIcXMeY8Ya">
    
    <title>软件开发吧</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="keywords" content="Jelon, 前端, Web, 张德龙, 前端开发">
    <meta name="description" content="Jelon个人前端小站">

    
    <link rel="alternative" href="/atom.xml" title="软件开发吧" type="application/atom+xml">
    
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
</html>
<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">软件开发吧</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/page/13/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/page/13/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/page/13/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/page/13/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/jangdelong" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.coding.me" target="_blank">Hosted by Coding Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                        <a href="http://weibo.com/jangdelong" class="sinaweibo" target="_blank"><b>■</b> 新浪微博</a>
                    
                        <a href="https://www.facebook.com/profile.php?id=100011855760219&amp;ref=bookmarks" class="qqweibo" target="_blank"><b>■</b> Facebook</a>
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon">
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 首页 -->

    
    <h3 class="widget-hd">
        <strong>
            
                最近动态
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/SQL-Server/">SQL Server</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/06/2019030500168/">
    		SqlServer 批处理（Batch Requests/sec）过高追踪处理
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-06T05:15:30.000Z">2015-07-06</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/sqlserver/" title="sqlserver">sqlserver</a> / 
    
        <a href="/tags/Requests/" title="Requests">Requests</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p>近一段时间观察，监控发现一数据库的 每秒批处理请求数（Batch Requests/sec）经常升高持续较长时间，比平时高出几百，如下图： <img src="http://img.blog.csdn.net/20150706115817476?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> 由于一直比较高，以为是正常现象，没有注意。最近我们老大要求查看原因，所以跟踪查看，确实是数据库的非正常请求引起！ 先了解 批处理（Batch Requestsc）， 批处理简单理解为同时执行的一批SQL处理语句，一个批处理中可能有多个DML、多个存储过程等等。如在SSMS操作，每个’GO’执行前都属于一个批处理。 开始处理，用最笨的方法，打开SQL Server profiler  监控 SQL:BatchCompleted （sql批处理完成记录），但发现不是很多，每秒300左右，看起来正常，所以用 SQL Server profiler 不可行。 既然是批处理过多，批处理跟事务相关，可以打开性能监视器监控以下两个计数器： Batch Requests/sec Tranactions/sec(_Total) 发现 Tranactions/sec(_Total) 与 Batch Requests/sec 几乎是一致的，在继续查看Tranactions/sec ，把每个数据库都详细监控，确定只有 Tranactions/sec(master)  是最大的。与 master 连接相关的，如果不是系统的作业引起，可能就是连接引起，连接又有可能是内部的报表连接引起。排除除了SqlServer作业，再监控以下计数器： Connection Reset/sec Logins/sec Logout/sec 只有 Connection Reset/sec 是最频繁的，Logins/sec 和 Logout/sec 平均都在3左右。Connection Reset/sec 就是连接池连接过来的。 <strong>[plain]</strong></p>
<ol>
<li>“The sp_reset_connection stored procedure is used by SQL</li>
<li>Server to support remote stored procedure calls in a transaction. This stored</li>
<li>procedure also causes Audit Login and Audit Logout events to fire when a</li>
<li>connection is reused from a connection pool.”</li>
</ol>
<p>此时可以用 SQL Server profiler  监控以下事件： Audit Login Audit Logout <img src="http://img.blog.csdn.net/20150706110355594?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> 这时监控出来的数据就比较多了！~这个用户 <strong>cdwbcb</strong> 不断从连接池地连接和断开！非常频繁，可以确定是该用户引起的！ 接下来就好办了，打开SSMS连接到该数据库，执行以下语句。</p>
<p><strong>[sql]</strong></p>
<ol>
<li>select p.*,s.text</li>
<li>from master.dbo.sysprocesses p</li>
<li>cross apply sys.dm_exec_sql_text(p.sql_handle) s</li>
<li>where nt_username=’cdwbcb’</li>
</ol>
<p>找到相关数据：<img src="http://img.blog.csdn.net/20150706112721177?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> 数据库中保持了该用户的6个连接会话。奇怪的是，这些session的事务已经关闭（open_tran=0），处于空闲状态（status=sleeping），但是仍有命令等待执行（cmd=AWAITING COMMAND）！如果 open_tran=1 还可以理解，这个就无法解释了。但是产生这种情况，应该就是应用层方面的逻辑没处理好了。 暂时的解决方法：kill 该账户的几个会话。执行后很快降下来！ <img src="http://img.blog.csdn.net/20150706115607371?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt></p>
</blockquote>

            
            <p class="more">
                <a href="/2015/07/06/2019030500168/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/06/2019030500168/" title="SqlServer 批处理（Batch Requests/sec）过高追踪处理">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/6.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/02/2019030500127/">
    		Oracle中Hint深入理解
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-02T09:05:01.000Z">2015-07-02</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a> / 
    
        <a href="/tags/Hint/" title="Hint">Hint</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p><strong>Hint概述</strong> 基于代价的优化器是很聪明的，在绝大多数情况下它会选择正确的优化器，减轻了DBA的负担。但有时它也聪明反被聪明误，选择了很差的执行计划，使某个语句的执行变得奇慢无比。 此时就需要DBA进行人为的干预，告诉优化器使用我们指定的存取路径或连接类型生成执行计划，从 而使语句高效的运行。例如，如果我们认为对于一个特定的语句，执行全表扫描要比执行索引扫描更有效，则我们就可以指示优化器使用全表扫描。在Oracle 中，是通过为语句添加 Hints(提示)来实现干预优化器优化的目的。 不建议在代码中使用hint，在代码使用hint使得CBO无法根据实际的数据状态选择正确的执行计划。毕竟 数据是不断变化的， 10g以后的CBO也越来越完善，大多数情况下我们该让Oracle自行决定采用什么执行计划。 Oracle Hints是一种机制，用来告诉优化器按照我们的告诉它的方式生成执行计划。我们可以用Oracle Hints来实现： 1) 使用的优化器的类型 2) 基于代价的优化器的优化目标，是all_rows还是first_rows。 3) 表的访问路径，是全表扫描，还是索引扫描，还是直接利用rowid。 4) 表之间的连接类型 5) 表之间的连接顺序 6) 语句的并行程度 除了”RULE”提示外，一旦使用的别的提示，语句就会自动的改为使用CBO优化器，此时如果你的数据字典中没有统计数据，就会使用缺省的统计数据。所以建议大家如果使用CBO或Hints提示，则最好对表和索引进行定期的分析。 如何使用Hints: Hints只应用在它们所在sql语句块(statement block，由select、update、delete关键字标识)上，对其它SQL语句或语句的其它部分没有影响。如：对于使用union操作的2个sql语句，如果只在一个sql语句上有Hints，则该Hints不会影响另一个sql语句。 我们可以使用注释(comment)来为一个语句添加Hints，一个语句块只能有一个注释，而且注释只能放在SELECT, UPDATE, or DELETE关键字的后面 使用Oracle Hints的语法： {DELETE|INSERT|SELECT|UPDATE} /<em>+ hint [text] [hint[text]]… </em>/ or {DELETE|INSERT|SELECT|UPDATE} –+ hint [text] [hint[text]]… 注解： 1) DELETE、INSERT、SELECT和UPDATE是标识一个语句块开始的关键字，包含提示的注释只能出现在这些关键字的后面，否则提示无效。 2) “+”号表示该注释是一个Hints，该加号必须立即跟在”/<em>”的后面，中间不能有空格。 3) hint是下面介绍的具体提示之一，如果包含多个提示，则每个提示之间需要用一个或多个空格隔开。 4) text 是其它说明hint的注释性文本 5)使用表别名。如果在查询中指定了表别名，那么提示必须也使用表别名。例如：select /</em>+ index(e,dept_idx) <em>/ </em> from emp e; 6)不要在提示中使用模式名称：如果在提示中指定了模式的所有者，那么提示将被忽略。例如： select /<em>+ index(scott.emp,dept_idx) </em>/ <em> from emp 注意：如果你没有正确的指定Hints，Oracle将忽略该Hints，并且不会给出任何错误。 <strong>hint被忽略</strong> 如果CBO认为使用hint会导致错误的结果时，hint将被忽略，详见下例 SQL&gt; select /</em>+ index(t t_ind) <em>/ count(</em>) from t; Execution Plan ———————————————————- Plan hash value: 2966233522 ——————————————————————- | Id  | Operation          | Name | Rows  | Cost (%CPU)| Time     | ——————————————————————- |   0 | SELECT STATEMENT   |      |     1 |    57   (2)| 00:00:01 | |   1 |  SORT AGGREGATE    |      |     1 |            |          | |   2 |   TABLE ACCESS FULL| T    | 50366 |    57   (2)| 00:00:01 | ——————————————————————- 因为我们是对记录求总数，且我们并没有在建立索引时指定不能为空，索引如果CBO选择在索引上进行count时，但索引字段上的值为空时，结果将不准确，故CBO没有选择索引。 SQL&gt;  select /<em>+ index(t t_ind) </em>/ count(id) from t; Execution Plan ———————————————————- Plan hash value: 646498162 ————————————————————————– | Id  | Operation        | Name  | Rows  | Bytes | Cost (%CPU)| Time     | ————————————————————————– |   0 | SELECT STATEMENT |       |     1 |     5 |   285   (1)| 00:00:04 | |   1 |  SORT AGGREGATE  |       |     1 |     5 |            |          | |   2 |   INDEX FULL SCAN| T_IND | 50366 |   245K|   285   (1)| 00:00:04 | ————————————————————————– 因为我们只对id进行count，这个动作相当于count索引上的所有id值，这个操作和对表上的id字段进行count是一样的(组函数会忽略null值) <strong>Hint的具体用法</strong> <strong>和优化器相关的hint</strong> 1、/<em>+ ALL_ROWS </em>/ 表明对语句块选择基于开销的优化方法,并获得最佳吞吐量,使资源消耗最小化. SELECT /<em>+ ALL+_ROWS</em>/ EMP_NO,EMP_NAM,DAT_IN FROM BSEMPMS WHERE EMP_NO=’SCOTT’; 2、/<em>+ FIRST_ROWS(n) </em>/ 表明对语句块选择基于开销的优化方法,并获得最佳响应时间,使资源消耗最小化. SELECT /<em>+FIRST_ROWS(20) </em>/ EMP_NO,EMP_NAM,DAT_IN FROM BSEMPMS WHERE EMP_NO=’SCOTT’; 3、/<em>+ RULE</em>/ 表明对语句块选择基于规则的优化方法. SELECT /<em>+ RULE </em>/ EMP_NO,EMP_NAM,DAT_IN FROM BSEMPMS WHERE EMP_NO=’SCOTT’; <strong>和访问路径相关的hint</strong> 1、/<em>+ FULL(TABLE)</em>/ 表明对表选择全局扫描的方法. SELECT /<em>+FULL(A)</em>/ EMP_NO,EMP_NAM FROM BSEMPMS A WHERE EMP_NO=’SCOTT’; 2、/<em>+ INDEX(TABLE INDEX_NAME) </em>/ 表明对表选择索引的扫描方法. SELECT /<em>+INDEX(BSEMPMS SEX_INDEX) </em>/ <em> FROM BSEMPMS WHERE SEX=’M’; 5、/</em>+ INDEX_ASC(TABLE INDEX_NAME)<em>/ 表明对表选择索引升序的扫描方法. SELECT /</em>+INDEX_ASC(BSEMPMS PK_BSEMPMS) <em>/ </em> FROM BSEMPMS WHERE DPT_NO=’SCOTT’; 6、/<em>+ INDEX_COMBINE</em>/ 为指定表选择位图访问路经,如果INDEX_COMBINE中没有提供作为参数的索引,将选择出位图索引的布尔组合方式. SELECT /<em>+INDEX_COMBINE(BSEMPMS SAL_BMI HIREDATE_BMI) </em>/  <em> FROM BSEMPMS WHERE SAL&lt;5000000 AND HIREDATE 7、/</em>+ INDEX_JOIN(TABLE INDEX_NAME1 INDEX_NAME2) <em>/ 当谓词中引用的列都有索引的时候，可以通过指定采用索引关联的方式，来访问数据 select /</em>+ index_join(t t_ind t_bm) <em>/ id from t where id=100 and object_name=’EMPLOYEES’ 8、/</em>+ INDEX_DESC(TABLE INDEX_NAME)<em>/ 表明对表选择索引降序的扫描方法. SELECT /</em>+INDEX_DESC(BSEMPMS PK_BSEMPMS) <em>/ </em> FROM BSEMPMS WHERE DPT_NO=’SCOTT’; 9、/<em>+ INDEX_FFS(TABLE INDEX_NAME) </em>/ 对指定的表执行快速全索引扫描,而不是全表扫描的办法. SELECT /<em> + INDEX_FFS(BSEMPMS IN_EMPNAM)</em>/ <em> FROM BSEMPMS WHERE DPT_NO=’TEC305’; 10、/</em>+ INDEX_SS(T T_IND) <em>/ 从9i开始，oracle引入了这种索引访问方式。当在一个联合索引中，某些谓词条件并不在联合索引的第一列时，可以通过Index Skip Scan来访问索引获得数据。当联合索引第一列的唯一值个数很少时，使用这种方式比全表扫描效率高。 SQL&gt; create table t as select 1 id,object_name from dba_objects; Table created. SQL&gt; insert into t select 2,object_name from dba_objects; 50366 rows created. SQL&gt; insert into t select 3,object_name from dba_objects; 50366 rows created. SQL&gt; insert into t select 4,object_name from dba_objects; 50366 rows created. SQL&gt; commit; Commit complete. SQL&gt; create index t_ind on t(id,object_name); Index created. SQL&gt; exec dbms_stats.gather_table_stats(‘HR’,’T’,cascade=&gt;true); PL/SQL procedure successfully completed. 执行全表扫描 SQL&gt; select /</em>+ full(t) <em>/ </em> from t where object_name=’EMPLOYEES’; 6 rows selected. Execution Plan ———————————————————- Plan hash value: 1601196873 ————————————————————————– | Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     | ————————————————————————– |   0 | SELECT STATEMENT  |      |     5 |   135 |   215   (3)| 00:00:03 | |<em>  1 |  TABLE ACCESS FULL| T    |     5 |   135 |   215   (3)| 00:00:03 | ————————————————————————– Predicate Information (identified by operation id): ————————————————— 1 - filter(“OBJECT_NAME”=’EMPLOYEES’) Statistics ———————————————————- 0  recursive calls 0  db block gets 942  consistent gets 0  physical reads 0  redo size 538  bytes sent via SQL\</em>Net to client 385  bytes received via SQL*Net from client 2  SQL*Net roundtrips to/from client 0  sorts (memory) 0  sorts (disk) 6  rows processed 不采用hint SQL&gt;  select * from t where object_name=’EMPLOYEES’; 6 rows selected. Execution Plan ———————————————————- Plan hash value: 2869677071 ————————————————————————– | Id  | Operation        | Name  | Rows  | Bytes | Cost (%CPU)| Time     | ————————————————————————– |   0 | SELECT STATEMENT |       |     5 |   135 |     5   (0)| 00:00:01 | |<em>  1 |  INDEX SKIP SCAN | T_IND |     5 |   135 |     5   (0)| 00:00:01 | ————————————————————————– Predicate Information (identified by operation id): ————————————————— 1 - access(“OBJECT_NAME”=’EMPLOYEES’) filter(“OBJECT_NAME”=’EMPLOYEES’) Statistics ———————————————————- 1  recursive calls 0  db block gets 17  consistent gets 1  physical reads 0  redo size 538  bytes sent via SQL\</em>Net to client 385  bytes received via SQL*Net from client 2  SQL<em>Net roundtrips to/from client 0  sorts (memory) 0  sorts (disk) 6  rows processed 当全表扫描扫描了942个块，联合索引只扫描了17个数据块。可以看到联合索引的第一个字段的值重复率很高时，即使谓词中没有联合索引的第一个字段，依然会使用index_ss方式，效率远远高于全表扫描效率。但当 第一个字段的值重复率很低时，使用 index_ss的效率要低于 全表扫描，读者可以自行实验 <strong>和表的关联相关的hint</strong> /\</em>+ leading(table_1,table_2) <em>/ 在多表关联查询中，指定哪个表作为驱动表，即告诉优化器首先要访问哪个表上的数据。 select /</em>+ leading(t,t1) <em>/ t.</em> from t,t1 where t.id=t1.id; /<em>+ order </em>/ 让Oracle根据from后面表的顺序来选择驱动表，oracle建议使用leading，他更为灵活 select /<em>+ order </em>/ t.<em> from t,t1 where t.id=t1.id; /</em>+ use_nl(table_1,table_2) <em>/ 在多表关联查询中，指定使用nest loops方式进行多表关联。 select /</em>+ use_nl(t,t1) <em>/ t.</em> from t,t1 where t.id=t1.id; /<em>+ use_hash(table_1,table_2) </em>/ 在多表关联查询中，指定使用hash join方式进行多表关联。 select /<em>+ use_hash(t,t1) </em>/ t.<em> from t,t1 where t.id=t1.id; 在多表关联查询中，指定使用hash join方式进行多表关联，并指定表t为驱动表。 select /</em>+ use_hash(t,t1) leading(t,t1) <em>/ t.</em> from t,t1 where t.id=t1.id; /<em>+ use_merge(table_1,table_2) </em>/ 在多表关联查询中，指定使用merge join方式进行多表关联。 select /<em>+ use_merge(t,t1) </em>/ t.<em> from t,t1 where t.id=t1.id; /</em>+ no_use_nl(table_1,table_2) <em>/ 在多表关联查询中，指定不使用nest loops方式进行多表关联。 select /</em>+ no_use_nl(t,t1) <em>/ t.</em> from t,t1 where t.id=t1.id; /<em>+ no_use_hash(table_1,table_2) </em>/ 在多表关联查询中，指定不使用hash join方式进行多表关联。 select /<em>+ no_use_hash(t,t1) </em>/ t.<em> from t,t1 where t.id=t1.id; /</em>+ no_use_merge(table_1,table_2) <em>/ 在多表关联查询中，指定不使用merge join方式进行多表关联。 select /</em>+ no_use_merge(t,t1) <em>/ t.</em> from t,t1 where t.id=t1.id; <strong>其他常用的hint</strong> /*+ parallel(table_name n) <em>/ 在sql中指定执行的并行度，这个值将会覆盖自身的并行度 select /</em>+ parallel(t 4) <em>/ count(</em>)  from t; /<em>+ no_parallel(table_name) </em>/ 在sql中指定执行的不使用并行 select /<em>+ no_parallel(t) </em>/ count(<em>)  from t; /</em>+ append <em>/以直接加载的方式将数据加载入库 insert into t /</em>+ append <em>/ select </em> from t; /<em>+ dynamic_sampling(table_name n) </em>/ 设置sql执行时动态采用的级别，这个级别为0~10 select /<em>+ dynamic_sampling(t 4) </em>/ <em> from t where id &gt; 1234 /</em>+ cache(table_name) <em>/ 进行全表扫描时将table置于LRU列表的最活跃端，类似于table的cache属性 select /</em>+ full(employees) cache(employees) */ last_name from employees <strong>附录hint表格</strong></p>
<p><strong>Hints for Optimization Approaches and Goals</strong></p>
<p>ALL_ROWS</p>
<p>The ALL_ROWS hint explicitly chooses the cost-based approach to optimize a statement block with a goal of best throughput (that is, minimum total resource consumption).</p>
<p>FIRST_ROWS</p>
<p>The FIRST_ROWS hint explicitly chooses the cost-based approach to optimize a statement block with a goal of best response time (minimum resource usage to return first row). In newer Oracle version you should give a parameter with this hint: FIRST_ROWS(n) means that the optimizer will determine an executionplan to give a fast response for returning the first n rows.</p>
<p>CHOOSE</p>
<p>The CHOOSE hint causes the optimizer to choose between the rule-based approach and the cost-based approach for a SQL statement based on the presence of statistics for the tables accessed by the statement</p>
<p>RULE</p>
<p>The RULE hint explicitly chooses rule-based optimization for a statement block. This hint also causes the optimizer to ignore any other hints specified for the statement block. The RULE hint does not work any more in Oracle 10g.</p>
<p><strong>Hints for Access Paths</strong></p>
<p>FULL</p>
<p>The FULL hint explicitly chooses a full table scan for the specified table. The syntax of the FULL hint is FULL(table) where table specifies the alias of the table (or table name if alias does not exist) on which the full table scan is to be performed.</p>
<p>ROWID</p>
<p>The ROWID hint explicitly chooses a table scan by ROWID for the specified table. The syntax of the ROWID hint is ROWID(table) where table specifies the name or alias of the table on which the table access by ROWID is to be performed. (This hint depricated in Oracle 10g)</p>
<p>CLUSTER</p>
<p>The CLUSTER hint explicitly chooses a cluster scan to access the specified table. The syntax of the CLUSTER hint is CLUSTER(table) where table specifies the name or alias of the table to be accessed by a cluster scan.</p>
<p>HASH</p>
<p>The HASH hint explicitly chooses a hash scan to access the specified table. The syntax of the HASH hint is HASH(table) where table specifies the name or alias of the table to be accessed by a hash scan.</p>
<p>HASH_AJ</p>
<p>The HASH_AJ hint transforms a NOT IN subquery into a hash anti-join to access the specified table. The syntax of the HASH_AJ hint is HASH_AJ(table) where table specifies the name or alias of the table to be accessed.(depricated in Oracle 10g)</p>
<p>INDEX</p>
<p>The INDEX hint explicitly chooses an index scan for the specified table. The syntax of the INDEX hint is INDEX(table index) where:table specifies the name or alias of the table associated with the index to be scanned and index specifies an index on which an index scan is to be performed. This hint may optionally specify one or more indexes:</p>
<p>NO_INDEX</p>
<p>The NO_INDEX hint explicitly disallows a set of indexes for the specified table. The syntax of the NO_INDEX hint is NO_INDEX(table index)</p>
<p>INDEX_ASC</p>
<p>The INDEX_ASC hint explicitly chooses an index scan for the specified table. If the statement uses an index range scan, Oracle scans the index entries in ascending order of their indexed values.</p>
<p>INDEX_COMBINE</p>
<p>If no indexes are given as arguments for the INDEX_COMBINE hint, the optimizer will use on the table whatever boolean combination of bitmap indexes has the best cost estimate. If certain indexes are given as arguments, the optimizer will try to use some boolean combination of those particular bitmap indexes. The syntax of INDEX_COMBINE is INDEX_COMBINE(table index).</p>
<p>INDEX_JOIN</p>
<p>Explicitly instructs the optimizer to use an index join as an access path. For the hint to have a positive effect, a sufficiently small number of indexes must exist that contain all the columns required to resolve the query.</p>
<p>INDEX_DESC</p>
<p>The INDEX_DESC hint explicitly chooses an index scan for the specified table. If the statement uses an index range scan, Oracle scans the index entries in descending order of their indexed values.</p>
<p>INDEX_FFS</p>
<p>This hint causes a fast full index scan to be performed rather than a full table.</p>
<p>NO_INDEX_FFS</p>
<p>Do not use fast full index scan (from Oracle 10g)</p>
<p>INDEX_SS</p>
<p>Exclude range scan from query plan (from Oracle 10g)</p>
<p>INDEX_SS_ASC</p>
<p>Exclude range scan from query plan (from Oracle 10g)</p>
<p>INDEX_SS_DESC</p>
<p>Exclude range scan from query plan (from Oracle 10g)</p>
<p>NO_INDEX_SS</p>
<p>The NO_INDEX_SS hint causes the optimizer to exclude a skip scan of the specified indexes on the specified table. (from Oracle 10g)</p>
<p><strong>Hints for Query Transformations</strong></p>
<p>NO_QUERY_TRANSFORMATION</p>
<p>Prevents the optimizer performing query transformations. (from Oracle 10g)</p>
<p>USE_CONCAT</p>
<p>The USE_CONCAT hint forces combined OR conditions in the WHERE clause of a query to be transformed into a compound query using the UNION ALL set operator. Normally, this transformation occurs only if the cost of the query using the concatenations is cheaper than the cost without them.</p>
<p>NO_EXPAND</p>
<p>The NO_EXPAND hint prevents the optimizer from considering OR-expansion for queries having OR conditions or IN-lists in the WHERE clause. Usually, the optimizer considers using OR expansion and uses this method if it decides that the cost is lower than not using it.</p>
<p>REWRITE</p>
<p>The REWRITE hint forces the optimizer to rewrite a query in terms of materialized views, when possible, without cost consideration. Use the REWRITE hint with or without a view list. If you use REWRITE with a view list and the list contains an eligible materialized view, then Oracle uses that view regardless of its cost.</p>
<p>NOREWRITE / NO_REWRITE</p>
<p>In Oracle 10g renamed to NO_REWRITE. The NOREWRITE/NO_REWRITE hint disables query rewrite for the query block, overriding the setting of the parameter QUERY_REWRITE_ENABLED.</p>
<p>MERGE</p>
<p>The MERGE hint lets you merge views in a query.</p>
<p>NO_MERGE</p>
<p>The NO_MERGE hint causes Oracle not to merge mergeable views. This hint is most often used to reduce the number of possible permutations for a query and make optimization faster.</p>
<p>FACT</p>
<p>The FACT hint indicated that the table should be considered as a fact table. This is used in the context of the star transformation.</p>
<p>NO_FACT</p>
<p>The NO_FACT hint is used in the context of the star transformation to indicate to the transformation that the hinted table should not be considered as a fact table.</p>
<p>STAR_TRANSFORMATION</p>
<p>The STAR_TRANSFORMATION hint makes the optimizer use the best plan in which the transformation has been used. Without the hint, the optimizer could make a query optimization decision to use the best plan generated without the transformation, instead of the best plan for the transformed query.</p>
<p>NO_STAR_TRANSFORMATION</p>
<p>Do not use star transformation (from Oracle 10g)</p>
<p>UNNEST</p>
<p>The UNNEST hint specifies subquery unnesting.</p>
<p>NO_UNNEST</p>
<p>Use of the NO_UNNEST hint turns off unnesting for specific subquery blocks.</p>
<p><strong>Hints for Join Orders</strong></p>
<p>LEADING</p>
<p>Give this hint to indicate the leading table in a join. This will indicate only 1 table. If you want to specify the whole order of tables, you can use the ORDERED hint. Syntax: LEADING(table)</p>
<p>ORDERED</p>
<p>The ORDERED hint causes Oracle to join tables in the order in which they appear in the FROM clause. If you omit the ORDERED hint from a SQL statement performing a join , the optimizer chooses the order in which to join the tables. You may want to use the ORDERED hint to specify a join order if you know something about the number of rows selected from each table that the optimizer does not. Such information would allow you to choose an inner and outer table better than the optimizer could.</p>
<p><strong>Hints for Join Operations</strong></p>
<p>USE_NL</p>
<p>The USE_NL hint causes Oracle to join each specified table to another row source with a nested loops join using the specified table as the inner table. The syntax of the USE_NL hint is USE_NL(table table) where table is the name or alias of a table to be used as the inner table of a nested loops join.</p>
<p>NO_USE_NL</p>
<p>Do not use nested loop (from Oracle 10g)</p>
<p>USE_NL_WITH_INDEX</p>
<p>Specifies a nested loops join. (from Oracle 10g)</p>
<p>USE_MERGE</p>
<p>The USE_MERGE hint causes Oracle to join each specified table with another row source with a sort-merge join. The syntax of the USE_MERGE hint is USE_MERGE(table table) where table is a table to be joined to the row source resulting from joining the previous tables in the join order using a sort-merge join.</p>
<p>NO_USE_MERGE</p>
<p>Do not use merge (from Oracle 10g)</p>
<p>USE_HASH</p>
<p>The USE_HASH hint causes Oracle to join each specified table with another row source with a hash join. The syntax of the USE_HASH hint is USE_HASH(table table) where table is a table to be joined to the row source resulting from joining the previous tables in the join order using a hash join.</p>
<p>NO_USE_HASH</p>
<p>Do not use hash (from Oracle 10g)</p>
<p>Hints for Parallel Execution</p>
<p>PARALLEL</p>
<p>The PARALLEL hint allows you to specify the desired number of concurrent query servers that can be used for the query. The syntax is PARALLEL(table number number). The PARALLEL hint must use the table alias if an alias is specified in the query. The PARALLEL hint can then take two values separated by commas after the table name. The first value specifies the degree of parallelism for the given table, the second value specifies how the table is to be split among the instances of a parallel server. Specifying DEFAULT or no value signifies the query coordinator should examine the settings of the initialization parameters (described in a later section) to determine the default degree of parallelism.</p>
<p>NOPARALLEL / NO_PARALLEL</p>
<p>The NOPARALLEL hint allows you to disable parallel scanning of a table, even if the table was created with a PARALLEL clause. In Oracle 10g this hint was renamed to NO_PARALLEL.</p>
<p>PQ_DISTRIBUTE</p>
<p>The PQ_DISTRIBUTE hint improves the performance of parallel join operations. Do this by specifying how rows of joined tables should be distributed among producer and consumer query servers. Using this hint overrides decisions the optimizer would normally make.</p>
<p>NO_PARALLEL_INDEX</p>
<p>The NO_PARALLEL_INDEX hint overrides a PARALLEL attribute setting on an index to avoid a parallel index scan operation.</p>
<p>Additional Hints</p>
<p>APPEND</p>
<p>When the APPEND hint is used with the INSERT statement, data is appended to the table. Existing free space in the block is not used. If a table or an index is specified with nologging, this hint applied with an insert statement produces a direct path insert which reduces generation of redo.</p>
<p>NOAPPEND</p>
<p>Overrides the append mode.</p>
<p>CACHE</p>
<p>The CACHE hint specifies that the blocks retrieved for the table in the hint are placed at the most recently used end of the LRU list in the buffer cache when a full table scan is performed. This option is useful for small lookup tables. In the following example, the CACHE hint overrides the table default caching specification.</p>
<p>NOCACHE</p>
<p>The NOCACHE hint specifies that the blocks retrieved for this table are placed at the least recently used end of the LRU list in the buffer cache when a full table scan is performed. This is the normal behavior of blocks in the buffer cache.</p>
<p>PUSH_PRED</p>
<p>The PUSH_PRED hint forces pushing of a join predicate into the view.</p>
<p>NO_PUSH_PRED</p>
<p>The NO_PUSH_PRED hint prevents pushing of a join predicate into the view.</p>
<p>PUSH_SUBQ</p>
<p>The PUSH_SUBQ hint causes nonmerged subqueries to be evaluated at the earliest possible place in the execution plan.</p>
<p>NO_PUSH_SUBQ</p>
<p>The NO_PUSH_SUBQ hint causes non-merged subqueries to be evaluated as the last step in the execution plan.</p>
<p>QB_NAME</p>
<p>Specifies a name for a query block. (from Oracle 10g)</p>
<p>CURSOR_SHARING_EXACT</p>
<p>Oracle can replace literals in SQL statements with bind variables, if it is safe to do so. This is controlled with the CURSOR_SHARING startup parameter. The CURSOR_SHARING_EXACT hint causes this behavior to be switched off. In other words, Oracle executes the SQL statement without any attempt to replace literals by bind variables.</p>
<p>DRIVING_SITE</p>
<p>The DRIVING_SITE hint forces query execution to be done for the table at a different site than that selected by Oracle</p>
<p>DYNAMIC_SAMPLING</p>
<p>The DYNAMIC_SAMPLING hint lets you control dynamic sampling to improve server performance by determining more accurate predicate selectivity and statistics for tables and indexes. You can set the value of DYNAMIC_SAMPLING to a value from 0 to 10. The higher the level, the more effort the compiler puts into dynamic sampling and the more broadly it is applied. Sampling defaults to cursor level unless you specify a table.</p>
<p>SPREAD_MIN_ANALYSIS</p>
<p>This hint omits some of the compile time optimizations of the rules, mainly detailed dependency graph analysis, on spreadsheets. Some optimizations such as creating filters to selectively populate spreadsheet access structures and limited rule pruning are still used. (from Oracle 10g)</p>
<p><strong>Hints with unknown status</strong></p>
<p>MERGE_AJ</p>
<p>The MERGE_AJ hint transforms a NOT IN subquery into a merge anti-join to access the specified table. The syntax of the MERGE_AJ hint is MERGE_AJ(table) where table specifies the name or alias of the table to be accessed.(depricated in Oracle 10g)</p>
<p>AND_EQUAL</p>
<p>The AND_EQUAL hint explicitly chooses an execution plan that uses an access path that merges the scans on several single-column indexes. The syntax of the AND_EQUAL hint is AND_EQUAL(table index index) where table specifies the name or alias of the table associated with the indexes to be merged. and index specifies an index on which an index scan is to be performed. You must specify at least two indexes. You cannot specify more than five. (depricated in Oracle 10g)</p>
<p>STAR</p>
<p>The STAR hint forces the large table to be joined last using a nested loops join on the index. The optimizer will consider different permutations of the small tables. (depricated in Oracle 10g)</p>
<p>BITMAP</p>
<p>Usage: BITMAP(table_name index_name) Uses a bitmap index to access the table. (depricated ?)</p>
<p>HASH_SJ</p>
<p>Use a Hash Anti-Join to evaluate a NOT IN sub-query. Use this hint in the sub-query, not in the main query. Use this when your high volume NOT IN sub-query is using a FILTER or NESTED LOOPS join. Try MERGE_AJ if HASH_AJ refuses to work.(depricated in Oracle 10g)</p>
<p>NL_SJ</p>
<p>Use a Nested Loop in a sub-query. (depricated in Oracle 10g)</p>
<p>NL_AJ</p>
<p>Use an anti-join in a sub-query. (depricated in Oracle 10g)</p>
<p>ORDERED_PREDICATES</p>
<p>(depricated in Oracle 10g)</p>
<p>EXPAND_GSET_TO_UNION</p>
<p>(depricated in Oracle 10g)</p>
</blockquote>

            
            <p class="more">
                <a href="/2015/07/02/2019030500127/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/02/2019030500127/" title="Oracle中Hint深入理解">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/02/2019030500122/">
    		NoSQL数据库概览及其与SQL语法的比较
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-02T06:14:20.000Z">2015-07-02</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/NoSQL/" title="NoSQL">NoSQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p><strong>【文章摘要</strong>】 HBase是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，同时也是知名的NoSQL数据库之一。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用的难题。 本文对NoSQL数据库的定义、分类、特征、当前比较流行的NoSQL数据库系统等进行了简单的介绍，并对NoSQL和SQL语法进行了简单的比较，为大家对NoSQL数据库的学习提供了有益的参考。   <strong>一、NoSQL的出现</strong> 关系型数据库系统多年来在解决数据存储、服务和处理问题方面取得了巨大的成功。一些大型的公司使用关系型数据库建立了自己的系统，如联机事务处理系统和后端分析应用系统。联机事务处理(OLTP)系统用来实时记录交易信息。对这类系统的期望是能够快速返回响应信息(一般在毫秒级)。联机分析处理(OLAP)系统用来分析查询所储存的数据。OLAP属于商业智能的范畴，数据需要研究、处理和分析，以便收集信息，进一步驱动商业决策。 关系型数据库的内部设计由关系算法决定，这些系统需要预先定义一个模式(schema)和数据要遵守的类型。SQL是与这些系统交互的标准方式。但在对象-关系不匹配问题出现的场合，SQL就不是表达访问模式的最好方式了。例如目前炙手可热的大数据领域，关系型数据库不能很好地工作。 有关大数据常见定义包括：第一，大数据意味着数据足够大，为了从这些数据中获得一些真知灼见，你不得不研究它；第二，大数据就是不再适用于单台机器的数据。这些观点并不完整，我们需要用一种根本上不同的方式来考虑数据，从如何驱动商业价值的角度来考虑数据，这种数据就是大数据。 在大数据领域中，系统需要能够适应不同种类的数据格式和数据源，不需要预先严格定义模式，并且能够处理大规模数据。这样，NoSQL就出现了。   <strong>二、NoSQL的定义</strong> NoSQL(NoSQL= Not Only SQL )，意即“不仅仅是SQL”，是一项全新的数据库革命性运动。NoSQL的拥护者们提倡运用非关系型的数据存储。大多数数据库技术不能保证支持ACID(原子性、一致性、隔离性和持久性)，而且大部分技术都是开源项目，这些技术作为整体被称为NoSQL。   <strong>三、NoSQL的分类</strong> 一般将NoSQL数据库分为四大类：键值(Key-Value)存储数据库、列存储数据库、文档型数据库和图形(Graph)数据库。它们的数据模型、优缺点、典型应用场景如表1所示。</p>
<p>表1 四大NoSQL数据库分析</p>
<p><strong>分类</strong></p>
<p><strong>数据模型</strong></p>
<p><strong>优点</strong></p>
<p><strong>缺点</strong></p>
<p><strong>典型应用场景</strong></p>
<p>键值(Key-Value)存储数据库</p>
<p>Key指向Value的键值对，通常用hash表来实现</p>
<p>查找速度快</p>
<p>数据无结构化(通常只被当作字符串或者二进制数据)</p>
<p>内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等</p>
<p>列存储数据库</p>
<p>以列簇式存储，将同一列数据存在一起</p>
<p>查找速度快，可扩展性强，更容易进行分布式扩展</p>
<p>功能相对局限</p>
<p>分布式的文件系统</p>
<p>文档型数据库</p>
<p>Key-Value对应的键值对，Value为结构化数据</p>
<p>数据结构要求不严格，表结构可变(不需要像关系型数据库一样需预先定义表结构)</p>
<p>查询性能不高，而且缺乏统一的查询语法</p>
<p>Web应用</p>
<p>图形(Graph)数据库</p>
<p>图结构</p>
<p>利用图结构相关算法(如最短路径寻址，N度关系查找等)</p>
<p>很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案</p>
<p>社交网络，推荐系统等</p>
<pre><code>**四、NoSQL的特征** NoSQL数据库并没有一个统一的架构，但是它们都普遍存在表2所示的一些共同特征。
</code></pre><p>表2 NoSQL的特征</p>
<p><strong>特征</strong></p>
<p><strong>描述</strong></p>
<p>不需要预定义模式</p>
<p>不需事先定义数据模式，预定义表结构等。数据中每条记录都可能有不同的属性和格式</p>
<p>无共享架构</p>
<p>NoSQL往往将数据划分后存储在各个本地服务器上，从而提高了系统的性能</p>
<p>弹性可扩展</p>
<p>可以在系统运行的时候，动态增加或者删除结点。不需要停机维护，数据可以自动迁移</p>
<p>分区</p>
<p>NoSQL数据库将数据进行分区，将记录分散在多个节点上面，并且通常分区的同时还要做复制</p>
<p>异步复制</p>
<p>NoSQL中的复制，往往是基于日志的异步复制。这样，数据就可以尽快地写入一个节点，而不会出现网络传输迟延</p>
<p>BASE</p>
<p>相对于ACID特性，NoSQL数据库保证的是BASE特性(BASE是最终一致性和软事务)</p>
<p>  <strong>五、常见的NoSQL数据库</strong> 比较适合采用NoSQL数据库的场合是：(1)数据模型比较简单；(2)需要灵活性更强的IT系统；(3)对数据库性能要求较高；(4)不需要高度的数据一致性；(5)对于给定key，比较容易映射复杂值的环境。 常见的NoSQL数据库如表3所示。</p>
<p>表3常见的NoSQL数据库</p>
<p><strong>分类</strong></p>
<p><strong>实例</strong></p>
<p>键值(Key-Value)存储数据库</p>
<p>*  Riak：一个开源、分布式键值数据库，支持数据复制和容错</p>
<p>*  Redis：一个开源的键值存储数据库，支持主从式复制、事务，Pub/Sub、Lua脚本，还支持给Key添加时限</p>
<p>*  Dynamo：一个键值分布式存储数据库，直接由亚马逊Dynamo数据库实现</p>
<ul>
<li><p>Oracle NoSQL Database：来自Oracle的键值NoSQL数据库，支持事务ACID和JSON</p>
</li>
<li><p>Oracle NoSQL Database：具备数据备份和分布式键值存储系统</p>
</li>
<li><p>Voldemort：具备数据备份和分布式键值存储系统</p>
</li>
<li><p>Aerospike：一个键值存储数据库，支持混合内存架构，通过强一致性和可调一致性保证数据的完整性</p>
</li>
</ul>
<p>列存储数据库</p>
<ul>
<li><p>Cassandra：支持跨数据中心的数据复制，提供列索引</p>
</li>
<li><p>HBase：一个开源、分布式、面向列存储的模型</p>
</li>
<li><p>Amazon SimpleDB：一个非关系型数据存储</p>
</li>
<li><p>Apache Accumulo：有序的、分布式键值数据存储，基于Google的BigTable设计</p>
</li>
<li><p>Hypertable：一个开源、可扩展的数据库，模仿Bigtable，支持分片</p>
</li>
<li><p>Azure Tables：为要求大量非结构化数据存储的应用提供NoSQL性能</p>
</li>
</ul>
<p>文档型数据库</p>
<ul>
<li><p>MongoDB：开源、面向文档</p>
</li>
<li><p>CounchDB：一个使用JSON的文档数据库，使用Javascript做MapReduce查询，也是一个使用HTTP的API</p>
</li>
<li><p>Couchbase：基于JSON模型</p>
</li>
<li><p>RavenDB：一个基于.net语言的面向文档数据库</p>
</li>
<li><p>MarkLogic：用来存储基于XML和以文档为中心的信息，支持灵活的模式</p>
</li>
</ul>
<p>图形(Graph)数据库</p>
<ul>
<li><p>Neo4j：一个图数据库，支持ACID事务</p>
</li>
<li><p>InfiniteGraph：用来维持和遍历对象间的关系，支持分布式数据存储</p>
</li>
<li><p>AllegroGraph：结合使用了内存和磁盘，提供了高可扩展性，支持SPARQ、RDFS++和Prolog推理</p>
</li>
</ul>
<p><strong>六、NoSQL和SQL语法的简单比较</strong> 前面介绍了NoSQL的基本情况，下面以HBase和ORACLE为例，对NoSQL和SQL的语法进行简单的比较。HBase数据库被认为是安全特性最完善的NoSQL数据库产品之一，它被证实是一个强大的工具，尤其是在已经使用Hadoop的场合。如今，它已经是Apache顶级项目，有着众多的开发人员和兴旺的用户社区。 1.创建表 如果要创建一个表“mytable”，其中包含了一个“info”字段，那么： (1)ORACLE中的语法为： create table mytable ( info  varchar(30) not null ); (2)HBase中的语法为： create ‘mytable’, ‘cf’ 该命令创建了一个有一个列族(“cf”)的表“mytable”。   2.写数据 如果要向表中写入数据“hello hbase”，那么： (1)ORACLE中的语法为： insert into mytable(info) values(‘hello hbase’); (2)HBase中的语法为： put ‘mytable’, ‘first’, ‘cf:info’, ‘hello hbase’ 该命令在“mytable”表的“first”行中的“cf:info”列对应的数据单元中插入“hello hbase”。   3.读(查)数据 如果要从表中读出单条数据，那么： (1)ORACLE中的语法为： select <em> from mytable where info = ‘hello hbase’; (2)HBase中的语法为： get ‘mytable’, ‘first’ 该命令输出了该行的数据单元。   如果要从表中读出所有数据，那么： (1)ORACLE中的语法为： select </em> from mytable; (2)HBase中的语法为： scan ‘mytable’ 该命令输出了所有数据。   4.删数据 如果要从表中删除数据，那么： (1)ORACLE中的语法为： delete from mytable where info = ‘hello hbase’; (2)HBase中的语法为： put ‘mytable’, ‘first’, ‘cf:info’, ‘hello hbase1’ 该命令用最新的值覆盖了旧的值，就相当于将原数据删除了。   5.修改数据 如果要在表中修改数据，那么： (1)ORACLE中的语法为： update mytable set info = ‘hello hbase1’ where info = ‘hellohbase’; (2)HBase中的语法为： put ‘mytable’, ‘first’, ‘cf:info’, ‘hello hbase1’ 该命令用最新的值覆盖了旧的值，就相当于修改了原数据。   6.删表 如果要删除表，那么： (1)ORACLE中的语法为： drop table mytable; (2)HBase中的语法为： disable ‘mytable’ drop ‘mytable’ 该命令先将表“disable”掉，然后再“drop”掉。   我们可以看到，HBase的语法比较的简单，因此完全可以将上述所有命令放到一个shell脚本中，让命令批量执行。下面，我们来具体操作一下： 第一步，编写名为“command.sh”的脚本，其内容如下： exec /root/zhouzx/hbase-1.0.1/bin/hbase shell &lt;&lt;EOF create ‘mytable’, ‘cf’ put ‘mytable’, ‘first’, ‘cf:info’, ‘hello hbase’ get ‘mytable’, ‘first’ scan ‘mytable’ put ‘mytable’, ‘first’, ‘cf:info’, ‘hello hbase1’ disable ‘mytable’ drop ‘mytable’ EOF   第二步，将该脚本上传到Linux机器的安装HBase的用户下，依次执行“dos2unix command.sh”和“chmod 777command.sh”命令来转换文件格式和对文件赋权限。   第三步，执行“./command.sh”命令，在Linux界面上，我们可以看到如下输出信息： HBase Shell; enter ‘help<return>‘ for list of supportedcommands. Type “exit<return>“ to leave the HBase Shell Version 1.0.1, r66a93c09df3b12ff7b86c39bc8475c60e15af82d, Fri Apr17 22:14:06 PDT 2015   create ‘mytable’, ‘cf’ 0 row(s) in 0.6660 seconds   Hbase::Table - mytable put ‘mytable’, ‘first’, ‘cf:info’, ‘hello hbase’ 0 row(s) in 0.1140 seconds   get ‘mytable’, ‘first’ COLUMN                           CELL cf:info                         timestamp=1435807200326, value=hello hbase 1 row(s) in 0.0440 seconds   scan ‘mytable’ ROW                  COLUMN+CELL first                   column=cf:info,timestamp=1435807200326, value=hello hbase 1 row(s) in 0.0210 seconds   put ‘mytable’, ‘first’, ‘cf:info’, ‘hello hbase1’ 0 row(s) in 0.0040 seconds   disable ‘mytable’ 0 row(s) in 1.1930 seconds   drop ‘mytable’ 0 row(s) in 0.1940 seconds   整个脚本执行过程不过几秒钟，但我们之前提到的所有HBase命令都包括其中了，由此可见批处理的威力。大家一定要好好体会一下。   <strong>七、总结</strong> 本文对NoSQL进行了全面的介绍，并比较了它与SQL语法之间的不同。尽管大多数NoSQL数据存储系统都已被部署到实际应用中，但仍存在以下挑战性问题需要解决： 第一，已有key-value数据库产品大多是面向特定应用自治构建的，缺乏通用性。 第二，已有产品支持的功能有限(不支持事务特性)，导致其应用具有一定的局限性。 第三，已有一些研究成果和改进的NoSQL数据存储系统，但它们都是针对不同应用需求而提出的相应解决方案，很少从全局考虑系统的通用性，也没有形成系列化的研究成果。 第四，缺乏类似关系数据库所具有的强有力的理论(如armstrong公理系统)、技术(如成熟的基于启发式的优化策略、两段封锁协议等)、标准规范(如SQL语言)的支持。 第五，很多NoSQL数据库没有提供内建的安全机制。   随着云计算、移动互联网等技术的发展，大数据广泛存在，同时也出现了许多云环境下的新型应用，如社交网络、移动服务、协作编辑等。这些新型应用对海量数据管理或称云数据管理系统也提出了新的需求，NoSQL数据库在这些方面有大展身手的机会。我们有理由相信，NoSQL数据库的明天会更加的美好！</return></return></p>
</blockquote>

            
            <p class="more">
                <a href="/2015/07/02/2019030500122/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/02/2019030500122/" title="NoSQL数据库概览及其与SQL语法的比较">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/02/2019030500104/">
    		mysql行转列（拆分字符串场景）
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-02T05:52:29.000Z">2015-07-02</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>一对多没有建立中间表的时候经常会采用分隔符的形式将“多”存储在“一”的一个字段里，这样做的代价是无法向一对多的时候那样直接关联查询，一般采用在程序中分割后分别查询的办法。如下图： <img src="http://img.blog.csdn.net/20150701165850674?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFva3g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> 如何才能直接用sql语句查询出下图的效果呢？ <img src="http://img.blog.csdn.net/20150701170018457?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFva3g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> 可以借助一个序号表，该表中除了连续的id没有其它字段，id的值范围取决于”一”中存储的信息拆分后的数量。 <img src="http://img.blog.csdn.net/20150701170230086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFva3g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> 实现sql：</p>
<p><strong>[sql]</strong></p>
<ol>
<li>SELECT</li>
<li>NAME,</li>
<li>REPLACE(</li>
<li>SUBSTRING_INDEX(mobile, ‘,’, a.id),</li>
<li>CONCAT(</li>
<li>SUBSTRING_INDEX(mobile, ‘,’, a.id - 1),</li>
<li>‘,’</li>
<li>),</li>
<li>‘’</li>
<li>)AS mobile</li>
<li>FROM</li>
<li>squence a</li>
<li>CROSS JOIN(</li>
<li>SELECT</li>
<li>NAME,</li>
<li>CONCAT(mobile, ‘,’)AS mobile,</li>
<li>LENGTH(mobile)- LENGTH(REPLACE(mobile, ‘,’, ‘’))+ 1 AS size</li>
<li>FROM</li>
<li><code>user</code></li>
<li>)b ON a.id &lt;= b.size</li>
</ol>

            
            <p class="more">
                <a href="/2015/07/02/2019030500104/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/02/2019030500104/" title="mysql行转列（拆分字符串场景）">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/02/2019030500139/">
    		Oracle移除表空间的数据文件 ora-00604 ora-01426
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-02T05:05:35.000Z">2015-07-02</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a> / 
    
        <a href="/tags/ora-00604/" title="ora-00604">ora-00604</a> / 
    
        <a href="/tags/ora-01426/" title="ora-01426">ora-01426</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p>项目背景:在之前开发环境数据库管理比较乱,在表空间不足时只是添加数据文件,测试完后数据己删除,但数据库表空间所占的空间不能回收,导致数据库的存储目录使用率达到97%以上实际使用只有10%,迫切需要将不用空间进行回收. 技术背景:Oracle不提供如删除表、视图一样删除数据文件的方法，数据文件是表空间的一部分，所以不能“移走”表空间。Oracle 10G R2开始，可以采用：Alter tablespace tablespace_name drop datafile file_name;来删除一个空数据文件，并且相应的数据字典信息也会清除: A.确认oracle版本(我是以本机(windows)查看数据库版本,测试环境为AIX操作系统,但数据库版本一致),版本满足可以直接删除数据文件 select <em> from v$version; B.确认移除的数据文件 a.确定需要移去的数据文件,可以用数据文件最大扩展的大小和对象多少综合评估一下,是否将这个文件进行移除 扩展大小: select file_id,tablespace_name,max(t.block_id)\</em>8192/1024/1024 from dba_extents t where tablespace_name = ‘FERMATDATA’ group by file_id,tablespace_name 对象多少: select * from dba_extents t where t.file_id =10 C.将数据文件中己有的对象move到其他表空间 a.对于segment_type为TABLE的非分区表采用以下语句 alter table bob_rwa3.db move tablespace ETLDATA; 批量语句: select ‘alter table ‘||t.owner||’.’||t.segment_name||’ move tablespace ETLDATA ;’ from dba_extents t where t.file_id =10 and t.partition_name is null b.对于segment_type为TABLE的分区表采用以下语句(非复合分区) alter table BOB_RAY.T_TRANSITION_MATRIX move partition P199001010001 tablespace ETLDATA update global indexes ; 批量脚本: select ‘alter table ‘||t.owner||’.’||t.segment_name||’ move partition ‘||t.partition_name||’ tablespace ETLDATA update global indexes ;’ from dba_extents t where t.file_id =10 and t.partition_name is not null ; c.对于segment_type 为TABLE复合分区采用以下语句 alter table BOB_RAY.LOG_TABLE move subpartition P199001010001_NULL tablespace IRM_DATA; 批量脚本可以自己关联dba_tab_subpartitions表写出. d.对于segment_type为LOBSEGMENT或LOBINDEX可以采用以下语句,因为LOB类型的字段会自动生成存储数据和索引两部份(lobsegment,lobindex) 1.查看找segment_type为lob的segment_name: select <em>  from dba_extents t where t.file_id =10 and t.segment_type like ‘%LOB%’; 2.查看segment_type为LOB对应的column select </em> from dba_lobs t where t.segment_name like ‘%SYS_LOB0000145648C00003%’ ; 3.将segment_type为LOB类型转移到其他表空间,因为move table只转移动非lob字段,所以需要执行以下语句 alter table BOB_RAY.BIRT_RESOURCE move tablespace ETLDADA lob(CONTENT) store as (tablespace ETLDATA); 批量脚本关联即可写出 因为本项目中数据表空间和索引表空间是分开的,所以这里不涉及索引的相关操作,如果有索引的情况估计与表的情况相似. D.确认数据文件是否为空 a.查看dba_extents 是否有记录(需要没有记录) select <em>  from dba_extents t where t.file_id =10; b.查看dba_segments是否有记录(需要没有记录) select </em> from dba_segments t where t.header_file = 10 注意:如果dba_segments有回收站的数据,那么在删除表空间数据文件时会报错 ora-00604 ora-01426 c.删除回收站数据 purge recyclebin; E.删除表空间对应的数据文件 1.查看数据文件名称 select * from dba_data_files t where t.file_id = 10 ; 2.删除表空间数据文件 alter tablespace FERMATDATA drop  datafile ‘D:\APP\ORADATA\RWADB\FERMATDATA02.DBF’; 注意:当执行完语句时数据库服务器用df -g查看空间时没有变化,重启数据库后才能看到空间明显回收了 F.指定表存储在固定的数据文件方法以(扩展) alter  table bob_ray.bis_risk_bucket allocate extent( datafie ‘/oracle/oradata/orcl/appdata.dbf’ ); 此语句不会改变表中现有数据的存储,当新insert数据时才生效,</p>
</blockquote>

            
            <p class="more">
                <a href="/2015/07/02/2019030500139/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/02/2019030500139/" title="Oracle移除表空间的数据文件 ora-00604 ora-01426">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/02/2019030500109/">
    		MYSQL错误1053:服务没有及时响应启动或控制请求
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-02T04:46:37.000Z">2015-07-02</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/1053/" title="1053">1053</a> / 
    
        <a href="/tags/my-ini/" title="my.ini">my.ini</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <ol>
<li>错误描述 <img src="http://img.blog.csdn.net/20150701210957279" alt="这里写图片描述"></li>
<li>错误原因 由于连接不上本地数据库，我将MySQL安装目录下的my.ini配置文件删除，结果导致MySQL56服务无法启动；再次将my.ini复制到安装目录指定位置下，但是MySQL服务还是无法启动</li>
<li>解决办法 上述方法尝试失败后，我将原先安装的MySQL相关的程序全部卸载掉，然后重新安装MySQL，重装后可以启动MySQL服务</li>
</ol>

            
            <p class="more">
                <a href="/2015/07/02/2019030500109/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/02/2019030500109/" title="MYSQL错误1053:服务没有及时响应启动或控制请求">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/01/2019030500170/">
    		TNS-12541，TNS-12560，TNS-00511，TNS-12542，TNS-12560，TNS-00512数据库启动监听报错
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-01T04:22:02.000Z">2015-07-01</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/TNS/" title="TNS">TNS</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p>服务器环境为ORACLE11G RAC环境，系统启动后，监听没起来。</p>
<p><strong>[oracle@RAC4 ~]$ lsnrctl status</strong> LSNRCTL for Linux: Version 11.2.0.3.0 - Production on 29-JUN-2015 10:44:45 Copyright (c) 1991, 2011, Oracle.  All rights reserved. Connecting to (ADDRESS=(PROTOCOL=tcp)(HOST=)(PORT=1521)) TNS-12541: TNS:no listener TNS-12560: TNS:protocol adapter error TNS-00511: No listener Linux Error: 111: Connection refused</p>
<p><strong>1.1.1.2 检查思路</strong></p>
<p><strong>当时同事已经检查过CRS、也尝试过使用命令启动监听等步骤。但是启动监听的时候会有以下报错</strong>。</p>
<p><strong>[oracle@RAC4 ~]$ lsnrctl start</strong> LSNRCTL for Linux: Version 11.2.0.3.0 - Production on 29-JUN-2015 10:51:46 Copyright (c) 1991, 2011, Oracle.  All rights reserved. Starting /u01/app/oracle/product/11.2.0/db_1/bin/tnslsnr: please wait… TNSLSNR for Linux: Version 11.2.0.3.0 - Production Log messages written to /u01/app/oracle/diag/tnslsnr/RAC4/listener/alert/log.xml Error listening on: (ADDRESS=(PROTOCOL=tcp)(HOST=)(PORT=1521)) TNS-12542: TNS:address already in use TNS-12560: TNS:protocol adapter error TNS-00512: Address already in use Linux Error: 98: Address already in use Listener failed to start. See the error message(s) above…</p>
<p><strong>居然说系统已使用，那么理所当然的就去查看1521端口和lsn进程</strong></p>
<p><strong>[root@RAC4 ~]# ps-ef | grep lsn</strong></p>
<p>grid     52181     1  0 10:04?        00:00:11/u01/<em>/</em>/bin/tnslsnrLISTENER_SCAN1 -inherit</p>
<p>root    101600 100759  0 22:30 pts/0    00:00:00 grep lsn</p>
<p>[root@RAC4 ~]#netstat-anp | grep 1521</p>
<p>tcp       0     0xxx.xxx.xxx.xxx:1521          0.0.0.0:*                  LISTEN      52181/tnslsnr     （有些内容不便列出）</p>
<p>发现1521端口和/u01/11.2.0/grid/bin/tnslsnrLISTENER_SCAN1-inherit进程存在，所以尝试杀掉此进程</p>
<p><strong>[root@RAC4 ~]#kill -9 52181</strong></p>
<p>-bash: kill:(52181) - No suchprocess</p>
<p>杀掉后发现系统提示没有这个进程,再次查询</p>
<p>[root@RAC4 ~]# ps-ef |grep lsn</p>
<p>grid    104147     1  0 23:23?        00:00:00/u01/<em>/</em>/bin/tnslsnrLISTENER_SCAN1 -inherit</p>
<p>root    104379 104353  0 23:28 pts/0    00:00:00 grep lsn</p>
<p>又有了，应该是父进程自动又给他启动了，查看其父进程是init进程。</p>
<p><strong>[grid@RAC4 ~]$pstree 1</strong></p>
<p>init─┬─MBADataMover───MBADataMover───MBADataMover</p>
<pre><code>├─2*\[tnslsnr───2*\[{tnslsnr}\]\]
</code></pre><p><strong>1.1.1.3 出现问题的原因</strong></p>
<p>因为我记得在书上看到过，11G的RAC中SRVCTL可以管理监听，于是尝试使用此命令来启动监听。</p>
<p><strong>1.1.1.4 解决方法</strong></p>
<p><strong>[grid@RAC4 ~]$srvctl start listener -n RAC4</strong></p>
<p><strong>[grid@RAC4~]$ exit</strong></p>
<p>logout</p>
<p><strong>[root@RAC4~]# su -oracle</strong></p>
<p><strong>[oracle@RAC4~]$lsnrctl status;</strong></p>
<p>LSNRCTLfor Linux:Version 11.2.0.3.0 - Production on 01-JUL-2015 11:32:45</p>
<p>Copyright(c) 1991,2011, Oracle.  All rightsreserved.</p>
<p>Connectingto(ADDRESS=(PROTOCOL=tcp)(HOST=)(PORT=1521))</p>
<p>STATUSof theLISTENER</p>
<p>------------------------</p>
<p>Alias                    LISTENER</p>
<p>Version                  TNSLSNR for Linux: Version11.2.0.3.0 - Production</p>
<p>StartDate               01-JUL-2015 10:38:57</p>
<p>Uptime                   0 days 0 hr. 53 min. 47 sec</p>
<p>TraceLevel              off</p>
<p>Security                 ON: Local OS Authentication</p>
<p>SNMP                     OFF</p>
<p>ListenerParameterFile  /u01/11.2.0/grid/network/admin/listener.ora</p>
<p>ListenerLogFile        /u01/app/oracle/diag/tnslsnr/RAC4/listener/alert/log.xml</p>
<p>ListeningEndpointsSummary…</p>
<p> (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=LISTENER)))</p>
<p> (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=11.10.110.23)(PORT=1521)))</p>
<p> (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=11.10.110.25)(PORT=1521)))</p>
<p>ServicesSummary…</p>
<p>Service”+ASM”has 1 instance(s).</p>
<p>  Instance”+ASM2”, status READY, has1 handler(s) for this service…</p>
<p>Service”RAC3”has 1 instance(s).</p>
<p>  Instance”RAC32”, status READY, has1 handler(s) for this service…</p>
<p>Service”RAC3XDB”has 1 instance(s).</p>
<p>  Instance”RAC32”, status READY, has1 handler(s) for this service…</p>
<p>Service”RACDB007”has 1 instance(s).</p>
<p>  Instance “RACDB0072”,status READY, has1 handler(s) for this service…</p>
<p>Service”RACDB007JL_BJ”has 1 instance(s).</p>
<p>  Instance”RACDB007JL2”, status READY,has 1 handler(s) for this service…</p>
<p>Service”RACDB007JL_BJXDB”has 1 instance(s).</p>
<p>  Instance”RACDB007JL2”, status READY,has 1 handler(s) for this service…</p>
<p>Service”RACDB007XDB”has 1 instance(s).</p>
<p>  Instance”RACDB0072”, status READY, has1 handler(s) for this service…</p>
<p>The commandcompleted successfully</p>
<p><strong>1.1.1.5 知识点</strong></p>
<p>经过这次问题的解决，发现oracle 11G的RAC中有很多功能都通过集群命令来控制，而不能单一的通过单机管理的方法来控制集群的某些功能</p>
</blockquote>

            
            <p class="more">
                <a href="/2015/07/01/2019030500170/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/01/2019030500170/" title="TNS-12541，TNS-12560，TNS-00511，TNS-12542，TNS-12560，TNS-00512数据库启动监听报错">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/06/30/2019030500095/">
    		MySQL数据库主从同步
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-06-30T08:07:10.000Z">2015-06-30</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/主从同步/" title="主从同步">主从同步</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p>1,准备工作 准备两台机器 ，各自安装一个 MySQL数据库 。比如 10.254.141.23 作为主数据库 10.254.166.60 作为从数据库 安装MySQL数据库参考 《MySQL数据库安装》 2,主库开启binlog 看主库上，是不是开启了 binlog ，主从同步需要开启这个。 mysql&gt; show master status; <img src="http://img.blog.csdn.net/20150630114918261" alt="这里写图片描述"> 有binlog文件 ，和 当前的位置显示出来 ，说明开启了binglog ，否则需要先去开这个， 修改/etc/my.cnf ,然后重启数据库。 配置文件中加这几句 log-bin = mysql-bin relay-log = relay-bin binlog_format = MIXED binlog_cache_size = 1M 3，主库上建立同步账号 在主机上 添加用于从库同步的账户 mysql&gt; GRANT REPLICATION SLAVE ON _._ to ‘repl’@’%’ identified by ‘123456’; Query OK, 0 rows affected (0.00 sec) mysql&gt; flush privileges; Query OK, 0 rows affected (0.00 sec) 4，备份主库的数据 如果主服务器上 已经存在 数据， 需要先对 主库的数据进行备份， 一次性导入从库上， 然后再主从同步 ，否则会出现数据冲突。 如果是全新安装的 主从数据库， 还没有任何的数据写入， 可以跳过这一步，直接去配置主从。 4.1 先对主库数据进行备份 mysql&gt; set sql_log_bin=0; [root@rs1 ~]# /usr/local/bin/mysqldump -uroot -p123456 –socket=/home/mysql/mysql.sock –all-databases –single-transaction –flush-logs –master-data=2 &gt; db.sql.2012-12-05 mysql&gt; set sql_log_bin=1; 4.2 将备份数据复制到从服务器上 [root@rs1 ~]# scp /home/work/db.sql.2012-12-05 10.136.51.111:/home/work 在从服务器上进行数据同步： mysql&gt; source /home/work/db.sql.2012-12-05 5, 在从库上 配置 head -30 db.sql.2012-12-05 找到以– CHANGE MASTER TO MASTER_LOG开头的行，如下所示： – CHANGE MASTER TO MASTER_LOG_FILE=’mysql-bin.000002’, MASTER_LOG_POS=107; 记录使用的二进制文件以及语句执行的位置。 因为要从这个位置开始 主从同步。 然后在从库上执行 mysql&gt; slave stop; mysql&gt; change master to master_host=’10.254.141.23’, master_user=’repl’, master_password=’123456’, master_port=3306, master_log_file=’mysql-bin.000007’, master_log_pos=107; mysql&gt; slave start; 看一下 从库的状态。 mysql&gt; show slave status\G;</p>
<pre><code> Slave_IO_Running: Yes
Slave_SQL_Running: Yes
Seconds_Behind_Master: 0   0显示从服务器比主服务器慢多少秒
</code></pre><p>主从同步完成。</p>
</blockquote>

            
            <p class="more">
                <a href="/2015/06/30/2019030500095/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/06/30/2019030500095/" title="MySQL数据库主从同步">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/0.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/开发语言/">开发语言</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/06/30/2019030500060/">
    		Mybatis一级、二级缓存
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-06-30T08:06:08.000Z">2015-06-30</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Mybatis/" title="Mybatis">Mybatis</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <h2 id="一级缓存"><a href="#一级缓存" class="headerlink" title="一级缓存"></a>一级缓存</h2><p>首先做一个测试，创建一个mapper配置文件和mapper接口，我这里用了最简单的查询来演示。</p>
<pre><code>&lt;mapper namespace=&quot;cn.elinzhou.mybatisTest.mapper.UserMapper&quot;&gt;

    &lt;select id=&quot;findUsers&quot; resultType=&quot;cn.elinzhou.mybatisTest.pojo.User&quot;&gt;
        SELECT * FROM user
    &lt;/select&gt;
&lt;/mapper&gt;

public interface UserMapper {
    List&lt;User&gt; findUsers()throws Exception;
}
</code></pre><p>然后编写一个单元测试</p>
<pre><code>public class UserMapperTest {


    SqlSession sqlSession = null;
    @Before
    public void setUp() throws Exception {
        // 通过配置文件获取数据库连接信息
        Reader reader = Resources.getResourceAsReader(&quot;cn/elinzhou/mybatisTest/config/mybatis.xml&quot;);
        // 通过配置信息构建一个SqlSessionFactory
        SqlSessionFactory sqlSessionFactory = new SqlSessionFactoryBuilder().build(reader);
        // 通过sqlSessionFactory打开一个数据库会话
        sqlSession = sqlSessionFactory.openSession();
    }

    @Test
    public void testFindUsers() throws Exception {
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        List&lt;User&gt; users = userMapper.findUsers();
        System.out.println(users);
    }
}
</code></pre><p>运行，可以看到控制台输出（先配好log4j）为类似如下图日志 <img src="http://img.blog.csdn.net/20150630131239665" alt="这里写图片描述"> 日志说明了该操作执行的sql语句已经查询的内容，最后一行是我手动通过System.out.printf输出的结果。 然后再加一条语句</p>
<pre><code>users = userMapper.findUsers();
</code></pre><ul>
<li>1</li>
</ul>
<p>之前的单元测试就变成了这个样子 <img src="http://img.blog.csdn.net/20150630131509302" alt="这里写图片描述"> 也就是在执行完userMapper.findUsers();后立刻再执行一遍userMapper.findUsers(); 可以想象，其实这两个操作执行的sql是完全相同的，而且在这期间没有对数据库进行过其他操作。然后执行该单元测试，发现效果跟上面执行一条的时候完全相同，也就是执行第二次userMapper.findUsers();操作的时候没有对数据库进行查询，那么得到的数据是从哪里来的？答案是一级缓存。 mybatis一级缓存是指在内存中开辟一块区域，用来保存用户对数据库的操作信息（sql）和数据库返回的数据，如果下一次用户再执行相同的请求，那么直接从内存中读数数据而不是从数据库读取。 其中数据的生命周期有两个影响因素。</p>
<ol>
<li>对sqlsession执行commit操作时</li>
</ol>
<p>对sqlsession执行commit操作，也就意味着用户执行了update、delete等操作，那么数据库中的数据势必会发生变化，如果用户请求数据仍然使用之前内存中的数据，那么将读到脏数据。所以在执行sqlsession操作后，会清除保存数据的HashMap，用户在发起查询请求时就会重新读取数据并放入一级缓存中了。 <img src="http://img.blog.csdn.net/20150630135748796" alt="这里写图片描述"> <img src="http://img.blog.csdn.net/20150630135727222" alt="这里写图片描述"> 上述测试就是在第一查询完后执行了commit操作，再进行查询。与之前的测试不同的是，这次测试控制台打印了两组查询结果，说明在commit之后mybatis对数据重新进行了查询。</p>
<ol>
<li>关闭sqlsession</li>
</ol>
<p>一般在mybatis集成spring时，会把SqlSessionFactory设置为单例注入到IOC容器中，不把sqlsession也设置为单例的原因是sqlsession是线程不安全的，所以不能为单例。那也就意味着其实是有关闭sqlsession的过程的。其实，对于每一个service中的sqlsession是不同的，这是通过mybatis-spring中的org.mybatis.spring.mapper.MapperScannerConfigurer创建sqlsession自动注入到service中的。 而一级缓存的设计是每个sqlsession单独使用一个缓存空间，不同的sqlsession是不能互相访问数据的。当然，在sqlsession关闭后，其中数据自然被清空。</p>
<h2 id="二级缓存"><a href="#二级缓存" class="headerlink" title="二级缓存"></a>二级缓存</h2><p>在使用二级缓存之前，先测试之前提到过的关闭sqlsession后会清空缓存的问题，把junit代码修改一下</p>
<pre><code>@Test
    public void testFindUsers() throws Exception {
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        List&lt;User&gt; users = userMapper.findUsers();
        //关闭sqlsession
        sqlSession.close();

        //通过sqlsessionFactroy创建一个新的sqlsession
        sqlSession = sqlSessionFactory.openSession();
        //获取mapper对象
        userMapper = sqlSession.getMapper(UserMapper.class);
        users = userMapper.findUsers();
        System.out.println(users);
    }
</code></pre><p>这段代码在第一次查询完后关闭sqlsession，然后创建新的sqlsession和mapper来重新执行一次查询操作，可以预见，执行结果如图 <img src="http://img.blog.csdn.net/20150630144534559" alt="这里写图片描述"> 说明关闭了sqlsession后的确把之前的缓存数据清空了，之后再执行同样的查询操作也会再访问一遍数据库。为了解决这个问题，需要使用二级缓存 一级缓存的作用域仅限于一个sqlsession，但是二级缓存的作用域是一个namespace。但并不是意味着同一个namespace创建的mapper可以互相读取缓存内容，<strong>这里的原则是，如果开启了二级缓存，那么在关闭sqlsession后，会把该sqlsession一级缓存中的数据添加到namespace的二级缓存中。</strong> 接下测试，先需要开启二级缓存。 1.打开二级缓存总开关 打开总开关，只需要在mybatis总配置文件中加入一行设置</p>
<pre><code>&lt;settings&gt;
   &lt;!--开启二级缓存--&gt;
    &lt;setting name=&quot;cacheEnabled&quot; value=&quot;true&quot;/&gt;
&lt;/settings&gt;
</code></pre><p>2.打开需要使用二级缓存的mapper的开关 在需要开启二级缓存的mapper.xml中加入caceh标签</p>
<pre><code>&lt;cache/&gt;
</code></pre><p>3.POJO序列化 让需要使用二级缓存的POJO类实现Serializable接口，如</p>
<pre><code>public class User implements Serializable {
</code></pre><p>通过之前三步操作就可以使用二级缓存了，接下来测试。添加一个Junit方法</p>
<pre><code>@Test
    public void testFindUsersCache() throws Exception {
        UserMapper userMapper = sqlSession.getMapper(UserMapper.class);
        List&lt;User&gt; users = userMapper.findUsers();
        //关闭sqlsession
        sqlSession.close();

        //通过sqlsessionFactroy创建一个新的sqlsession
        sqlSession = sqlSessionFactory.openSession();
        //获取mapper对象
        userMapper = sqlSession.getMapper(UserMapper.class);
        users = userMapper.findUsers();
        System.out.println(users);
    }
</code></pre><p>执行后可以发现，控制台值输出了一次查询过程，也可以证明二级缓存开启成功。 还有一个问题，之前说了，即使开启了二级缓存，不同的sqlsession之间的缓存数据也不是想互访就能互访的，必须等到sqlsession关闭了以后，才会把其一级缓存中的数据写入二级缓存。为了测试这个，把上述代码中的</p>
<pre><code>sqlSession.close();
</code></pre><p>注释，那么之前的代码就变成了 <img src="http://img.blog.csdn.net/20150630145844316" alt="这里写图片描述"> 再执行，发现控制太又输出了两次的查询过程，所以可以印证，<strong>只有关闭了sqlsession之后，才会把其中一级缓存数据写入二级缓存。</strong></p>
<h2 id="缓存配置"><a href="#缓存配置" class="headerlink" title="缓存配置"></a>缓存配置</h2><ul>
<li>关闭刷新</li>
</ul>
<p>在默认情况下，当sqlsession执行commit后会刷新缓存，但是也可以强制设置为不刷新，在不需要刷新的标签中加入</p>
<pre><code>flushCache=&quot;false&quot; 
</code></pre><p>如</p>
<pre><code>&lt;select id=&quot;findUsers&quot; resultType=&quot;cn.elinzhou.mybatisTest.pojo.User&quot; flushCache=&quot;false&quot;&gt;
</code></pre><p>那么，无论是否执行commit，缓存都不会刷新了。但是这样会造成脏读，只有在特殊情况下才使用</p>
<ul>
<li>自动刷新</li>
</ul>
<p>有些情况下，需要设置自动刷新缓存，那么需要配置对应mapper中的cache标签。</p>
<pre><code>flushInterval=&quot;10000&quot;
</code></pre><p>该属性表示每隔10秒钟自动刷新一遍缓存</p>

            
            <p class="more">
                <a href="/2015/06/30/2019030500060/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/06/30/2019030500060/" title="Mybatis一级、二级缓存">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/0.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/06/30/2019030500071/">
    		Mysql双机热备主从配置
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-06-30T06:28:54.000Z">2015-06-30</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/主从配置/" title="主从配置">主从配置</a> / 
    
        <a href="/tags/双机热备/" title="双机热备">双机热备</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>replication on mysql: Master/Slave. Master server is the production MySQL instance. Slave server is the java host (123.57.39.<em>). First we need to install MySQL server and client on the java host(123.57.39.</em>). 1.in master execute: CREATE USER ‘replica‘@’123.57.39.<em>‘ IDENTIFIED BY ‘replica@123’; GRANT REPLICATION SLAVE ON </em>.<em> TO ‘replica‘@’123.57.39.</em>‘; flush privileges; 2. add the following to [mysqld] segment in /etc/my.cnf of master DB.  And make sure mysql user is the owner of log-bin direcotry.  Otherwise you will get error when you startup MySQL. server-id=1 log-bin=/var/lib/mysql/binlog/mysql-bin expire_logs_days=7 3. On Slave,add the following to [mysqld] segment in /etc/my.cnf server-id=2 innodb_flush_log_at_trx_commit=2 //this line is not required,just improve innodb performance expire_logs_days=7 4.in master,then copy data to slave mysqldump –master-data=2 –user=root –password=fadfafafaD  –single-transaction –all-databases &gt; replica.sql 5.copy the replica.sql to slave server,then import data in slave. mysql –user=root –password=fadfafafaD  &lt; replica.sql 6.change master settting on slave;view the privious replica.sql,using “more replica.sql”,you will see some text like the follwing, – CHANGE MASTER TO MASTER_LOG_FILE=’mysql-bin.000001’, MASTER_LOG_POS=107; record the red font part,then fill them into the following statement,then execute the following statement in slave mysql server. CHANGE MASTER TO MASTER_HOST = ‘123.57.38.*’, MASTER_USER = ‘replica’, MASTER_PASSWORD = ‘replica@123’, MASTER_LOG_FILE = ‘mysql-bin.000001’, MASTER_LOG_POS = 107; 7.finally start slave; Be don’t forget to issue “show slave status\G’ to check whether slave runs normally.</p>

            
            <p class="more">
                <a href="/2015/06/30/2019030500071/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/06/30/2019030500071/" title="Mysql双机热备主从配置">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/0.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <a class="extend prev" rel="prev" href="/page/12/">前一页</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/11/">11</a><a class="page-number" href="/page/12/">12</a><span class="page-number current">13</span><a class="page-number" href="/page/14/">14</a><a class="page-number" href="/page/15/">15</a><span class="space">&hellip;</span><a class="page-number" href="/page/18/">18</a><a class="extend next" rel="next" href="/page/14/">后一页</a>
    </nav>
    




            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/MySQL/">MySQL</a>
        <span class="badge">(92)</span>
    </li>
    
    <li>
        <a href="/categories/Oracle/">Oracle</a>
        <span class="badge">(40)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/">NOSQL</a>
        <span class="badge">(17)</span>
    </li>
    
    <li>
        <a href="/categories/开发语言/">开发语言</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="/categories/SQL-Server/">SQL Server</a>
        <span class="badge">(13)</span>
    </li>
    
    <li>
        <a href="/categories/其他数据库/">其他数据库</a>
        <span class="badge">(4)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/">Oracle</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/SQL-Server/">SQL Server</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/开发语言/">开发语言</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/MySQL/" title="MySQL">MySQL (71)</a>
  
    <a class="tag-item" href="/tags/位运算/" title="位运算">位运算 (0)</a>
  
    <a class="tag-item" href="/tags/sqlplus/" title="sqlplus">sqlplus (1)</a>
  
    <a class="tag-item" href="/tags/PL-SQL/" title="PL/SQL">PL/SQL (5)</a>
  
    <a class="tag-item" href="/tags/数据库/" title="数据库">数据库 (7)</a>
  
    <a class="tag-item" href="/tags/视图/" title="视图">视图 (1)</a>
  
    <a class="tag-item" href="/tags/B-Tree/" title="B+Tree">B+Tree (1)</a>
  
    <a class="tag-item" href="/tags/索引/" title="索引">索引 (1)</a>
  
    <a class="tag-item" href="/tags/redis/" title="redis">redis (6)</a>
  
    <a class="tag-item" href="/tags/SSDB/" title="SSDB">SSDB (1)</a>
  
    <a class="tag-item" href="/tags/SQL/" title="SQL">SQL (17)</a>
  
    <a class="tag-item" href="/tags/ORA-00600/" title="ORA-00600">ORA-00600 (1)</a>
  
    <a class="tag-item" href="/tags/存储过程/" title="存储过程">存储过程 (3)</a>
  
    <a class="tag-item" href="/tags/CentOS/" title="CentOS">CentOS (2)</a>
  
    <a class="tag-item" href="/tags/allow/" title="allow">allow (1)</a>
  
    <a class="tag-item" href="/tags/Apache/" title="Apache">Apache (1)</a>
  
    <a class="tag-item" href="/tags/deny/" title="deny">deny (1)</a>
  
    <a class="tag-item" href="/tags/druid/" title="druid">druid (1)</a>
  
    <a class="tag-item" href="/tags/心跳/" title="心跳">心跳 (1)</a>
  
    <a class="tag-item" href="/tags/事务/" title="事务">事务 (5)</a>
  
    <a class="tag-item" href="/tags/分布式/" title="分布式">分布式 (1)</a>
  
    <a class="tag-item" href="/tags/消息/" title="消息">消息 (1)</a>
  
    <a class="tag-item" href="/tags/KeepAlived/" title="KeepAlived">KeepAlived (1)</a>
  
    <a class="tag-item" href="/tags/Oracle/" title="Oracle">Oracle (30)</a>
  
    <a class="tag-item" href="/tags/schedule-job/" title="schedule job">schedule job (1)</a>
  
    <a class="tag-item" href="/tags/分库/" title="分库">分库 (1)</a>
  
    <a class="tag-item" href="/tags/分库分表/" title="分库分表">分库分表 (1)</a>
  
    <a class="tag-item" href="/tags/分表/" title="分表">分表 (1)</a>
  
    <a class="tag-item" href="/tags/结构同步/" title="结构同步">结构同步 (1)</a>
  
    <a class="tag-item" href="/tags/批量/" title="批量">批量 (1)</a>
  
    <a class="tag-item" href="/tags/truncate/" title="truncate">truncate (1)</a>
  
    <a class="tag-item" href="/tags/Hash索引/" title="Hash索引">Hash索引 (1)</a>
  
    <a class="tag-item" href="/tags/InnoDB/" title="InnoDB">InnoDB (3)</a>
  
    <a class="tag-item" href="/tags/MyISAM/" title="MyISAM">MyISAM (3)</a>
  
    <a class="tag-item" href="/tags/索引优化/" title="索引优化">索引优化 (1)</a>
  
    <a class="tag-item" href="/tags/FineReport/" title="FineReport">FineReport (1)</a>
  
    <a class="tag-item" href="/tags/报表/" title="报表">报表 (1)</a>
  
    <a class="tag-item" href="/tags/数据集/" title="数据集">数据集 (1)</a>
  
    <a class="tag-item" href="/tags/Excel/" title="Excel">Excel (1)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="https://jelon.top" target="_blank" title="Jelon个人前端小站">前端博客小站</a>
        </li>
    
        <li>
            <a href="https://www.baidu.com" target="_blank" title="百度搜索">百度</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>