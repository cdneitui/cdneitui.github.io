<!doctype html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8">
    <meta name="baidu-site-verification" content="dIcXMeY8Ya">
    
    <title>`MySQL`标签下的文章 | 软件开发吧</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="keywords" content="Jelon, 前端, Web, 张德龙, 前端开发">
    <meta name="description" content="Jelon个人前端小站">

    
    <link rel="alternative" href="/atom.xml" title="软件开发吧" type="application/atom+xml">
    
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
</html>
<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">软件开发吧</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/tags/MySQL/page/3/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/tags/MySQL/page/3/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/tags/MySQL/page/3/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/tags/MySQL/page/3/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/jangdelong" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.coding.me" target="_blank">Hosted by Coding Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                        <a href="http://weibo.com/jangdelong" class="sinaweibo" target="_blank"><b>■</b> 新浪微博</a>
                    
                        <a href="https://www.facebook.com/profile.php?id=100011855760219&amp;ref=bookmarks" class="qqweibo" target="_blank"><b>■</b> Facebook</a>
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon">
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 按标签分类 -->

    <h3 class="widget-hd">
        <strong>
            
                `MySQL`标签下的文章
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/23/2019030500072/">
    		MySQL垂直和水平切分
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-23T07:46:17.000Z">2015-12-23</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/切分/" title="切分">切分</a> / 
    
        <a href="/tags/垂直/" title="垂直">垂直</a> / 
    
        <a href="/tags/水平/" title="水平">水平</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>replication的限制:一旦数据库过于庞大，尤其是当写入过于频繁，很难由一台主机支撑的时候，我们还是会面临到扩展瓶颈。数据切分(sharding):通过某种特定的条件，将我们存放在同一个数据库中的数据分散存放到多个数据库（主机）上面，以达到分散单台设备负载的效果。。数据的切分同时还可以提高系统的总体可用性，因为单台设备Crash之后，只有总体数据的某部分不可用，而不是所有的数据。   数据的切分（Sharding）模式   一种是按照不同的表（或者Schema）来切分到不同的数据库（主机）之上，这种切可以称之为数据的垂直（纵向）切分；另外一种则是根据表中的数据的逻辑关系，将同一个表中的数据按照某种条件拆分到多台数据库（主机）上面，这种切分称之为数据的水平（横向）切分。   垂直切分:   一个架构设计较好的应用系统，其总体功能肯定是由很多个功能模块所组成的，而每一个功能模块所需要的数据对应到数据库中就是一个或者多个表。而在架构设计中，各个功能模块相互之间的交互点越统一越少，系统的耦合度就越低，系统各个模块的维护性以及扩展性也就越好。这样的系统，实现数据的垂直切分也就越容易。   一般来说，如果是一个负载相对不是很大的系统，而且表关联又非常的频繁，那可能数据库让步，将几个相关模块合并在一起减少应用程序的工作的方案可以减少较多的工作量，这是一个可行的方案。一个垂直拆分的例子: 1.用户模块表：user,user_profile,user_group,user_photo_album 2.群组讨论表：groups,group_message,group_message_content,top_message 3.相册相关表：photo,photo_album,photo_album_relation,photo_comment   4.事件信息表：event <em>群组讨论模块和用户模块之间主要存在通过用户或者是群组关系来进行关联。一般关联的时候都会是通过用户的id或者nick_name以及group的id来进行关联，通过模块之间的接口实现不会带来太多麻烦； </em>相册模块仅仅与用户模块存在通过用户的关联。这两个模块之间的关联基本就有通过用户id关联的内容，简单清晰，接口明确；   *事件模块与各个模块可能都有关联，但是都只关注其各个模块中对象的ID信息，同样可以做到很容易分拆。 垂直切分的优点: 数据库的拆分简单明了，拆分规则明确； 应用程序模块清晰明确，整合容易； 数据维护方便易行，容易定位；   垂直切分的缺点: 部分表关联无法在数据库级别完成，需要在程序中完成； 对于访问极其频繁且数据量超大的表仍然存在性能瓶颈，不一定能满足要求； 事务处理相对更为复杂； 切分达到一定程度之后，扩展性会遇到限制； 过读切分可能会带来系统过渡复杂而难以维护。     水平切分   将某个访问极其频繁的表再按照某个字段的某种规则来分散到多个表之中，每个表中包含一部分数据。 对于上面的例子:所有数据都是和用户关联的，那么我们就可以根据用户来进行水平拆分，将不同用户的数据切分到不同的数据库中。现在互联网非常火爆的Web2.0类型的网站，基本上大部分数据都能够通过会员用户信息关联上，可能很多核心表都非常适合通过会员ID来进行数据的水平切分。而像论坛社区讨论系统，就更容易切分了，非常容易按照论坛编号来进行数据的水平切分。切分之后基本上不会出现各个库之间的交互。   水平切分的优点： 表关联基本能够在数据库端全部完成； 不会存在某些超大型数据量和高负载的表遇到瓶颈的问题； 应用程序端整体架构改动相对较少； 事务处理相对简单； 只要切分规则能够定义好，基本上较难遇到扩展性限制；   水平切分的缺点： 切分规则相对更为复杂，很难抽象出一个能够满足整个数据库的切分规则； 后期数据的维护难度有所增加，人为手工定位数据更困难； 应用系统各模块耦合度较高，可能会对后面数据的迁移拆分造成一定的困难。   两种切分结合用:   一般来说，我们数据库中的所有表很难通过某一个（或少数几个）字段全部关联起来，所以很难简单的仅仅通过数据的水平切分来解决所有问题。而垂直切分也只能解决部分问题，对于那些负载非常高的系统，即使仅仅只是单个表都无法通过单台数据库主机来承担其负载。我们必须结合“垂直”和“水平”两种切分方式同时使用   每一个应用系统的负载都是一步一步增长上来的，在开始遇到性能瓶颈的时候，大多数架构师和DBA都会选择先进行数据的垂直拆分，因为这样的成本最先，最符合这个时期所追求的最大投入产出比。然而，随着业务的不断扩张，系统负载的持续增长，在系统稳定一段时期之后，经过了垂直拆分之后的数据库集群可能又再一次不堪重负，遇到了性能瓶颈。   如果我们再一次像最开始那样继续细分模块，进行数据的垂直切分，那我们可能在不久的将来，又会遇到现在所面对的同样的问题。而且随着模块的不断的细化，应用系统的架构也会越来越复杂，整个系统很可能会出现失控的局面。   这时候我们就必须要通过数据的水平切分的优势，来解决这里所遇到的问题。而且，我们完全不必要在使用数据水平切分的时候，推倒之前进行数据垂直切分的成果，而是在其基础上利用水平切分的优势来避开垂直切分的弊端，解决系统复杂性不断扩大的问题。而水平拆分的弊端（规则难以统一）也已经被之前的垂直切分解决掉了，让水平拆分可以进行的得心应手。   示例数据库:   假设在最开始，我们进行了数据的垂直切分，然而随着业务的不断增长，数据库系统遇到了瓶颈，我们选择重构数据库集群的架构。如何重构？考虑到之前已经做好了数据的垂直切分，而且模块结构清晰明确。而业务增长的势头越来越猛，即使现在进一步再次拆分模块，也坚持不了太久。   ==&gt;选择了在垂直切分的基础上再进行水平拆分。   ==&gt;在经历过垂直拆分后的各个数据库集群中的每一个都只有一个功能模块，而每个功能模块中的所有表基本上都会与某个字段进行关联。如用户模块全部都可以通过用户ID进行切分，群组讨论模块则都通过群组ID来切分，相册模块则根据相册ID来进切分，最后的事件通知信息表考虑到数据的时限性（仅仅只会访问最近某个事件段的信息），则考虑按时间来切分。   数据切分以及整合方案.   数据库中的数据在经过垂直和（或）水平切分被存放在不同的数据库主机之后，应用系统面临的最大问题就是如何来让这些数据源得到较好的整合，其中存在两种解决思路：   在每个应用程序模块中配置管理自己需要的一个（或者多个）数据源，直接访问各个数据库，在模块内完成数据的整合； 通过中间代理层来统一管理所有的数据源，后端数据库集群对前端应用程序透明；   第二种方案,虽然短期内需要付出的成本可能会相对更大一些，但是对整个系统的扩展性来说，是非常有帮助的。针对第二种方案，可以选择的方法和思路有：   1.利用MySQLProxy 实现数据切分及整合.   可用来监视、分析或者传输他们之间的通讯信息。他的灵活性允许你最大限度的使用它，目前具备的功能主要有连接路由，Query分析，Query过滤和修改，负载均衡，以及基本的HA机制等。MySQLProxy 本身并不具有上述所有的这些功能，而是提供了实现上述功能的基础。要实现这些功能，还需要通过我们自行编写LUA脚本来实现。   原理:MySQLProxy 实际上是在客户端请求与MySQLServer 之间建立了一个连接池。所有客户端请求都是发向MySQLProxy，然后经由MySQLProxy 进行相应的分析，判断出是读操作还是写操作，分发至对应的MySQLServer 上。对于多节点Slave集群，也可以起做到负载均衡的效果。   2.利用Amoeba实现数据切分及整合   Amoeba是一个基于Java开发的，专注于解决分布式数据库数据源整合Proxy程序的开源框架，Amoeba已经具有Query路由，Query过滤，读写分离，负载均衡以及HA机制等相关内容。Amoeba主要解决的以下几个问题：   数据切分后复杂数据源整合； 提供数据切分规则并降低数据切分规则给数据库带来的影响； 降低数据库与客户端的连接数； 读写分离路由；   AmoebaFor MySQL 主要是专门针对MySQL数据库的解决方案，前端应用程序请求的协议以及后端连接的数据源数据库都必须是MySQL。对于客户端的任何应用程序来说，AmoebaForMySQL 和一个MySQL数据库没有什么区别，任何使用MySQL协议的客户端请求，都可以被AmoebaFor MySQL 解析并进行相应的处理。   Proxy程序常用的功能如读写分离，负载均衡等配置都在amoeba.xml中进行。Amoeba已经支持了实现数据的垂直切分和水平切分的自动路由，路由规则可以在rule.xml进行设置。   3.利用HiveDB实现数据切分及整合   HiveDB同样是一个基于Java针对MySQL数据库的提供数据切分及整合的开源框架，只是目前的HiveDB仅仅支持数据的水平切分。主要解决大数据量下数据库的扩展性及数据的高性能访问问题，同时支持数据的冗余及基本的HA机制。   HiveDB的实现机制与MySQLProxy 和Amoeba有一定的差异，他并不是借助MySQL的Replication功能来实现数据的冗余，而是自行实现了数据冗余机制，而其底层主要是基于HibernateShards 来实现的数据切分工作。数据切分与整合中可能存在的问题   引入分布式事务的问题? 一旦数据进行切分被分别存放在多个MySQLServer中之后，不管我们的切分规则设计的多么的完美（实际上并不存在完美的切分规则），都可能造成之前的某些事务所涉及到的数据已经不在同一个MySQLServer 中了。 ==&gt;将一个跨多个数据库的分布式事务分拆成多个仅处于单个数据库上面的小事务，并通过应用程序来总控各个小事务。   跨节点Join的问题? ==&gt;先从一个节点取出数据,然后根据这些数据,再到另一个表中取数据. ==&gt;使用Federated存储引擎,问题是:乎如果远端的表结构发生了变更，本地的表定义信息是不会跟着发生相应变化的。   跨节点合并排序分页问题? ==&gt;Join本身涉及到的多个表之间的数据读取一般都会存在一个顺序关系。但是排序分页就不太一样了，排序分页的数据源基本上可以说是一个表（或者一个结果集），本身并不存在一个顺序关系，所以在从多个数据源取数据的过程是完全可以并行的。这样，排序分页数据的取数效率我们可以做的比跨库Join更高，所以带来的性能损失相对的要更小。</p>

            
            <p class="more">
                <a href="/2015/12/23/2019030500072/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/23/2019030500072/" title="MySQL垂直和水平切分">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/3.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/22/2019030500120/">
    		mysqldump命令使用笔记总结
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-22T06:34:53.000Z">2015-12-22</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/dump/" title="dump">dump</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>[size=small]mysqldump只导出数据或只导出表结构 1、备份数据库 #mysqldump -u 用户名 -p 数据库名 &gt; 导出文件名 2、导出表结构 #mysqldump -u 用户名 -p -d 数据库名 –add-drop-table 表名 &gt; 导出文件名  ##-d:表示没有数据，–add-drop-table 在每个creat语句之前增加一个drop table 3、导出表 #mysqldump -u 用户名 -p 数据库名 表名&gt; 导出文件名 4、导出数据 #mysqldump -u 用户名 -p -t 数据库名 &gt; 导出文件名 5、导入数据 #mysql 数据库名&lt;文件路径 -u 用户名 -p 实例： 备份数据库 #mysqldump　数据库名　&gt;数据库备份名 #mysqldump　-A　-u　用户名　-p密码　数据库名&gt;数据库备份名 #mysqldump　-d　-A　–add-drop-table　-uroot　-p　&gt;xxx.sql 导出结构不导出数据 mysqldump　–opt　-d　数据库名　-u　root　-p　&gt;　xxx.sql 导出数据不导出结构 mysqldump　-t　数据库名　-uroot　-p　&gt;　xxx.sql 导出数据和表结构 mysqldump　数据库名　-uroot　-p　&gt;　xxx.sql 导出特定表的结构 mysqldump　-uroot　-p　-B　数据库名　–table　表名　&gt;　xxx.sql 导入数据 #mysql　数据库名　&lt;　文件名 === 导出： mysqldump -u root -p week_system &gt; /bak_mysql/week_systembak.sql 导入： 必须先新建一个同名的库，才能恢复，不然会报错。 mysqldump: Got error: 1049: Unknown database ‘week_systembak’ when selecting the database mysql&gt; create database week_system character set utf8; Query OK, 1 row affected (0.02 sec) mysql&gt; \q Bye [root@localhost etc]# mysqldump -u root -p week_system &lt; /tmp/week_systembak.sql Enter password: – MySQL dump 10.13  Distrib 5.6.19, for Linux (x86_64) – – Host: localhost    Database: week_system – —————————————————— – Server version       5.6.19 /<em>!40101 SET @OLD_CHARACTER_SET_CLIENT=@@CHARACTER_SET_CLIENT </em>/; /<em>!40101 SET @OLD_CHARACTER_SET_RESULTS=@@CHARACTER_SET_RESULTS </em>/; /<em>!40101 SET @OLD_COLLATION_CONNECTION=@@COLLATION_CONNECTION </em>/; /<em>!40101 SET NAMES utf8 </em>/; /<em>!40103 SET @OLD_TIME_ZONE=@@TIME_ZONE </em>/; /<em>!40103 SET TIME_ZONE=’+00:00’ </em>/; /<em>!40014 SET @OLD_UNIQUE_CHECKS=@@UNIQUE_CHECKS, UNIQUE_CHECKS=0 </em>/; /<em>!40014 SET @OLD_FOREIGN_KEY_CHECKS=@@FOREIGN_KEY_CHECKS, FOREIGN_KEY_CHECKS=0 </em>/; /<em>!40101 SET @OLD_SQL_MODE=@@SQL_MODE, SQL_MODE=’NO_AUTO_VALUE_ON_ZERO’ </em>/; /<em>!40111 SET @OLD_SQL_NOTES=@@SQL_NOTES, SQL_NOTES=0 </em>/; /<em>!40103 SET TIME_ZONE=@OLD_TIME_ZONE </em>/; /<em>!40101 SET SQL_MODE=@OLD_SQL_MODE </em>/; /<em>!40014 SET FOREIGN_KEY_CHECKS=@OLD_FOREIGN_KEY_CHECKS </em>/; /<em>!40014 SET UNIQUE_CHECKS=@OLD_UNIQUE_CHECKS </em>/; /<em>!40101 SET CHARACTER_SET_CLIENT=@OLD_CHARACTER_SET_CLIENT </em>/; /<em>!40101 SET CHARACTER_SET_RESULTS=@OLD_CHARACTER_SET_RESULTS </em>/; /<em>!40101 SET COLLATION_CONNECTION=@OLD_COLLATION_CONNECTION </em>/; /<em>!40111 SET SQL_NOTES=@OLD_SQL_NOTES </em>/; – Dump completed on 2014-07-30  1:00:00 —-导入完成，但发现数据库是空的 –原来是命令用错了： mysql  -u root -p week_system &lt; /tmp/week_systembak.sql 就可以正常看到表了。 添加条件： mysqldump  -h rdsa3qfmmqriq3y.mysql.rds.aliyuncs.com -uweblog -pweblog -w “date=’2014-11-13’” weblog update_log &gt;/tmp/update.sql 先创建：mysql&gt;create database bugtracker character uft8; 再还原：root@viptest2 ~]# mysql -uroot -ptina1  bugtracker &lt; ./bugtracker.sql[/size]</p>

            
            <p class="more">
                <a href="/2015/12/22/2019030500120/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/22/2019030500120/" title="mysqldump命令使用笔记总结">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/22/2019030500050/">
    		java插入mysql 300万-2200万数据，优化查询
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-22T06:31:31.000Z">2015-12-22</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/Java/" title="Java">Java</a> / 
    
        <a href="/tags/优化/" title="优化">优化</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>my.ini参数修改了下</p>
<ol>
<li>table_cache=512</li>
<li>bulk_insert_buffer_size = 100M</li>
<li>innodb_additional_mem_pool_size=30M</li>
<li>innodb_flush_log_at_trx_commit=0</li>
<li>innodb_buffer_pool_size=207M</li>
<li>innodb_log_file_size=128M</li>
</ol>
<p>innodb_flush_log_at_trx_commit默认值1的意思是每一次事务提交或事务外的指令都需要把日志写入（flush）硬盘，这是很费时的。特别是使用电 池供电缓存（Battery backed up cache）时。设成2对于很多运用，特别是从MyISAM表转过来的是可以的，它的意思是不写入硬盘而是写入系统缓存。日志仍然会每秒flush到硬 盘，所以你一般不会丢失超过1-2秒的更新。设成0会更快一点，但安全方面比较差，即使MySQL挂了也可能会丢失事务的数据。而值2只会在整个操作系统 挂了时才可能丢数据。对于事务要求很强，设置为0 是存在安全问题的 mysql创建表</p>
<p>Sql代码</p>
<ol>
<li>CREATE TABLE `news` (</li>
<li>`id` int(19) NOT NULL AUTO_INCREMENT,</li>
<li>`title` varchar(30) DEFAULT NULL,</li>
<li>`content` varchar(400) DEFAULT NULL,</li>
<li>`type` varchar(30) DEFAULT NULL,</li>
<li>PRIMARY KEY (`id`),</li>
<li>UNIQUE KEY `PK_NEWS_ID` (`id`),</li>
<li>KEY `INDEX_NEWS_ID_TYPE` (`id`,`type`),</li>
<li>KEY `INDEX_NEWS_TYPE` (`type`)</li>
<li><p>) ENGINE=InnoDB AUTO_INCREMENT=1072779 DEFAULT CHARSET=utf8</p>
<p>插入数据一定要用 addBatch 超过300万条数据在我的笔记本上只需要近10分钟</p>
</li>
</ol>
<p>Java代码</p>
<ol>
<li>public static void main(String[] args) {</li>
<li><p>Connection conn = null;</p>
</li>
<li><p>// MySQL的JDBC URL编写方式：jdbc:mysql://主机名称：连接端口/数据库的名称?参数=值</p>
</li>
<li>// 避免中文乱码要指定useUnicode和characterEncoding</li>
<li>// 执行数据库操作之前要在数据库管理系统上创建一个数据库，名字自己定，</li>
<li>// 下面语句之前就要先创建javademo数据库</li>
<li>String url = “jdbc:mysql://localhost:3306/javademo?”</li>
<li><ul>
<li>“user=root&amp;password=root&amp;useUnicode=true&amp;characterEncoding=UTF8”;</li>
</ul>
</li>
<li>try {</li>
<li>Class.forName(“com.mysql.jdbc.Driver”);// 动态加载mysql驱动</li>
<li><p>conn = DriverManager.getConnection(url);</p>
</li>
<li><p>String   sql = “insert into news(title,content,type) values(?,?,?)”;</p>
</li>
<li><p>PreparedStatement prep = conn.prepareStatement(sql);</p>
</li>
<li>// 将连接的自动提交关闭，数据在传送到数据库的过程中相当耗时</li>
<li>conn.setAutoCommit(false);</li>
<li>long start = System.currentTimeMillis();</li>
<li>String type = “java”;</li>
<li>String content = “SUN公司开发Java语言的时候，在数据库这里只是提供了一个标准的接口，或者说是规范，叫做JDBC，这个东西单独放在那里没有任何作用，根本无法连接任何的数据库，只有当你下载相应的数据库驱动程序之后，才可以用JDBC通过这个驱动程序和数据库通信。sqlsever就有它的专门的驱动程序，在微软网站上可以下载到。SUN公司自己也开发了数据库驱动程序，叫做JDBC-ODBC驱动程序，是通过建立ODBC桥来连接Windows数据库，但是因为效率低并且有限制，现在一般都不推荐使用”;</li>
<li>for (int i = 0; i &lt; 30; i++) {</li>
<li>long start2 = System.currentTimeMillis();</li>
<li>// 一次性执行插入10万条数据</li>
<li>if(i==2){type=”php”;}</li>
<li>else if(i==3){type=”erlang”;}</li>
<li>else if(i==4){type=”go”;}</li>
<li>else if(i==5){type=”javascript”;}</li>
<li>else if(i==6){type=”html”;}</li>
<li>else if(i==7){type=”html5”;}</li>
<li>else if(i==8){type=”css”;}</li>
<li>else if(i==9){type=”python”;}</li>
<li>else if(i==10){type=”ror”;}</li>
<li>else if(i==11){type=”nodejs”;}</li>
<li>else if(i==12){type=”spring”;}</li>
<li>else if(i==13){type=”hibernate”;}</li>
<li>else if(i==14){type=”ibatis”;}</li>
<li>else if(i==15){type=”mybatis”;}</li>
<li>else if(i==16){type=”mysql”;}</li>
<li>else if(i==17){type=”msserver”;}</li>
<li>else if(i==18){type=”oracle”;}</li>
<li>else if(i==19){type=”redis”;}</li>
<li>else if(i==20){type=”mangodb”;}</li>
<li>else if(i==21){type=”c”;}</li>
<li>else if(i==22){type=”c++”;}</li>
<li>else if(i==23){type=”springside”;}</li>
<li>else if(i==24){type=”springroo”;}</li>
<li>else if(i==25){type=”sprintboot”;}</li>
<li>else if(i==26){type=”sprintmvc”;}</li>
<li>else if(i==27){type=”websocket”;}</li>
<li>else if(i==28){type=”restful”;}</li>
<li>else if(i==29){type=”comet”;}</li>
<li>for (int j = 0; j &lt; 100000; j++) {</li>
<li>prep.setString(1, “文章”+j);</li>
<li>prep.setString(2, content);</li>
<li>prep.setString(3, type);</li>
<li>prep.addBatch();</li>
<li>}</li>
<li>// 预处理批量执行</li>
<li>prep.executeBatch();</li>
<li>prep.clearBatch();</li>
<li>conn.commit();</li>
<li>long end2 = System.currentTimeMillis();</li>
<li><p>// 批量执行一次批量打印执行依次的时间</p>
</li>
<li><p>System.out.println(end2 - start2);</p>
</li>
<li>}</li>
<li>long end = System.currentTimeMillis();</li>
<li>System.out.print(“total: “);</li>
<li>System.out.println(end - start);</li>
<li>} catch (Exception e) {</li>
<li>e.printStackTrace();</li>
<li>} finally {</li>
<li>try {</li>
<li>conn.close();</li>
<li>} catch (SQLException e) {</li>
<li>// TODO Auto-generated catch block</li>
<li>e.printStackTrace();</li>
<li>}</li>
<li>}</li>
<li>}</li>
</ol>
<p>测试结果300万插入只需要597秒</p>
<ol>
<li>15031</li>
<li>15248</li>
<li>18522</li>
<li>18419</li>
<li>19223</li>
<li>19613</li>
<li>20822</li>
<li>18701</li>
<li>19468</li>
<li>21290</li>
<li>19766</li>
<li>20956</li>
<li>19490</li>
<li>19089</li>
<li>20290</li>
<li>22568</li>
<li>20079</li>
<li>20556</li>
<li>20922</li>
<li>22659</li>
<li>21155</li>
<li>19782</li>
<li>20378</li>
<li>21053</li>
<li>19459</li>
<li>22388</li>
<li>20323</li>
<li>20011</li>
<li>18158</li>
<li>21199</li>
<li><p>total: 596625</p>
<p>机器上一共插入了300万的数据，测试下查询：</p>
</li>
<li><p>select COUNT(id) from news</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li>Time: 0.729ms</li>
</ol>
<p>查询下分页</p>
<ol>
<li><p>select id,title from news limit 1000000,20</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li><p>Time: 7.839ms</p>
<p>从第100万条查询20条记录，耗费了八秒时间，速度慢  </p>
</li>
<li><p>[SQL] select id from news limit 1000000,20</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li>Time: 0.242ms</li>
</ol>
<p>id 是索引，所以更快点  </p>
<ol>
<li>[SQL]</li>
<li><p>select id from news order by id limit 1000000,20</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li>Time: 7.841ms</li>
</ol>
<p>order 加上去慢的太多了  </p>
<ol>
<li><p>select id,title from news where id&gt;=(select id from news order by id limit 1000000,1) limit 20</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li>Time: 8.115ms</li>
</ol>
<p>只要有order by在效率是上不去  </p>
<ol>
<li>[SQL]</li>
<li>select id  from news where type = ‘ibatis’    limit 1,500000;</li>
<li>Affected rows: 0</li>
<li>Time: 0.076ms</li>
</ol>
<ol>
<li><p>select id,title from news where type = ‘ibatis’  limit 1000000,20</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li>Time: 0.163ms</li>
</ol>
<p>Java代码  <img src="/uploads/2015/12/icon_star.png" alt="收藏代码"></p>
<ol>
<li>[SQL]</li>
<li>select id,title,type from news where type = ‘ibatis’    limit 1,500000;</li>
<li>Affected rows: 0</li>
<li>Time: 0.209ms</li>
</ol>
<p>Java代码  <img src="/uploads/2015/12/icon_star.png" alt="收藏代码"></p>
<ol>
<li>[SQL]</li>
<li>select id,title,content,type from news where type = ‘ibatis’    limit 1,500000;</li>
<li>Affected rows: 0</li>
<li>Time: 0.471ms</li>
</ol>
<p>加上大字段会消耗一点性能 <img src="/uploads/2015/12/137ad894-49bd-31a6-9fa4-3e2f99930c72.png" alt title="点击查看原始大小图片"> 可见复合索引带来性能的优势 <img src="/uploads/2015/12/f54e794d-5d08-3f01-9aff-6f251ae141b1.png" alt title="点击查看原始大小图片"> in的速度是惊人的，300万条记录里面里用in仅仅 0.004ms，最主要也是因为加了索引。 这里面有2个惊人的查询，这也刚好是分页的功能的查询</p>
<ol>
<li>select id  from news where type = ‘ibatis’    limit 1,500000;</li>
<li><p>select *  from news where id in(xxx,xxx,xxx,xxx……………)</p>
<p>最后把in的代码贴出来，大家也试试in的威力</p>
</li>
<li><p>select *  from news where id in(</p>
</li>
<li>2999999,2999998,2999997,2999996,2999995,2999994,2999993,2999992,2999991,2999990,2999989,</li>
<li>2999988,2999987,2999986,2999985,2999984,2999983,2999982,2999981,2999980,2999979,2999978,</li>
<li>2999977,2999976,2999975,2999974,2999973,2999972,2999971,2999970,2999969,2999968,2999967,</li>
<li>2999966,2999965,2999964,2999963,2999962,2999961,2999960,2999959,2999958,2999957,2999956,</li>
<li>2999955,2999954,2999953,2999952,2999951,2999950,2999949,2999948,2999947,2999946,2999945,</li>
<li>2999944,2999943,2999942,2999941,2999940,2999939,2999938,2999937,2999936,2999935,2999934,</li>
<li>2999933,2999932,2999931,2999930,2999929,2999928,2999927,2999926,2999925,2999924,2999923,</li>
<li>2999922,2999921,2999920,2999919,2999918,2999917,2999916,2999915,2999914,2999913,2999912,</li>
<li>2999911,2999910,2999909,2999908,2999907,2999906,2999905,2999904,2999903,2999902,2999901,</li>
<li>2999900,2999899,2999898,2999897,2999896,2999895,2999894,2999893,2999892,2999891,2999890,</li>
<li>2999889,2999888,2999887,2999886,2999885,2999884,2999883,2999882,2999881,2999880,2999879,</li>
<li>2999878,2999877,2999876,2999875,2999874,2999873,2999872,2999871,2999870,2999869,2999868,</li>
<li>2999867,2999866,2999865,2999864,2999863,2999862,2999861,2999860,2999859,2999858,2999857,</li>
<li>2999856,2999855,2999854,2999853,2999852,2999851,2999850,2999849,2999848,2999847,2999846,</li>
<li>2999845,2999844,2999843,2999842,2999841,2999840,2999839,2999838,2999837,2999836,2999835,</li>
<li>2999834,2999833,2999832,2999831,2999830,2999829,2999828,2999827,2999826,2999825,2999824,</li>
<li>2999823,2999822,2999821,2999820,2999819,2999818,2999817,2999816,2999815,2999814,2999813,2999812</li>
<li><p>)</p>
<p><img src="/uploads/2015/12/b70cf91e-9fac-3792-bfed-5c6474d64ae0.png" alt title="点击查看原始大小图片"> 最快的是0.003ms   试试in里面放1188个参数   <img src="/uploads/2015/12/8830527f-e550-3795-b315-d15c7bf395a3.jpg" alt title="点击查看原始大小图片"> 速度依然很惊人   现在数据已经添加到了至少2200万条数据，看看in的效果 <img src="/uploads/2015/12/09409dd7-0647-382b-a090-0a17a785894b.png" alt title="点击查看原始大小图片"> 几千万数据中in语句只需0.001ms <img src="/uploads/2015/12/500dea44-6342-3b6e-bfa5-9b0f35408310.png" alt title="点击查看原始大小图片"> 数据大了，这个语句消耗的时间也增加了点 0.406ms 返回记录49.9999万条</p>
</li>
</ol>

            
            <p class="more">
                <a href="/2015/12/22/2019030500050/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/22/2019030500050/" title="java插入mysql 300万-2200万数据，优化查询">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/22/2019030500073/">
    		MySQL函数
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-22T06:24:35.000Z">2015-12-22</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/函数/" title="函数">函数</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>复制代码 控制流函数 IFNULL(expr1,expr2) 如果expr1不是NULL，IFNULL()返回expr1，否则它返回expr2。IFNULL()返回一个数字或字符串值，取决于它被使用的上下文环境。 mysql&gt; select IFNULL(1,0); -&gt; 1 mysql&gt; select IFNULL(0,10); -&gt; 0 mysql&gt; select IFNULL(1/0,10); -&gt; 10 mysql&gt; select IFNULL(1/0,’yes’); -&gt; ‘yes’ IF(expr1,expr2,expr3) 如果expr1是TRUE(expr1&lt;&gt;0且expr1&lt;&gt;NULL)，那么IF()返回expr2，否则它返回expr3。IF()返回一个数字或字符串值，取决于它被使用的上下文。 mysql&gt; select IF(1&gt;2,2,3); -&gt; 3 mysql&gt; select IF(1&lt;2,’yes’,’no’); -&gt; ‘yes’ mysql&gt; select IF(strcmp(‘test’,’test1’),’yes’,’no’); -&gt; ‘no’ expr1作为整数值被计算，它意味着如果你正在测试浮点或字符串值，你应该使用一个比较操作来做。 mysql&gt; select IF(0.1,1,0); -&gt; 0 mysql&gt; select IF(0.1&lt;&gt;0,1,0); -&gt; 1 在上面的第一种情况中，IF(0.1)返回0，因为0.1被变换到整数值, 导致测试IF(0)。这可能不是你期望的。在第二种情况中，比较测试原来的浮点值看它是否是非零，比较的结果被用作一个整数。 CASE value WHEN [compare-value] THEN result [WHEN [compare-value] THEN result ] [ELSE result] END CASE WHEN [condition] THEN result [WHEN [condition] THEN result ] [ELSE result] END 第一个版本返回result，其中value=compare-value。第二个版本中如果第一个条件为真，返回result。如果没有匹配的result值，那么结果在ELSE后的result被返回。如果没有ELSE部分，那么NULL被返回。 mysql&gt; SELECT CASE 1 WHEN 1 THEN “one” WHEN 2 THEN “two” ELSE “more” END; -&gt; “one” mysql&gt; SELECT CASE WHEN 1&gt;0 THEN “true” ELSE “false” END; -&gt; “true” mysql&gt; SELECT CASE BINARY “B” when “a” then 1 when “b” then 2 END; -&gt; NULL 数学函数 所有的数学函数在一个出错的情况下返回NULL。 - 单目减。改变参数的符号。 mysql&gt; select - 2; 注意，如果这个操作符与一个BIGINT使用，返回值是一个BIGINT！这意味着你应该避免在整数上使用-，那可能有值-2^63！ ABS(X) 返回X的绝对值。 mysql&gt; select ABS(2); -&gt; 2 mysql&gt; select ABS(-32); -&gt; 32 该功能可安全用于BIGINT值。 SIGN(X) 返回参数的符号，为-1、0或1，取决于X是否是负数、零或正数。 mysql&gt; select SIGN(-32); -&gt; -1 mysql&gt; select SIGN(0); -&gt; 0 mysql&gt; select SIGN(234); -&gt; 1 MOD(N,M) % 模 (类似C中的%操作符)。返回N被M除的余数。 mysql&gt; select MOD(234, 10); -&gt; 4 mysql&gt; select 253 % 7; -&gt; 1 mysql&gt; select MOD(29,9); -&gt; 2 这个函数可安全用于BIGINT值。  FLOOR(X) 返回不大于X的最大整数值。 mysql&gt; select FLOOR(1.23); -&gt; 1 mysql&gt; select FLOOR(-1.23); -&gt; -2 注意返回值被变换为一个BIGINT！  CEILING(X) 返回不小于X的最小整数值。 mysql&gt; select CEILING(1.23); -&gt; 2 mysql&gt; select CEILING(-1.23); -&gt; -1 注意返回值被变换为一个BIGINT！ ROUND(X) 返回参数X的四舍五入的一个整数。 mysql&gt; select ROUND(-1.23); -&gt; -1 mysql&gt; select ROUND(-1.58); -&gt; -2 mysql&gt; select ROUND(1.58); -&gt; 2 注意返回值被变换为一个BIGINT! ROUND(X,D) 返回参数X的四舍五入的有D为小数的一个数字。如果D为0，结果将没有小数点或小数部分。 mysql&gt; select ROUND(1.298, 1); -&gt; 1.3 mysql&gt; select ROUND(1.298, 0); -&gt; 1 注意返回值被变换为一个BIGINT! EXP(X) 返回值e（自然对数的底）的X次方。 mysql&gt; select EXP(2); -&gt; 7.389056 mysql&gt; select EXP(-2); -&gt; 0.135335 LOG(X) 返回X的自然对数。 mysql&gt; select LOG(2); -&gt; 0.693147 mysql&gt; select LOG(-2); -&gt; NULL 如果你想要一个数字X的任意底B的对数，使用公式LOG(X)/LOG(B)。 LOG10(X) 返回X的以10为底的对数。 mysql&gt; select LOG10(2); -&gt; 0.301030 mysql&gt; select LOG10(100); -&gt; 2.000000 mysql&gt; select LOG10(-100); -&gt; NULL POW(X,Y) POWER(X,Y) 返回值X的Y次幂。 mysql&gt; select POW(2,2); -&gt; 4.000000 mysql&gt; select POW(2,-2); -&gt; 0.250000SQRT(X) 返回非负数X的平方根。 mysql&gt; select SQRT(4); -&gt; 2.000000 mysql&gt; select SQRT(20); -&gt; 4.472136 PI() 返回PI的值（圆周率）。 mysql&gt; select PI(); -&gt; 3.141593 COS(X) 返回X的余弦, 在这里X以弧度给出。 mysql&gt; select COS(PI()); -&gt; -1.000000 SIN(X) 返回X的正弦值，在此X以弧度给出。 mysql&gt; select SIN(PI()); -&gt; 0.000000 TAN(X) 返回X的正切值，在此X以弧度给出。 mysql&gt; select TAN(PI()+1); -&gt; 1.557408 ACOS(X) 返回X反余弦，即其余弦值是X。如果X不在-1到1的范围，返回NULL。 mysql&gt; select ACOS(1); -&gt; 0.000000 mysql&gt; select ACOS(1.0001); -&gt; NULL mysql&gt; select ACOS(0); -&gt; 1.570796 ASIN(X) 返回X反正弦值，即其正弦值是X。L如果X不在-1到1的范围，返回NULL。 mysql&gt; select ASIN(0.2); -&gt; 0.201358 mysql&gt; select ASIN(‘foo’); -&gt; 0.000000 ATAN(X) 返回X的反正切值，即其正切值是X。 mysql&gt; select ATAN(2); -&gt; 1.107149 mysql&gt; select ATAN(-2); -&gt; -1.107149ATAN2(X,Y) 返回2个变量X和Y的反正切。它类似于计算Y/X的反正切，除了两个参数的符号被用来决定结果的象限。 mysql&gt; select ATAN(-2,2); -&gt; -0.785398 mysql&gt; select ATAN(PI(),0); -&gt; 1.570796 COT(X) 返回X的余切。 mysql&gt; select COT(12); -&gt; -1.57267341 mysql&gt; select COT(0); -&gt; NULL RAND() RAND(N) 返回在范围0到1.0内的随机浮点值。如果一个整数参数N被指定，它被用作种子值。 mysql&gt; select RAND(); -&gt; 0.5925 mysql&gt; select RAND(20); -&gt; 0.1811 mysql&gt; select RAND(20); -&gt; 0.1811 mysql&gt; select RAND(); -&gt; 0.2079 mysql&gt; select RAND(); -&gt; 0.7888 你不能在一个ORDER BY子句用RAND()值使用列，因为ORDER BY将重复计算列多次。然而在MySQL3.23中，你可以做： SELECT <em> FROM table_name ORDER BY RAND()，这是有利于得到一个来自SELECT </em> FROM table1,table2 WHERE a=b AND c<d order by rand() limit 1000的集合的随机样本。注意在一个where子句里的一个rand()将在每次where被执行时重新评估。 least(x,y,) 有2和2个以上的参数，返回最小(最小值)的参数。参数使用下列规则进行比较： 如果返回值被使用在一个integer上下文，或所有的参数都是整数值，他们作为整数比较。 如果返回值被使用在一个real上下文，或所有的参数是实数值，他们作为实数比较。 如果任何参数是一个大小敏感的字符串，参数作为大小写敏感的字符串被比较。 在其他的情况下，参数作为大小写无关的字符串被比较。 mysql> select LEAST(2,0); -&gt; 0 mysql&gt; select LEAST(34.0,3.0,5.0,767.0); -&gt; 3.0 mysql&gt; select LEAST(“B”,”A”,”C”); -&gt; “A” 在MySQL 3.22.5以前的版本，你可以使用MIN()而不是LEAST。 GREATEST(X,Y,) 返回最大(最大值)的参数。参数使用与LEAST一样的规则进行比较。 mysql&gt; select GREATEST(2,0); -&gt; 2 mysql&gt; select GREATEST(34.0,3.0,5.0,767.0); -&gt; 767.0 mysql&gt; select GREATEST(“B”,”A”,”C”); -&gt; “C” 在MySQL在 3.22.5 以前的版本, 你能使用MAX()而不是GREATEST.  DEGREES(X) 返回参数X，从弧度变换为角度。 mysql&gt; select DEGREES(PI()); -&gt; 180.000000RADIANS(X) 返回参数X，从角度变换为弧度。 mysql&gt; select RADIANS(90); -&gt; 1.570796 TRUNCATE(X,D) 返回数字X，截断为D位小数。如果D为0，结果将没有小数点或小数部分。 mysql&gt; select TRUNCATE(1.223,1); -&gt; 1.2 mysql&gt; select TRUNCATE(1.999,1); -&gt; 1.9 mysql&gt; select TRUNCATE(1.999,0); -&gt; 1 字符串函数对于针对字符串位置的操作，第一个位置被标记为1。 ASCII(str) 返回字符串str的最左面字符的ASCII代码值。如果str是空字符串，返回0。如果str是NULL，返回NULL。 mysql&gt; select ASCII(‘2’); -&gt; 50 mysql&gt; select ASCII(2); -&gt; 50 mysql&gt; select ASCII(‘dx’); -&gt; 100也可参见ORD()函数。 ORD(str) 如果字符串str最左面字符是一个多字节字符，通过以格式((first byte ASCII code)*256+(second byte ASCII code))[*256+third byte ASCII code]返回字符的ASCII代码值来返回多字节字符代码。如果最左面的字符不是一个多字节字符。返回与ASCII()函数返回的相同值。 mysql&gt; select ORD(‘2’); -&gt; 50 CONV(N,from_base,to_base) 在不同的数字基之间变换数字。返回数字N的字符串数字，从from_base基变换为to_base基，如果任何参数是NULL，返回NULL。参数N解释为一个整数，但是可以指定为一个整数或一个字符串。最小基是2且最大的基是36。如果to_base是一个负数，N被认为是一个有符号数，否则，N被当作无符号数。 CONV以64位点精度工作。 mysql&gt; select CONV(“a”,16,2); -&gt; ‘1010’ mysql&gt; select CONV(“6E”,18,8); -&gt; ‘172’ mysql&gt; select CONV(-17,10,-18); -&gt; ‘-H’ mysql&gt; select CONV(10+”10”+’10’+0xa,10,10); -&gt; ‘40’ BIN(N) 返回二进制值N的一个字符串表示，在此N是一个长整数(BIGINT)数字，这等价于CONV(N,10,2)。如果N是NULL，返回NULL。 mysql&gt; select BIN(12); -&gt; ‘1100’ OCT(N) 返回八进制值N的一个字符串的表示，在此N是一个长整型数字，这等价于CONV(N,10,8)。如果N是NULL，返回NULL。 mysql&gt; select OCT(12); -&gt; ‘14’ HEX(N) 返回十六进制值N一个字符串的表示，在此N是一个长整型(BIGINT)数字，这等价于CONV(N,10,16)。如果N是NULL，返回NULL。 mysql&gt; select HEX(255); -&gt; ‘FF’ CHAR(N,) CHAR()将参数解释为整数并且返回由这些整数的ASCII代码字符组成的一个字符串。NULL值被跳过。 mysql&gt; select CHAR(77,121,83,81,’76’); -&gt; ‘MySQL’ mysql&gt; select CHAR(77,77.3,’77.3’); -&gt; ‘MMM’ CONCAT(str1,str2,) 返回来自于参数连结的字符串。如果任何参数是NULL，返回NULL。可以有超过2个的参数。一个数字参数被变换为等价的字符串形式。 mysql&gt; select CONCAT(‘My’, ‘S’, ‘QL’); -&gt; ‘MySQL’ mysql&gt; select CONCAT(‘My’, NULL, ‘QL’); -&gt; NULL mysql&gt; select CONCAT(14.3); -&gt; ‘14.3’ LENGTH(str) OCTET_LENGTH(str) CHAR_LENGTH(str) CHARACTER_LENGTH(str) 返回字符串str的长度。 mysql&gt; select LENGTH(‘text’); -&gt; 4 mysql&gt; select OCTET_LENGTH(‘text’); -&gt; 4 注意，对于多字节字符，其CHAR_LENGTH()仅计算一次。 LOCATE(substr,str) POSITION(substr IN str) 返回子串substr在字符串str第一个出现的位置，如果substr不是在str里面，返回0. mysql&gt; select LOCATE(‘bar’, ‘foobarbar’); -&gt; 4 mysql&gt; select LOCATE(‘xbar’, ‘foobar’); -&gt; 0 该函数是多字节可靠的。  LOCATE(substr,str,pos) 返回子串substr在字符串str第一个出现的位置，从位置pos开始。如果substr不是在str里面，返回0。 mysql&gt; select LOCATE(‘bar’, ‘foobarbar’,5); -&gt; 7 这函数是多字节可靠的。 INSTR(str,substr) 返回子串substr在字符串str中的第一个出现的位置。这与有2个参数形式的LOCATE()相同，除了参数被颠倒。 mysql&gt; select INSTR(‘foobarbar’, ‘bar’); -&gt; 4 mysql&gt; select INSTR(‘xbar’, ‘foobar’); -&gt; 0 这函数是多字节可靠的。 LPAD(str,len,padstr) 返回字符串str，左面用字符串padstr填补直到str是len个字符长。 mysql&gt; select LPAD(‘hi’,4,’??’); -&gt; ‘??hi’ RPAD(str,len,padstr) 返回字符串str，右面用字符串padstr填补直到str是len个字符长。 mysql&gt; select RPAD(‘hi’,5,’?’); -&gt; ‘hi???’ LEFT(str,len) 返回字符串str的最左面len个字符。 mysql&gt; select LEFT(‘foobarbar’, 5); -&gt; ‘fooba’ 该函数是多字节可靠的。 RIGHT(str,len) 返回字符串str的最右面len个字符。 mysql&gt; select RIGHT(‘foobarbar’, 4); -&gt; ‘rbar’ 该函数是多字节可靠的。 SUBSTRING(str,pos,len) SUBSTRING(str FROM pos FOR len) MID(str,pos,len) 从字符串str返回一个len个字符的子串，从位置pos开始。使用FROM的变种形式是ANSI SQL92语法。 mysql&gt; select SUBSTRING(‘Quadratically’,5,6); -&gt; ‘ratica’ 该函数是多字节可靠的。 SUBSTRING(str,pos) SUBSTRING(str FROM pos) 从字符串str的起始位置pos返回一个子串。 mysql&gt; select SUBSTRING(‘Quadratically’,5); -&gt; ‘ratically’ mysql&gt; select SUBSTRING(‘foobarbar’ FROM 4); -&gt; ‘barbar’ 该函数是多字节可靠的。 SUBSTRING_INDEX(str,delim,count) 返回从字符串str的第count个出现的分隔符delim之后的子串。如果count是正数，返回最后的分隔符到左边(从左边数) 的所有字符。如果count是负数，返回最后的分隔符到右边的所有字符(从右边数)。 mysql&gt; select SUBSTRING_INDEX(‘<a href="http://www.mysql.com&#39;" target="_blank" rel="noopener">www.mysql.com&#39;</a>, ‘.’, 2); -&gt; ‘<a href="http://www.mysql&#39;" target="_blank" rel="noopener">www.mysql&#39;</a> mysql&gt; select SUBSTRING_INDEX(‘<a href="http://www.mysql.com&#39;" target="_blank" rel="noopener">www.mysql.com&#39;</a>, ‘.’, -2); -&gt; ‘mysql.com’ 该函数对多字节是可靠的。 LTRIM(str) 返回删除了其前置空格字符的字符串str。 mysql&gt; select LTRIM(‘  barbar’); -&gt; ‘barbar’ RTRIM(str) 返回删除了其拖后空格字符的字符串str。 mysql&gt; select RTRIM(‘barbar   ‘); -&gt; ‘barbar’ 该函数对多字节是可靠的。  TRIM([[BOTH | LEADING | TRAILING] [remstr] FROM] str) 返回字符串str，其所有remstr前缀或后缀被删除了。如果没有修饰符BOTH、LEADING或TRAILING给出，BOTH被假定。如果remstr没被指定，空格被删除。 mysql&gt; select TRIM(‘  bar   ‘); -&gt; ‘bar’ mysql&gt; select TRIM(LEADING ‘x’ FROM ‘xxxbarxxx’); -&gt; ‘barxxx’ mysql&gt; select TRIM(BOTH ‘x’ FROM ‘xxxbarxxx’); -&gt; ‘bar’ mysql&gt; select TRIM(TRAILING ‘xyz’ FROM ‘barxxyz’); -&gt; ‘barx’ 该函数对多字节是可靠的。 SOUNDEX(str) 返回str的一个同音字符串。听起来“大致相同”的2个字符串应该有相同的同音字符串。一个“标准”的同音字符串长是4个字符，但是SOUNDEX()函数返回一个任意长的字符串。你可以在结果上使用SUBSTRING()得到一个“标准”的 同音串。所有非数字字母字符在给定的字符串中被忽略。所有在A-Z之外的字符国际字母被当作元音。 mysql&gt; select SOUNDEX(‘Hello’); -&gt; ‘H400’ mysql&gt; select SOUNDEX(‘Quadratically’); -&gt; ‘Q36324’ SPACE(N) 返回由N个空格字符组成的一个字符串。 mysql&gt; select SPACE(6); -&gt; ‘      ‘ REPLACE(str,from_str,to_str) 返回字符串str，其字符串from_str的所有出现由字符串to_str代替。 mysql&gt; select REPLACE(‘<a href="http://www.mysql.com&#39;" target="_blank" rel="noopener">www.mysql.com&#39;</a>, ‘w’, ‘Ww’); -&gt; ‘WwWwWw.mysql.com’ 该函数对多字节是可靠的。 REPEAT(str,count) 返回由重复countTimes次的字符串str组成的一个字符串。如果count &lt;= 0，返回一个空字符串。如果str或count是NULL，返回NULL。 mysql&gt; select REPEAT(‘MySQL’, 3); -&gt; ‘MySQLMySQLMySQL’ REVERSE(str) 返回颠倒字符顺序的字符串str。 mysql&gt; select REVERSE(‘abc’); -&gt; ‘cba’ 该函数对多字节可靠的。 INSERT(str,pos,len,newstr) 返回字符串str，在位置pos起始的子串且len个字符长得子串由字符串newstr代替。 mysql&gt; select INSERT(‘Quadratic’, 3, 4, ‘What’); -&gt; ‘QuWhattic’ 该函数对多字节是可靠的。 ELT(N,str1,str2,str3,) 如果N= 1，返回str1，如果N= 2，返回str2，等等。如果N小于1或大于参数个数，返回NULL。ELT()是FIELD()反运算。 mysql&gt; select ELT(1, ‘ej’, ‘Heja’, ‘hej’, ‘foo’); -&gt; ‘ej’ mysql&gt; select ELT(4, ‘ej’, ‘Heja’, ‘hej’, ‘foo’); -&gt; ‘foo’ FIELD(str,str1,str2,str3,) 返回str在str1, str2, str3, 清单的索引。如果str没找到，返回0。FIELD()是ELT()反运算。 mysql&gt; select FIELD(‘ej’, ‘Hej’, ‘ej’, ‘Heja’, ‘hej’, ‘foo’); -&gt; 2 mysql&gt; select FIELD(‘fo’, ‘Hej’, ‘ej’, ‘Heja’, ‘hej’, ‘foo’); -&gt; 0 FIND_IN_SET(str,strlist) 如果字符串str在由N子串组成的表strlist之中，返回一个1到N的值。一个字符串表是被“,”分隔的子串组成的一个字符串。如果第一个参数是一个常数字符串并且第二个参数是一种类型为SET的列，FIND_IN_SET()函数被优化而使用位运算！如果str不是在strlist里面或如果strlist是空字符串，返回0。如果任何一个参数是NULL，返回NULL。如果第一个参数包含一个“,”，该函数将工作不正常。 mysql&gt; SELECT FIND_IN_SET(‘b’,’a,b,c,d’); -&gt; 2 MAKE_SET(bits,str1,str2,) 返回一个集合 (包含由“,”字符分隔的子串组成的一个字符串)，由相应的位在bits集合中的的字符串组成。str1对应于位0，str2对应位1，等等。在str1, str2, 中的NULL串不添加到结果中。 mysql&gt; SELECT MAKE_SET(1,’a’,’b’,’c’); -&gt; ‘a’ mysql&gt; SELECT MAKE_SET(1 | 4,’hello’,’nice’,’world’); -&gt; ‘hello,world’ mysql&gt; SELECT MAKE_SET(0,’a’,’b’,’c’); -&gt; ‘’ EXPORT_SET(bits,on,off,[separator,[number_of_bits]]) 返回一个字符串，在这里对于在“bits”中设定每一位，你得到一个“on”字符串，并且对于每个复位(reset)的位，你得到一个“off”字符串。每个字符串用“separator”分隔(缺省“,”)，并且只有“bits”的“number_of_bits” (缺省64)位被使用。 mysql&gt; select EXPORT_SET(5,’Y’,’N’,’,’,4) -&gt; Y,N,Y,N LCASE(str) LOWER(str) 返回字符串str，根据当前字符集映射(缺省是ISO-8859-1 Latin1)把所有的字符改变成小写。该函数对多字节是可靠的。 mysql&gt; select LCASE(‘QUADRATICALLY’); -&gt; ‘quadratically’ UCASE(str) UPPER(str) 返回字符串str，根据当前字符集映射(缺省是ISO-8859-1 Latin1)把所有的字符改变成大写。该函数对多字节是可靠的。 mysql&gt; select UCASE(‘Hej’); -&gt; ‘HEJ’ 该函数对多字节是可靠的。 LOAD_FILE(file_name) 读入文件并且作为一个字符串返回文件内容。文件必须在服务器上，你必须指定到文件的完整路径名，而且你必须有file权限。文件必须所有内容都是可读的并且小于max_allowed_packet。如果文件不存在或由于上面原因之一不能被读出，函数返回NULL。 mysql&gt; UPDATE table_name SET blob_column=LOAD_FILE(“/tmp/picture”) WHERE id=1; MySQL必要时自动变换数字为字符串，并且反过来也如此： mysql&gt; SELECT 1+”1”; -&gt; 2 mysql&gt; SELECT CONCAT(2,’ test’); -&gt; ‘2 test’ 如果你想要明确地变换一个数字到一个字符串，把它作为参数传递到CONCAT()。 如果字符串函数提供一个二进制字符串作为参数，结果字符串也是一个二进制字符串。被变换到一个字符串的数字被当作是一个二进制字符串。这仅影响比较。   日期和时间函数   对于每个类型拥有的值范围以及并且指定日期何时间值的有效格式的描述见7.3.6 日期和时间类型。 这里是一个使用日期函数的例子。下面的查询选择了所有记录，其date_col的值是在最后30天以内： mysql&gt; SELECT something FROM table WHERE TO_DAYS(NOW()) - TO_DAYS(date_col) &lt;= 30; DAYOFWEEK(date) 返回日期date的星期索引(1=星期天，2=星期一, ……7=星期六)。这些索引值对应于ODBC标准。 mysql&gt; select DAYOFWEEK(‘1998-02-03’); -&gt; 3 WEEKDAY(date) 返回date的星期索引(0=星期一，1=星期二, ……6= 星期天)。 mysql&gt; select WEEKDAY(‘1997-10-04 22:23:00’); -&gt; 5 mysql&gt; select WEEKDAY(‘1997-11-05’); -&gt; 2 DAYOFMONTH(date) 返回date的月份中日期，在1到31范围内。 mysql&gt; select DAYOFMONTH(‘1998-02-03’); -&gt; 3 DAYOFYEAR(date) 返回date在一年中的日数, 在1到366范围内。 mysql&gt; select DAYOFYEAR(‘1998-02-03’); -&gt; 34 MONTH(date) 返回date的月份，范围1到12。 mysql&gt; select MONTH(‘1998-02-03’); -&gt; 2 DAYNAME(date) 返回date的星期名字。 mysql&gt; select DAYNAME(“1998-02-05”); -&gt; ‘Thursday’ MONTHNAME(date) 返回date的月份名字。 mysql&gt; select MONTHNAME(“1998-02-05”); -&gt; ‘February’ QUARTER(date) 返回date一年中的季度，范围1到4。 mysql&gt; select QUARTER(‘98-04-01’); -&gt; 2 WEEK(date) WEEK(date,first) 对于星期天是一周的第一天的地方，有一个单个参数，返回date的周数，范围在0到52。2个参数形式WEEK()允许你指定星期是否开始于星期天或星期一。如果第二个参数是0，星期从星期天开始，如果第二个参数是1，从星期一开始。 mysql&gt; select WEEK(‘1998-02-20’); -&gt; 7 mysql&gt; select WEEK(‘1998-02-20’,0); -&gt; 7 mysql&gt; select WEEK(‘1998-02-20’,1); -&gt; 8 YEAR(date) 返回date的年份，范围在1000到9999。 mysql&gt; select YEAR(‘98-02-03’); -&gt; 1998 HOUR(time) 返回time的小时，范围是0到23。 mysql&gt; select HOUR(‘10:05:03’); -&gt; 10 MINUTE(time) 返回time的分钟，范围是0到59。 mysql&gt; select MINUTE(‘98-02-03 10:05:03’); -&gt; 5 SECOND(time) 回来time的秒数，范围是0到59。 mysql&gt; select SECOND(‘10:05:03’); -&gt; 3 PERIOD_ADD(P,N) 增加N个月到阶段P（以格式YYMM或YYYYMM)。以格式YYYYMM返回值。注意阶段参数P不是日期值。 mysql&gt; select PERIOD_ADD(9801,2); -&gt; 199803 PERIOD_DIFF(P1,P2) 返回在时期P1和P2之间月数，P1和P2应该以格式YYMM或YYYYMM。注意，时期参数P1和P2不是日期值。 mysql&gt; select PERIOD_DIFF(9802,199703); -&gt; 11 DATE_ADD(date,INTERVAL expr type) DATE_SUB(date,INTERVAL expr type) ADDDATE(date,INTERVAL expr type) SUBDATE(date,INTERVAL expr type) 这些功能执行日期运算。对于MySQL 3.22，他们是新的。ADDDATE()和SUBDATE()是DATE_ADD()和DATE_SUB()的同义词。在MySQL 3.23中，你可以使用+和-而不是DATE_ADD()和DATE_SUB()。（见例子）date是一个指定开始日期的DATETIME或DATE值，expr是指定加到开始日期或从开始日期减去的间隔值一个表达式，expr是一个字符串；它可以以一个“-”开始表示负间隔。type是一个关键词，指明表达式应该如何被解释。EXTRACT(type FROM date)函数从日期中返回“type”间隔。下表显示了type和expr参数怎样被关联： type值  含义  期望的expr格式 SECOND  秒 SECONDS MINUTE  分钟 MINUTES HOUR  时间 HOURS DAY  天 DAYS MONTH  月 MONTHS YEAR  年 YEARS MINUTE_SECOND  分钟和秒 “MINUTES:SECONDS” HOUR_MINUTE  小时和分钟 “HOURS:MINUTES” DAY_HOUR  天和小时 “DAYS HOURS” YEAR_MONTH  年和月 “YEARS-MONTHS” HOUR_SECOND  小时, 分钟， “HOURS:MINUTES:SECONDS” DAY_MINUTE  天, 小时, 分钟 “DAYS HOURS:MINUTES” DAY_SECOND  天, 小时, 分钟, 秒 “DAYS HOURS:MINUTES:SECONDS” MySQL在expr格式中允许任何标点分隔符。表示显示的是建议的分隔符。如果date参数是一个DATE值并且你的计算仅仅包含YEAR、MONTH和DAY部分(即，没有时间部分)，结果是一个DATE值。否则结果是一个DATETIME值。 mysql&gt; SELECT “1997-12-31 23:59:59” + INTERVAL 1 SECOND; -&gt; 1998-01-01 00:00:00 mysql&gt; SELECT INTERVAL 1 DAY + “1997-12-31”; -&gt; 1998-01-01 mysql&gt; SELECT “1998-01-01” - INTERVAL 1 SECOND; -&gt; 1997-12-31 23:59:59 mysql&gt; SELECT DATE_ADD(“1997-12-31 23:59:59”, INTERVAL 1 SECOND); -&gt; 1998-01-01 00:00:00 mysql&gt; SELECT DATE_ADD(“1997-12-31 23:59:59”, INTERVAL 1 DAY); -&gt; 1998-01-01 23:59:59 mysql&gt; SELECT DATE_ADD(“1997-12-31 23:59:59”, INTERVAL “1:1” MINUTE_SECOND); -&gt; 1998-01-01 00:01:00 mysql&gt; SELECT DATE_SUB(“1998-01-01 00:00:00”, INTERVAL “1 1:1:1” DAY_SECOND); -&gt; 1997-12-30 22:58:59 mysql&gt; SELECT DATE_ADD(“1998-01-01 00:00:00”, INTERVAL “-1 10” DAY_HOUR); -&gt; 1997-12-30 14:00:00 mysql&gt; SELECT DATE_SUB(“1998-01-02”, INTERVAL 31 DAY); -&gt; 1997-12-02 mysql&gt; SELECT EXTRACT(YEAR FROM “1999-07-02”); -&gt; 1999 mysql&gt; SELECT EXTRACT(YEAR_MONTH FROM “1999-07-02 01:02:03”); -&gt; 199907 mysql&gt; SELECT EXTRACT(DAY_MINUTE FROM “1999-07-02 01:02:03”); -&gt; 20102 如果你指定太短的间隔值(不包括type关键词期望的间隔部分)，MySQL假设你省掉了间隔值的最左面部分。例如，如果你指定一个type是DAY_SECOND，值expr被希望有天、小时、分钟和秒部分。如果你象”1:10”这样指定值，MySQL假设日子和小时部分是丢失的并且值代表分钟和秒。换句话说，”1:10” DAY_SECOND以它等价于”1:10” MINUTE_SECOND的方式解释，这对那MySQL解释TIME值表示经过的时间而非作为一天的时间的方式有二义性。如果你使用确实不正确的日期，结果是NULL。如果你增加MONTH、YEAR_MONTH或YEAR并且结果日期大于新月份的最大值天数，日子在新月用最大的天调整。 mysql&gt; select DATE_ADD(‘1998-01-30’, Interval 1 month); -&gt; 1998-02-28 注意，从前面的例子中词INTERVAL和type关键词不是区分大小写的。  TO_DAYS(date) 给出一个日期date，返回一个天数(从0年的天数)。 mysql&gt; select TO_DAYS(950501); -&gt; 728779 mysql&gt; select TO_DAYS(‘1997-10-07’); -&gt; 729669 TO_DAYS()不打算用于使用格列高里历(1582)出现前的值。 FROM_DAYS(N) 给出一个天数N，返回一个DATE值。 mysql&gt; select FROM_DAYS(729669); -&gt; ‘1997-10-07’ TO_DAYS()不打算用于使用格列高里历(1582)出现前的值。 DATE_FORMAT(date,format) 根据format字符串格式化date值。下列修饰符可以被用在format字符串中： %M  月名字(January……December) %W  星期名字(Sunday……Saturday) %D  有英语前缀的月份的日期(1st, 2nd, 3rd, 等等。） %Y  年, 数字, 4 位 %y  年, 数字, 2 位 %a  缩写的星期名字(Sun……Sat) %d  月份中的天数, 数字(00……31) %e  月份中的天数, 数字(0……31) %m  月, 数字(01……12) %c  月, 数字(1……12) %b  缩写的月份名字(Jan……Dec) %j  一年中的天数(001……366) %H  小时(00……23) %k  小时(0……23) %h  小时(01……12) %I  小时(01……12) %l  小时(1……12) %i  分钟, 数字(00……59) %r  时间,12 小时(hh:mm:ss [AP]M) %T  时间,24 小时(hh:mm:ss) %S  秒(00……59) %s  秒(00……59) %p  AM或PM %w  一个星期中的天数(0=Sunday ……6=Saturday ） %U  星期(0……52), 这里星期天是星期的第一天 %u  星期(0……52), 这里星期一是星期的第一天 %%  一个文字“%”。 所有的其他字符不做解释被复制到结果中。 mysql&gt; select DATE_FORMAT(‘1997-10-04 22:23:00’, ‘%W %M %Y’); -&gt; ‘Saturday October 1997’ mysql&gt; select DATE_FORMAT(‘1997-10-04 22:23:00’, ‘%H:%i:%s’); -&gt; ‘22:23:00’ mysql&gt; select DATE_FORMAT(‘1997-10-04 22:23:00’, ‘%D %y %a %d %m %b %j’); -&gt; ‘4th 97 Sat 04 10 Oct 277’ mysql&gt; select DATE_FORMAT(‘1997-10-04 22:23:00’, ‘%H %k %I %r %T %S %w’); -&gt; ‘22 22 10 10:23:00 PM 22:23:00 00 6’MySQL3.23中，在格式修饰符字符前需要%。在MySQL更早的版本中，%是可选的。 TIME_FORMAT(time,format) 这象上面的DATE_FORMAT()函数一样使用，但是format字符串只能包含处理小时、分钟和秒的那些格式修饰符。其他修饰符产生一个NULL值或0。 CURDATE() CURRENT_DATE 以’YYYY-MM-DD’或YYYYMMDD格式返回今天日期值，取决于函数是在一个字符串还是数字上下文被使用。 mysql&gt; select CURDATE(); -&gt; ‘1997-12-15’ mysql&gt; select CURDATE() + 0; -&gt; 19971215 CURTIME() CURRENT_TIME 以’HH:MM:SS’或HHMMSS格式返回当前时间值，取决于函数是在一个字符串还是在数字的上下文被使用。 mysql&gt; select CURTIME(); -&gt; ‘23:50:26’ mysql&gt; select CURTIME() + 0; -&gt; 235026 NOW() SYSDATE() CURRENT_TIMESTAMP 以’YYYY-MM-DD HH:MM:SS’或YYYYMMDDHHMMSS格式返回当前的日期和时间，取决于函数是在一个字符串还是在数字的上下文被使用。 mysql&gt; select NOW(); -&gt; ‘1997-12-15 23:50:26’ mysql&gt; select NOW() + 0; -&gt; 19971215235026 UNIX_TIMESTAMP() UNIX_TIMESTAMP(date) 如果没有参数调用，返回一个Unix时间戳记(从’1970-01-01 00:00:00’GMT开始的秒数)。如果UNIX_TIMESTAMP()用一个date参数被调用，它返回从’1970-01-01 00:00:00’ GMT开始的秒数值。date可以是一个DATE字符串、一个DATETIME字符串、一个TIMESTAMP或以YYMMDD或YYYYMMDD格式的本地时间的一个数字。 mysql&gt; select UNIX_TIMESTAMP(); -&gt; 882226357 mysql&gt; select UNIX_TIMESTAMP(‘1997-10-04 22:23:00’); -&gt; 875996580 当UNIX_TIMESTAMP被用于一个TIMESTAMP列，函数将直接接受值，没有隐含的“string-to-unix-timestamp”变换。 FROM_UNIXTIME(unix_timestamp) 以’YYYY-MM-DD HH:MM:SS’或YYYYMMDDHHMMSS格式返回unix_timestamp参数所表示的值，取决于函数是在一个字符串还是或数字上下文中被使用。 mysql&gt; select FROM_UNIXTIME(875996580); -&gt; ‘1997-10-04 22:23:00’ mysql&gt; select FROM_UNIXTIME(875996580) + 0; -&gt; 19971004222300 FROM_UNIXTIME(unix_timestamp,format) 返回表示 Unix 时间标记的一个字符串，根据format字符串格式化。format可以包含与DATE_FORMAT()函数列出的条目同样的修饰符。 mysql&gt; select FROM_UNIXTIME(UNIX_TIMESTAMP(), ‘%Y %D %M %h:%i:%s %x’); -&gt; ‘1997 23rd December 03:43:30 x’ SEC_TO_TIME(seconds) 返回seconds参数，变换成小时、分钟和秒，值以’HH:MM:SS’或HHMMSS格式化，取决于函数是在一个字符串还是在数字上下文中被使用。 mysql&gt; select SEC_TO_TIME(2378); -&gt; ‘00:39:38’ mysql&gt; select SEC_TO_TIME(2378) + 0; -&gt; 3938 TIME_TO_SEC(time) 返回time参数，转换成秒。 mysql&gt; select TIME_TO_SEC(‘22:23:00’); -&gt; 80580 mysql&gt; select TIME_TO_SEC(‘00:39:38’); -&gt; 2378 其他函数 DATABASE() 返回当前的数据库名字。 mysql&gt; select DATABASE(); -&gt; ‘test’ 如果没有当前的数据库，DATABASE()返回空字符串。 USER() 　 SYSTEM_USER() 　 SESSION_USER() 返回当前MySQL用户名。 mysql&gt; select USER(); -&gt; ‘davida@localhost’ 在MySQL 3.22.11或以后版本中，这包括用户名和客户主机名。你可以象这样只提取用户名部分(值是否包括主机名部分均可工作)： mysql&gt; select substring_index(USER(),”@”,1); -&gt; ‘davida’ PASSWORD(str) 从纯文本口令str计算一个口令字符串。该函数被用于为了在user授权表的Password列中存储口令而加密MySQL口令。 mysql&gt; select PASSWORD(‘badpwd’); -&gt; ‘7f84554057dd964b’ PASSWORD()加密是非可逆的。PASSWORD()不以与Unix口令加密的相同的方法执行口令加密。你不应该假定如果你的Unix 口令和你的MySQL口令是一样的，PASSWORD()将导致与在Unix口令文件存储的相同的加密值。见ENCRYPT()。 ENCRYPT(str[,salt]) 使用Unix crypt()系统调用加密str。salt参数应该是一个有2个字符的字符串。（MySQL 3.22.16中，salt可以长于2个字符。） mysql&gt; select ENCRYPT(“hello”); -&gt; ‘VxuFAJXVARROc’ 如果crypt()在你的系统上不可用，ENCRYPT()总是返回NULL。ENCRYPT()只保留str起始8个字符而忽略所有其他，至少在某些系统上是这样。这将由底层的crypt()系统调用的行为决定。 ENCODE(str,pass_str) 使用pass_str作为口令加密str。为了解密结果，使用DECODE()。结果是一个二进制字符串，如果你想要在列中保存它，使用一个BLOB列类型。 DECODE(crypt_str,pass_str) 使用pass_str作为口令解密加密的字符串crypt_str。crypt_str应该是一个由ENCODE()返回的字符串。 MD5(string) 对字符串计算MD5校验和。值作为一个32长的十六进制数字被返回可以，例如用作哈希(hash)键。 mysql&gt; select MD5(“testing”) -&gt; ‘ae2b1fca515949e5d54fb22b8ed95575’ 这是一个“RSA数据安全公司的MD5消息摘要算法”。 LAST_INSERT_ID([expr]) 返回被插入一个AUTO_INCREMENT列的最后一个自动产生的值。见20.4.29 mysql_insert_id()。 mysql&gt; select LAST_INSERT_ID(); -&gt; 195 产生的最后ID以每个连接为基础在服务器被维护，它不会被其他客户改变。如果你更新另外一个有非魔术值(即，不是NULL和不是0的一个值)的AUTO_INCREMENT列，它甚至不会被改变。如果expr作为一个参数在一个UPDATE子句的LAST_INSERT_ID()里面给出，那么参数值作为一个LAST_INSERT_ID()值被返回。这可以用来模仿顺序：首先创建表： mysql&gt; create table sequence (id int not null); mysql&gt; insert into sequence values (0); 然后表能被用来产生顺序号，象这样： mysql&gt; update sequence set id=LAST_INSERT_ID(id+1); 你可以不调用LAST_INSERT_ID()而产生顺序，但是这样使用函数的实用程序在服务器上自动维护ID值作为最后自动产生的值。你可以检索新的ID值，就像你能读入正常MySQL中的任何正常的AUTO_INCREMENT值一样。例如，LAST_INSERT_ID()（没有一个参数 )将返回新ID。C API函数mysql_insert_id()也可被用来得到值。 FORMAT(X,D) 格式化数字X为类似于格式’#,###,###.##’，四舍五入到D为小数。如果D为0，结果将没有小数点和小数部分。 mysql&gt; select FORMAT(12332.123456, 4); -&gt; ‘12,332.1235’ mysql&gt; select FORMAT(12332.1,4); -&gt; ‘12,332.1000’ mysql&gt; select FORMAT(12332.2,0); -&gt; ‘12,332’ VERSION() 返回表明MySQL服务器版本的一个字符串。 mysql&gt; select VERSION(); -&gt; ‘3.22.19b-log’ GET_LOCK(str,timeout) 试图获得由字符串str给定的一个名字的锁定，第二个timeout为超时。如果锁定成功获得，返回1，如果尝试超时了，返回0，或如果发生一个错误，返回NULL(例如从存储器溢出或线程用mysqladmin kill被杀死)。当你执行RELEASE_LOCK()时、执行一个新的GET_LOCK()或线程终止时，一个锁定被释放。该函数可以用来实现应用锁或模拟记录锁，它阻止其他客户用同样名字的锁定请求；赞成一个给定的锁定字符串名字的客户可以使用字符串执行子协作建议的锁定。 mysql&gt; select GET_LOCK(“lock1”,10); -&gt; 1 mysql&gt; select GET_LOCK(“lock2”,10); -&gt; 1 mysql&gt; select RELEASE_LOCK(“lock2”); -&gt; 1 mysql&gt; select RELEASE_LOCK(“lock1”); -&gt; NULL 注意，第二个RELEASE_LOCK()调用返回NULL，因为锁”lock1”自动地被第二个GET_LOCK()调用释放。 RELEASE_LOCK(str) 释放字符串str命名的通过GET_LOCK()获得的锁。如果锁被释放，返回1，如果锁没被这个线程锁定(在此情况下锁没被释放)返回0，并且如果命名的锁不存在，返回NULL。如果锁从来没有通过调用GET_LOCK()获得或如果它已经被释放了，锁将不存在。 BENCHMARK(count,expr) BENCHMARK()函数重复countTimes次执行表达式expr，它可以用于计时MySQL处理表达式有多快。结果值总是0。意欲用于mysql客户，它报告查询的执行时间。 mysql&gt; select BENCHMARK(1000000,encode(“hello”,”goodbye”)); +———————————————-+ | BENCHMARK(1000000,encode(“hello”,”goodbye”)) | +———————————————-+ |                                            0 | +———————————————-+ 1 row in set (4.74 sec) 报告的时间是客户端的经过时间，不是在服务器端的CPU时间。执行BENCHMARK()若干次可能是明智的，并且注意服务器机器的负载有多重来解释结果。 与GROUP BY子句一起使用的函数 如果你在不包含GROUP BY子句的一个语句中使用聚合函数，它等价于聚合所有行。 COUNT(expr) 返回由一个SELECT语句检索出来的行的非NULL值的数目。 mysql&gt; select student.student_name,COUNT(<em>) from student,course where student.student_id=course.student_id GROUP BY student_name; COUNT(</em>)在它返回的检索出来的行数目上有些不同，不管他们是否包含NULL值。如果SELECT从一个表检索，或没有检索出其他列并且没有WHERE子句，COUNT(<em>)被优化以便快速地返回。例如： mysql&gt; select COUNT(</em>) from student; COUNT(DISTINCT expr,[expr]) 返回一个不同值的数目。 mysql&gt; select COUNT(DISTINCT results) from student; 在MySQL中，你可以通过给出一个表达式列表以得到不同的表达式组合的数目。在 ANSI SQL中，你可能必须在CODE(DISTINCT ..)内进行所有表达式的连接。 AVG(expr) 返回expr的平均值。 mysql&gt; select student_name, AVG(test_score) from student GROUP BY student_name; MIN(expr) 　 MAX(expr) 返回expr的最小或最大值。MIN()和MAX()可以有一个字符串参数；在这种的情况下，他们返回最小或最大的字符串值。 mysql&gt; select student_name, MIN(test_score), MAX(test_score) from student GROUP BY student_name; SUM(expr) 返回expr的和。注意，如果返回的集合没有行，它返回NULL！ STD(expr) 　 STDDEV(expr) 返回expr标准差(deviation)。这是对 ANSI SQL 的扩展。该函数的形式STDDEV()是提供与Oracle的兼容性。 BIT_OR(expr) 返回expr里所有位的位或。计算用 64 位(BIGINT)精度进行。 BIT_AND(expr) 返回expr里所有位的位与。计算用 64 位(BIGINT)精度进行。 MySQL扩展了GROUP BY的用法。你可以不出现在的GROUP BY部分的SELECT表达式中使用列或计算，这表示这个组的任何可能值。你可以使用它是性能更好，避免在不必要的项目上排序和分组。例如，你在下列查询中不需要在customer.name上聚合： mysql&gt; select order.custid,customer.name,max(payments) from order,customer where order.custid = customer.custid GROUP BY order.custid; 在 ANSI SQL中，你将必须将customer.name加到GROUP BY子句。在MySQL中，名字是冗余的。 如果你从GROUP BY部分省略的列在组中不是唯一的，不要使用这个功能。 在某些情况下，你可以使用MIN()和MAX()获得一个特定的列值，即使它不是唯一的。下例给出从包含sort列中最小值的行的column值： substr(MIN(concat(sort,space(6-length(sort)),column),7,length(column))) 注意，如果你正在使用MySQL 3.22(或更早)或如果你正在试图遵从ANSI SQL，你不能在GROUP BY或ORDER BY子句中使用表达式。你可以通过使用表达式的一个别名解决此限制： mysql&gt; SELECT id,FLOOR(value/100) AS val FROM tbl_name GROUP BY id,val ORDER BY val; 在MySQL3.23中，你可以这样做： mysql&gt; SELECT id,FLOOR(value/100) FROM tbl_name ORDER BY RAND(); 复制代码 学习的语句 /<strong><strong><strong>**</strong></strong></strong>字符串函数<strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>/ select insert(‘ring’,2,0,’ok’); /<em>从2的地方插入ok字符，插入时替换0个字符</em>/ select repeat(‘ring’,2); /<em>重复输出字符串2次</em>/ select REVERSE(‘ring’); /<em>反写</em>/ select mid(‘ring’,2,2);/<em>从某个位置取某个长度的字符</em>/ select instr(‘ring’,’i’);/<em>查找字符</em>/ select replace(‘very good’,’o’,’O’); /<em>替换所有的字符</em>/ select LENGTH(‘very good’); /<em>返回字符串长度</em>/ select ascii(‘abc’);/<em>返回最左边的字符ascii码</em>/ select space(3);/<em>产生3次空格</em>/ select CONCAT(‘ri’,’n’,’g’,’ wang’); /<em>组合成字符串</em>/ select lcase(‘RING’); /<em>小写</em>/ select ucase(‘ring’); /<em>转换成大写</em>/ select substring_index(user(),‘@’,1); /<em>提取当前的用户名,表示提取@左边第一出现的字符，如果后面的为负数则提取右边的字符</em>/ /<strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong>数学函数<strong><strong><strong><strong>**</strong></strong></strong></strong>/ select conv(‘ee’,16,10); /<em>将’ee’从16转换成10，16和10可以是任意进制</em>/ select bin(10); /*2进制*/ select hex(10); /*16进制*/ select oct(10); /*10进制*/ select round(12.5678,2); /<em>将小数保留两位，四舍五入</em>/ select round(123.8767); /<em>转换为整形，因为没有小数位</em>/ select char(65,66,99); /<em>将ascill码组合成字符串</em>/ select least(3,6,5,1); /<em>最小数字</em>/ select greatest(6,3,2,8,3,1);  /<em>最大数字</em>/ select power(2,3); /*2的3次幂*/ select sqrt(9); /<em>开方</em>/ select pi(); /<em>圆周率 </em>/ select RAND(11); /<em>返回0-1的随机数，指定种子，每次的数都一样</em>/ select rand();  /<em>没有指定种子，默认为时间为种子</em>/ /<strong><em>**</em></strong>日期时间函数<strong><strong><strong><strong>*</strong></strong></strong></strong>/ select now(); select to_days(‘2008-07-6’); /<em>转换成天数</em>/ select to_days(‘2008-8-8’)-to_days(now());/<em>相差的天数</em>/ select day(now());/<em>该日期中的时，分，秒，天，月，年 hour(),minute(),second(),month(),year()</em>/ select dayofyear(‘2008-2-2’); /<em>返回该年已过的天数</em>/ select monthname(now()); /<em>返回月的英文名</em>/ select dayname(now());/<em>星期几的英文名</em>/ select week(now(),0); /<em>表示当前的日期是第几周，后面的数字0表示从周日开始算，1表示从周一开始算</em>/ select from_days(734215); /<em>返回该天数表示的日期</em>/ select DATEDIFF(now(),’2008-8-8’); /<em>前面的日期减去后面的日期所得的天数</em>/ select date_add(now(),interval 2 day); /<em>表示给当前的日期加2天</em>/ select date_add(now(),interval 2 month); /<em>表示给当前的日期加2个月</em>/ select CURRENT_DATE(); /<em>当前日期，短格式</em>/ select CURRENT_TIME();/<em>当前的时间</em>/ select current_user();/<em>当前的用户</em>/ select date_format(now(),’%Y-%m-%d %H:%i:%s’);/<em>日期的格式，Y表示4位，H表示24小时制</em>/ select date_format(now(),’%T’); /<em>只显示时间，没有日期，T表示24小时制,r表示12小时制</em>/ select date_format(‘2008-08-08 14:08:08’,’%Y-%m-%d’); /<em>显示日期部分，时间不要</em>/ select date_format(now(),’%Y-%m-%d %H:%i:%s %W’); /<em>带日期的</em>/ select date_format(‘2008-8-8’,’%W’);/<em>该日期的星期几</em>/ /<strong><strong>***</strong></strong>其他函数<strong><strong><strong><em>**</em></strong></strong></strong>/ select database();/<em>返回当前的数据库名字</em>/ select substring_index(CURRENT_USER(),‘@’,1);/<em>提取当前的用户名</em>/ select password(‘123’); /*mysql的加密方式*/ select MD5(‘123’);/*32位的md5加密*/ select LAST_INSERT_ID();/<em>返回最后一次自动产生的ID值</em>/ select format(123456789.565378,4);/<em>输出123,456,789.5654有四舍五入</em>/ /<strong><strong><strong>***</strong></strong></strong>控制流函数<strong><strong><strong>*</strong></strong></strong>/ select if(1,2,3);/<em>如果第一参数为空则输入第三参数，否则输入第二个参数,后面的参数可以是字符,第一为整形</em>/ select ifnull(null,2); /<em>如果第一参数为空则输出第二个参数，否则输出第一参数</em>/ select name, case when age&lt;=20 then ‘年轻’ when age&lt;=40 then ‘壮年’ when age&lt;=50 then ‘中年’ else ‘老年’ end as ‘agestr’, date_format(adddate,’%Y-%m-%d’) as ‘adddate’ from users; /*case 语句的用法*/</d></p>

            
            <p class="more">
                <a href="/2015/12/22/2019030500073/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/22/2019030500073/" title="MySQL函数">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/16/2019030500100/">
    		MySQL数据库调优分享
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-16T03:13:15.000Z">2015-12-16</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/数据库/" title="数据库">数据库</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>日常的困扰 *<em>反映查询某个数据越来越慢，怎么办？ 数据库监控页面显示某个操作频繁执行，每次执行都非常耗时，怎么办？ 1.Sql优化 2.合理使用索引 一、sql优化—常用方法 1）not in 子查询优化 2）模糊匹配 like ‘%abc%’ 3）limit分页优化 4）count(</em>)统计数据如何加快速度 5）or条件如何优化 6）用where子句代替having子句 1、not in 子查询优化 SELECT count(<em>) FROM t_cps t1  where t1.flag&gt;=2 and  sample_md5 not in (select sample_hash from t_sfa_sample  t2 where t2.sample_hash=t1.sample_md5); -1052661行记录 33.530s SELECT count(</em>) FROM t_cps t1  where t1.flag&gt;=2 and not exists(select sample_hash from t_sfa_sample   t2 where t2.sample_hash=t1.sample_md5); -1052661行记录 18.617s SELECT count(<em>) FROM t_cps t1 left join t_sfa_sample t2 on t1.sample_md5=t2.sample_hash where t1.flag&gt;=2  and t2.sample_hash is null; -1052661行记录 14.544s 生产环境中，尽量避免使用子查询，可用表连接join代替。可避免mysql在内存中创建临时表 in和exists SELECT count(</em>) FROM t_cps t1  where t1.flag&gt;=2 and  sample_md5  in (select sample_hash  from t_sfa_sample   t2 where t2.sample_hash=t1.sample_md5); 1227992行记录 30.762s SELECT count(<em>) FROM t_cps t1  where t1.flag&gt;=2 and  exists (select sample_hash from t_sfa_sample   t2 where t2.sample_hash=t1.sample_md5); 1227992行记录 15.581s in和exists执行时: in是先执行子查询中的查询，然后再执行主查询。 exists是先执行主查询，即外层表的查询，然后再执行子查询 exists 和 in 在执行时效率单从执行时间来说差不多，exists要稍微优于in。在使用时一般应该是用exists而不用in 而在not in 和 not exists比较时，not exists的效率要比not in的效率要高。 但也有少数时候并非如此。 建议是尽量多使用exists和not exists，少用in 和not in 2、模糊匹配 like ‘%abc%’ mysql&gt; explain select </em> from update_log_test where msg like ‘e%’; +—-+————-+—————–+——-+—————+———+———+——+——+———————–+ | id | select_type | table           | type  | possible_keys | key     | key_len | ref  | rows | Extra                 | +—-+————-+—————–+——-+—————+———+———+——+——+———————–+ |  1 | SIMPLE      | update_log_test | range | idx_msg       | idx_msg | 768     | NULL |    1 | Using index condition | +—-+————-+—————–+——-+—————+———+———+——+——+———————–+ 1 row in set (0.00 sec) mysql&gt; explain select <em> from update_log_test where msg like ‘%e%’; +—-+————-+—————–+——+—————+——+———+——+——+————-+ | id | select_type | table           | type | possible_keys | key  | key_len | ref  | rows | Extra       | +—-+————-+—————–+——+—————+——+———+——+——+————-+ |  1 | SIMPLE      | update_log_test | ALL  | NULL          | NULL | NULL    | NULL |    4 | Using where | +—-+————-+—————–+——+—————+——+———+——+——+————-+ 1 row in set (0.00 sec) like ‘abc%’可以用到索引，但like‘%abc%’却不行。 SELECT </em> FROM books  WHERE name like “MySQL%” ; 但是如果换用下面的查询，返回的结果一样，但速度就要快上很多： SELECT <em> FROM books  WHERE name&gt;=”MySQL”and name&lt;”MySQM” ; 补充：explain列的解释 table  显示这一行的数据是关于哪张表的 type   这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL possible_keys  显示可能应用在这张表中的索引。如果为空，没有可能的索引。 key 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引 key_len  使用的索引的长度。在不损失精确性的情况下，长度越短越好 ref     显示索引的哪一列被使用了，显示了哪些字段或者常量被用来和 key配合从表中查询记录出来。 rows   MYSQL认为必须检查的用来返回请求数据的行数 Extra  关于MYSQL如何解析查询的额外信息。这里可以看到的坏的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，检索会很慢 type不同连接类型的解释（按照效率高低的顺序排序） const   索引可以是主键或惟一索引，因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待 mysql&gt; explain select </em> from update_log_20141111 where id=2; +—-+————-+———————+——-+—————+———+———+——-+——+——-+ | id | select_type | table               | type  | possible_keys | key     | key_len | ref   | rows | Extra | +—-+————-+———————+——-+—————+———+———+——-+——+——-+ |  1 | SIMPLE      | update_log_20141111 | const | PRIMARY       | PRIMARY | 4       | const |    1 | NULL  | +—-+————-+———————+——-+—————+———+———+——-+——+——-+ eq_ref     从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用 mysql&gt; explain select <em> from t1,t2 where t1.id=t2.id; +—-+————-+——-+——–+—————+———+———+————+——+——-+ | id | select_type | table | type   | possible_keys | key     | key_len | ref        | rows | Extra | +—-+————-+——-+——–+—————+———+———+————+——+——-+ |  1 | SIMPLE      | t2    | ALL    | PRIMARY       | NULL    | NULL    | NULL       |    9 | NULL  | |  1 | SIMPLE      | t1    | eq_ref | PRIMARY       | PRIMARY | 4       | test.t2.id |    1 | NULL  | +—-+————-+——-+——–+—————+———+———+————+——+——-+ 2 rows in set (0.00 sec) ref      只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好 mysql&gt; explain select </em> from update_log_20141110 t1,update_log_test t2 where t1.action=t2.action; +—-+————-+——-+——+—————+———-+———+—————-+——+————-+ | id | select_type | table | type | possible_keys | key      | key_len | ref            | rows | Extra       | +—-+————-+——-+——+—————+———-+———+—————-+——+————-+ |  1 | SIMPLE      | t1    | ALL  | i_action      | NULL     | NULL    | NULL           |    2 | Using where | |  1 | SIMPLE      | t2    | ref  | i_action      | i_action | 2       | test.t1.action |    1 | NULL        | +—-+————-+——-+——+—————+———-+———+—————-+——+————-+ 2 rows in set (0.00 sec) range   返回一个范围中的行，比如使用&gt;或&lt;查找东西时 mysql&gt; explain select <em> from t1 where id&gt;=9900 order by id limit 10; +—-+————-+——-+——-+—————+———+———+——+——+————-+ | id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       | +—-+————-+——-+——-+—————+———+———+——+——+————-+ |  1 | SIMPLE      | t1    | range | PRIMARY       | PRIMARY | 4       | NULL |  101 | Using where | +—-+————-+——-+——-+—————+———+———+——+——+————-+ 1 row in set (0.00 sec) index   对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据） ALL      对每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免 Extra 列返回的描述的意义 Distinct  一旦MYSQL找到了与行相联合匹配的行，就不再搜索了 Not exists  MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索 Record（index map:#）没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一 Using filesort   看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行 Using index  列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候 Using temporary 看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上 Using where 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题 3、limit分页优化 Select  </em> from t1 order by id limit 9900,10; 上面的语句，虽然用到了id索引，但是从第一行开始起定位至9900行，然后再扫描后10行，相当于进行了一次全扫描，显然效率不高。 Select <em> from t1 where id&gt;=9900 order by id limit 10; 利用id索引直接定位到9900行，然后在扫描出后10行，相当于一个range范围扫描 mysql&gt; explain select  </em> from t1 order by id limit 9900,10; +—-+————-+——-+——-+—————+———+———+——+——+——-+ | id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra | +—-+————-+——-+——-+—————+———+———+——+——+——-+ |  1 | SIMPLE      | t1    | index | NULL          | PRIMARY | 4       | NULL | 9910 | NULL  | +—-+————-+——-+——-+—————+———+———+——+——+——-+ 1 row in set (0.00 sec) mysql&gt; explain select <em> from t1 where id&gt;=9900 order by id limit 10; +—-+————-+——-+——-+—————+———+———+——+——+————-+ | id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       | +—-+————-+——-+——-+—————+———+———+——+——+————-+ |  1 | SIMPLE      | t1    | range | PRIMARY       | PRIMARY | 4       | NULL |  101 | Using where | +—-+————-+——-+——-+—————+———+———+——+——+————-+ 1 row in set (0.00 sec) 4、count(</em>)统计数据如何加快速度 select count(<em>)  from update_log; select count(</em>)  from update_log  where sid&gt;=0; 利用辅助索引 select count(distinct k) from t; select count(<em>) from (select distinct k from t) tmp;  利用索引来做排重操作。 注意：innodb count（</em>）必须全表扫，而不像myisam那样有一个计数器，直接从中取出数据。Innodb必须要全表扫一次才能得到count，而且会锁表。 5、or条件如何优化 select <em> from user where name=’d’ or age=31; name和age都建立了索引，但explain发现这个or条件用不到索引。 改成union all结果集合并 select </em> from user where name=’d’ union all select <em> from user where age=31; 6、用where子句代替having子句 select </em> from user group by id having id&gt;40 limit 3; select <em> from user where id&gt;40 group by id limit 3; having只会在检索出所有记录之后才对结果集进行过滤。这个处理需要排序、总计等操作。 如果能通过where子句限制记录的数目，那就能减少这方面的开销。 SQL优化的一般步骤 1、通过 show status 命令了解各种SQL的执行频率 show status like ‘uptime’ 当前MySQL运行时间 show status like ‘com_select’ 当前MySQL执行了多少次查询 show status like ‘com_insert’ 当前MySQL执行了多少次添加 show status like ‘com_update’ 当前MySQL执行了多少次更新 show status like ‘com_delete’ 当前MySQL执行了多少次删除 show status 语法： show [session|global] status like ‘’; 如果不写 [session|global] 表示默认是 session 指取出当前窗口的执行情况 如果想看所有(mysql启动到现在)的情况 加上 global show global status like ‘com_insert’; 2、 定位执行效率较低的SQL语句 （重点select） 3、通过 explain 分析低效率的SQL语句的执行情况 4、确定问题并采取相应的优化措施 二、合理使用索引 使用索引，why? 单列索引和联合索引 字段使用函数，将不能走索引 当取出的数据量超过表中数据的20%，索引是否有效？ order by 和group by优化 全文索引 1、适当的索引对应用的性能来说至关重要。 2、索引只对select有加速作用，但对写入（insert,update、delete）操作会带来额外的开销，如果带有一个或多个索引，那么数据更新的时候，mysql也要更新各个索引。 3、并不是所有经常查询的列都适合创建索引，区分度不高的，通常走全表扫浏览会更快。例如性别，只有男女两种，就不适合。 4、一条sql只能用一个索引，如果有多个，优化器会选择最优的。 1、单列索引和联合索引 mysql&gt; create index i_s_time on update_log(server,time); 联合索引要遵循最左侧原则 mysql&gt; explain select </em> from update_log where server=’115.29.138.24’ and time=’13:00:00’; +—-+————-+————+——+—————–+———-+———+————-+——+———————–+ | id | select_type | table      | type | possible_keys   | key      | key_len | ref         | rows | Extra                 | +—-+————-+————+——+—————–+———-+———+————-+——+———————–+ |  1 | SIMPLE      | update_log | ref  | i_time,i_s_time | i_s_time | 50      | const,const |    7 | Using index condition | +—-+————-+————+——+—————–+———-+———+————-+——+———————–+ 1 row in set (0.00 sec) mysql&gt; explain select <em> from update_log where server=’115.29.138.24’; +—-+————-+————+——+—————+———-+———+——-+———+———————–+ | id | select_type | table      | type | possible_keys | key      | key_len | ref   | rows    | Extra                 | +—-+————-+————+——+—————+———-+———+——-+———+———————–+ |  1 | SIMPLE      | update_log | ref  | i_s_time      | i_s_time | 46      | const | 2653264 | Using index condition | +—-+————-+————+——+—————+———-+———+——-+———+———————–+ 1 row in set (0.00 sec) mysql&gt; explain select </em> from update_log where server=’115.29.138.24’ and client=’14.197.74.21’ and time=’13:00:00’; +—-+————-+————+——+—————–+———-+———+————-+——+————————————+ | id | select_type | table      | type | possible_keys   | key      | key_len | ref         | rows | Extra                              | +—-+————-+————+——+—————–+———-+———+————-+——+————————————+ |  1 | SIMPLE      | update_log | ref  | i_time,i_s_time | i_s_time | 50      | const,const |    7 | Using index condition; Using where | +—-+————-+————+——+—————–+———-+———+————-+——+————————————+ 1 row in set (0.00 sec) mysql&gt; explain select <em> from update_log where  time=’13:00:00’; +—-+————-+————+——+—————+——+———+——+———-+————-+ | id | select_type | table      | type | possible_keys | key  | key_len | ref  | rows     | Extra       | +—-+————-+————+——+—————+——+———+——+———-+————-+ |  1 | SIMPLE      | update_log | ALL  | NULL          | NULL | NULL    | NULL | 21615394 | Using where | +—-+————-+————+——+—————+——+———+——+———-+————-+ 1 row in set (0.00 sec) 2、字段使用函数，将不能走索引 –mysql目前还不支持函数索引 mysql&gt; explain select </em> from update_log where year(date)&lt;2014; +—-+————-+————+——+—————+——+———+——+———-+————-+ | id | select_type | table      | type | possible_keys | key  | key_len | ref  | rows     | Extra       | +—-+————-+————+——+—————+——+———+——+———-+————-+ |  1 | SIMPLE      | update_log | ALL  | NULL          | NULL | NULL    | NULL | 21615394 | Using where | +—-+————-+————+——+—————+——+———+——+———-+————-+ 1 row in set (0.00 sec) 在where后面的查询条件字段使用了date()函数，是不会用到索引的。 mysql&gt; explain select <em> from update_log where date&lt;’2014-01-01’; +—-+————-+————+——-+—————+——+———+——+——+———————–+ | id | select_type | table      | type  | possible_keys | key  | key_len | ref  | rows | Extra                 | +—-+————-+————+——-+—————+——+———+——+——+———————–+ |  1 | SIMPLE      | update_log | range | date          | date | 4       | NULL |    1 | Using index condition | +—-+————-+————+——-+—————+——+———+——+——+———————–+ 1 row in set (0.00 sec) 同样的情形也会发生在对数值型字段进行计算的时候： SELECT </em> FROM t1  WHERE Amount/7&lt;24; SELECT <em> FROM t1  WHERE Amount&lt;24\</em>7; 3、无引号导致全表扫描，无法使用索引 mysql&gt; explain select * from update_log_test where msg=123; +—-+————-+—————–+——+—————+——+———+——+——+————-+ | id | select_type | table           | type | possible_keys | key  | key_len | ref  | rows | Extra       | +—-+————-+—————–+——+—————+——+———+——+——+————-+ |  1 | SIMPLE      | update_log_test | ALL  | i_msg         | NULL | NULL    | NULL |    4 | Using where | +—-+————-+—————–+——+—————+——+———+——+——+————-+ 1 row in set (0.00 sec) mysql&gt; explain select <em> from update_log_test where msg=’yoyo’; +—-+————-+—————–+——+—————+——-+———+——-+——+———————–+ | id | select_type | table           | type | possible_keys | key   | key_len | ref   | rows | Extra                 | +—-+————-+—————–+——+—————+——-+———+——-+——+———————–+ |  1 | SIMPLE      | update_log_test | ref  | i_msg         | i_msg | 768     | const |    1 | Using index condition | +—-+————-+—————–+——+—————+——-+———+——-+——+———————–+ 由于msg是varchar类型，因此查询的时候，必须加‘’ 数字当字符类型使用时，也一定要加上。 4、当取出的数据量超过表中数据的20%，优化器认为全表扫更快，不会走索引 mysql&gt; explain select </em> from update_log where time&lt;’14:00:00’; +—-+————-+————+——+—————+——+———+——+———-+————-+ | id | select_type | table      | type | possible_keys | key  | key_len | ref  | rows     | Extra       | +—-+————-+————+——+—————+——+———+——+———-+————-+ |  1 | SIMPLE      | update_log | ALL  | i_time        | NULL | NULL    | NULL | 21615394 | Using where | +—-+————-+————+——+—————+——+———+——+———-+————-+ 1 row in set (0.00 sec) mysql&gt; explain select <em> from update_log where time&lt;’14:00:00’ and time&gt;’13:00:00’; +—-+————-+————+——-+—————+——–+———+——+———+———————–+ | id | select_type | table      | type  | possible_keys | key    | key_len | ref  | rows    | Extra                 | +—-+————-+————+——-+—————+——–+———+——+———+———————–+ |  1 | SIMPLE      | update_log | range | i_time        | i_time | 4       | NULL | 3013332 | Using index condition | +—-+————-+————+——-+—————+——–+———+——+———+———————–+ 1 row in set (0.00 sec) 5、order by 和group by优化 mysql&gt; explain select </em> from update_log where server=’115.29.138.24’ order by time; +—-+————-+————+——+—————+——+———+——+———-+—————————–+ | id | select_type | table      | type | possible_keys | key  | key_len | ref  | rows     | Extra                       | +—-+————-+————+——+—————+——+———+——+———-+—————————–+ |  1 | SIMPLE      | update_log | ALL  | NULL          | NULL | NULL    | NULL | 21615394 | Using where; Using filesort | +—-+————-+————+——+—————+——+———+——+———-+—————————–+ 1 row in set (0.00 sec) 创建联合索引 mysql&gt; create index i_s_time on update_log(server,time); Query OK, 0 rows affected (3 min 18.94 sec) Records: 0  Duplicates: 0  Warnings: 0 mysql&gt; explain select <em> from update_log where server=’115.29.138.24’ order by time; +—-+————-+————+——+—————+———-+———+——-+———+————————————+ | id | select_type | table      | type | possible_keys | key      | key_len | ref   | rows    | Extra                              | +—-+————-+————+——+—————+———-+———+——-+———+————————————+ |  1 | SIMPLE      | update_log | ref  | i_s_time      | i_s_time | 46      | const | 2653264 | Using index condition; Using where | +—-+————-+————+——+—————+———-+———+——-+———+————————————+ 1 row in set (0.01 sec) 如果order by 后面有多个字段排序，它们的顺序要一致，如果一个是降序，一个是升序，也会出现using filesort排序。 6、全文索引 全文索引：主要是针对文件，文本的索引，比如文章(5.6开始innodb也支持） 字段类型：char、varchar、text 全文搜索通过 MATCH() 函数完成. mysql&gt; create table articles( -&gt; id int unsigned auto_increment not null primary key, -&gt; title varchar(200), -&gt; body text, -&gt; fulltext(title,body)); Query OK, 0 rows affected (0.05 sec) mysql&gt; INSERT INTO articles VALUES -&gt; (NULL,’MySQL Tutorial’, ‘DBMS stands for DataBase …’), -&gt;  (NULL,’How To Use MySQL Efficiently’, ‘After you went through a …’), -&gt; (NULL,’Optimising MySQL’,’In this tutorial we will show …’), -&gt; (NULL,’1001 MySQL Tricks’,’1. Never run mysqld as root. 2. …’), -&gt; (NULL,’MySQL vs. YourSQL’, ‘In the following database comparison …’), -&gt; (NULL,’MySQL Security’, ‘When configured properly, MySQL …’); Query OK, 6 rows affected (0.01 sec) Records: 6  Duplicates: 0  Warnings: 0 mysql&gt; explain select </em> from articles where match(title,body) against(‘database’); +—-+————-+———-+———-+—————+——-+———+——+——+————-+ | id | select_type | table    | type     | possible_keys | key   | key_len | ref  | rows | Extra       | +—-+————-+———-+———-+—————+——-+———+——+——+————-+ |  1 | SIMPLE      | articles | fulltext | title         | title | 0       | NULL |    1 | Using where | +—-+————-+———-+———-+—————+——-+———+——+——+————-+ 1 row in set (0.00 sec) 但如果某个单词单词出现在至少全文的50%的行中，它会被列入停止字。对于大型数据集，使用这个操作最合适不过了—-一个自然语言问询不会从一个1GB 的表每隔一行返回一次。对于小型数据集，它的用处可能比较小。不是大型的数据量，就不要用他，影响插入速度 7、mysql 5.6支持explain update/delete mysql&gt; explain update update_log_test set msg=’gugu’ where id=4; +—-+————-+—————–+——-+—————+———+———+——-+——+————-+ | id | select_type | table           | type  | possible_keys | key     | key_len | ref   | rows | Extra       | +—-+————-+—————–+——-+—————+———+———+——-+——+————-+ |  1 | SIMPLE      | update_log_test | range | PRIMARY       | PRIMARY | 4       | const |    1 | Using where | +—-+————-+—————–+——-+—————+———+———+——-+——+————-+ 1 row in set (0.01 sec) mysql&gt; explain delete from update_log_test  where id=4; +—-+————-+—————–+——-+—————+———+———+——-+——+————-+ | id | select_type | table           | type  | possible_keys | key     | key_len | ref   | rows | Extra       | +—-+————-+—————–+——-+—————+———+———+——-+——+————-+ |  1 | SIMPLE      | update_log_test | range | PRIMARY       | PRIMARY | 4       | const |    1 | Using where | +—-+————-+—————–+——-+—————+———+———+——-+——+————-+ 1 row in set (0.00 sec) 8、mysql5.6优化了合并索引 mysql&gt; explain select <em> from update_log where date=’2014-11-12’ or time=’14:00:00’; +—-+————-+————+————-+—————+————-+———+——+———-+—————————————+ | id | select_type | table      | type        | possible_keys | key         | key_len | ref  | rows     | Extra                                 | +—-+————-+————+————-+—————+————-+———+——+———-+—————————————+ |  1 | SIMPLE      | update_log | index_merge | date,i_time   | date,i_time | 4,4     | NULL | 10808103 | Using union(date,i_time); Using where | +—-+————-+————+————-+—————+————-+———+——+———-+—————————————+ 1 row in set (0.01 sec) mysql&gt; explain select </em> from update_log where date=’2014-11-12’ union select * from update_log where time=’14:00:00’; +—-+————–+————+——+—————+——–+———+——-+———-+———————–+ | id | select_type  | table      | type | possible_keys | key    | key_len | ref   | rows     | Extra                 | +—-+————–+————+——+—————+——–+———+——-+———-+———————–+ |  1 | PRIMARY      | update_log | ref  | date          | date   | 4       | const | 10807697 | NULL                  | |  2 | UNION        | update_log | ref  | i_time        | i_time | 4       | const |      406 | Using index condition | | NULL | UNION RESULT | &lt;union1,2&gt; | ALL  | NULL          | NULL   | NULL    | NULL  |     NULL | Using temporary       | +—-+————–+————+——+—————+——–+———+——-+———-+———————–+ 3 rows in set (0.00 sec) 实际测试2条sql，or的执行时间是union执行时间的两倍。 1、union all 不一定就比 or及in 快，要结合实际情况分析到底使用哪种情况。 2、对于索引列来最好使用union all，因复杂的查询【包含运算等】将使or、in放弃索引而全表扫描，除非你能确定or、in会使用索引。 3、对于只有非索引字段来说你就老老实实的用or 或者in，因为 非索引字段本来要全表扫描而union all 只成倍增加表扫描的次数。 Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；Union All：对两个结果集进行并集操作，包括重复行，不进行排序； union因为要进行重复值扫描，所以效率低。</p>

            
            <p class="more">
                <a href="/2015/12/16/2019030500100/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/16/2019030500100/" title="MySQL数据库调优分享">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/6.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/07/2019030500107/">
    		mysql集群
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-07T04:35:02.000Z">2015-12-07</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/集群/" title="集群">集群</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>五台服务器篇 安装要求 安装环境：CentOS-6.3 安装方式：源码编译安装 软件名称：mysql-cluster-gpl-7.2.6-linux2.6-x86_64.tar.gz 下载地址：<a href="http://mysql.mirror.kangaroot.net/Downloads/" target="_blank" rel="noopener">http://mysql.mirror.kangaroot.net/Downloads/</a> 软件安装位置：/usr/local/mysql 数据存放位置：/var/mysql/data 日志存放位置：/var/mysql/logs 集群设计 首先设计集群的安装分配方式，我共需要5台服务器，服务器分配如下： 管理节点：    192.168.15.231 sql节点1：   192.168.15.232 sql节点2：   192.168.15.233 数据节点1：  192.168.15.234 数据节点2：  192.168.15.235 设备的连接方式如下图所示： 注意：目前这种设计存在的问题是管理节点是单点的，231挂掉后整个集群就会瘫痪，先不管这个问题，首先把这个简单的MySQL集群先搭建起来。 检查安装的mysql 检查系统中已经安装过的mysql信息，操作如下： [root@localhost /]# rpm -qa | grep mysql [root@localhost /]# service mysql status 如果安装过其他版本的mysql，请卸载，操作如下： [root@localhost /]# /etc/init.d/mysqld    stop  //关闭目前的mysql服务 [root@localhost /]# ps    -ef | grep mysql  //检验mysql是否已经关闭 #如果没关闭，执行kill -9 端口号 #执行删除 rpm -e –allmatches    –nodeps mysql mysql-server rm -rf /var/lib/mysql  // 删除mysql的安装目录 管理节点 管理节点安装 安装管理节点（192.168.15.231） [root@localhost /]#    groupadd mysql [root@localhost /]#  useradd mysql -g mysql [root@localhost /]# cd    /usr/local [root@localhost local]#    tar -zxv -f mysql-cluster-gpl-7.2.6-linux2.6-x86_64.tar.gz [root@localhost local]#    mv mysql-cluster-gpl-7.2.6-linux2.6-x86_64 mysql [root@localhost local]#    chown -R mysql:mysql mysql [root@localhost local]#    cd mysql [root@localhost mysql]#    scripts/mysql_install_db –user=mysql 管理节点配置 [root@localhost ~]#  mkdir /var/lib/mysql-cluster [root@localhost ~]# cd    /var/lib/mysql-cluster [root@localhost mysql-cluster]#    vi + /var/lib/mysql-cluster/config.ini 在config.ini 中添加以下内容: [NDBD DEFAULT] NoOfReplicas=1 [TCP DEFAULT] portnumber=3306 [NDB_MGMD] #设置管理节点服务器 HostName=192.168.15.231 DataDir=/var/mysql/data [NDBD] #设置存储节点服务器(NDB节点) HostName=192.168.15.234 DataDir=/var/mysql/data [NDBD] #第二个NDB节点 HostName=192.168.15.235 DataDir=/var/mysql/data [MYSQLD] #设置SQL节点服务器 HostName=192.168.15.232 [MYSQLD] #第二个SQL节点 HostName=192.168.15.233 管理节点启动 [root@localhost ~]#/usr/local/mysql/bin/ndb_mgmd -f /var/lib/mysql-cluster/config.ini [root@localhost ~]# mkdir  /var/mysql/logs [root@localhost ~]# netstat -lntpu 看到tcp 0 0 0.0.0.0:1186开放说明启动正常 开启管理节点服务器的1186端口 管理节点检验 执行以下操作： [root@localhost /]# ndb_mgm     // 管理节点 – NDB Cluster – Management Client – ndb_mgm&gt; show Connected to Management Server at:    localhost:1186 Cluster Configuration ——————— [ndbd(NDB)]        2 node(s) id=2 (not connected, accepting connect from    192.168.15.234) id=3 (not connected, accepting connect from    192.168.15.235) [ndb_mgmd(MGM)] 1 node(s) id=1       @192.168.15.231  (mysql-5.5.22    ndb-7.2.6) [mysqld(API)]      2 node(s) id=4 (not connected, accepting connect from    192.168.15.232) id=5 (not connected, accepting connect from    192.168.15.233) 管理节点关闭 [root@localhost /]#    /usr/local/mysql/bin/ndb_mgm -e shutdown #成功后终端打印出以下信息 Connected to Management    Server at: 192.168.15.236:1186 3 NDB Cluster node(s)    have shutdown. Disconnecting to allow    management server to shutdown. 数据节点 数据节点安装 数据节点1： 192.168.15.234 数据节点2： 192.168.15.235 [root@localhost /]#    groupadd mysql [root@localhost /]#    useradd mysql -g mysql [root@localhost /]# cd    /usr/local [root@localhost local]#    tar -zxv -f mysql-cluster-gpl-7.2.6-linux2.6-x86_64.tar.gz [root@localhost local]#    mv mysql-cluster-gpl-7.2.6-linux2.6-x86_64 mysql [root@localhost local]#    chown -R mysql:mysql mysql [root@localhost local]#    cd mysql [root@localhost mysql]#    scripts/mysql_install_db –user=mysql [root@localhost mysql]#    cp support-files/my-medium.cnf /etc/my.cnf [root@localhost mysql]#    cp support-files/mysql.server /etc/init.d/mysqld 数据节点配置 对数据节点进行配置，执行以下操作： [root@localhost mysql]#    mkdir /var/mysql/data [root@localhost mysql]#    mkdir /var/mysql/logs [root@localhost mysql]#    vi /etc/my.cnf 向文件追加以下内容： [MYSQLD] ndbcluster ndb-connectstring=192.168.15.231 [MYSQL_CLUSTER] ndb-connectstring=192.168.15.231 [NDB_MGM] connect-string=192.168.15.231 数据节点启动 启动此处时，管理节点服务器防火墙必须开启1186,3306端口。 注意：只是在第一次启动或在备份／恢复或配置变化后重启ndbd时，才加–initial参数！ 第一次启动如下： [root@localhost mysql]#/usr/local/mysql/bin/ndbd –initial 2013-01-30 13:43:53    [ndbd] INFO     – Angel connected to    ‘192.168.15.231:1186’ 2013-01-30 13:43:53    [ndbd] INFO     – Angel allocated    nodeid: 2 正常启动方式： [root@localhost mysql]# /usr/local/mysql/bin/ndbd 数据节点关闭 [root@localhost /]# /etc/rc.d/init.d/mysqld stop 或者 [root@localhost mysql]# /etc/init.d/mysql stop Shutting down MySQL.. SUCCESS! /usr/local/mysql/bin/mysqladmin -uroot shutdown SQL节点安装 SQL节点安装 SQL节点和存储节点(NDB节点)安装相同，都执行以下操作； sql节点1： 192.168.15.232 sql节点2： 192.168.15.233 [root@localhost /]#    groupadd mysql [root@localhost /]#    useradd mysql -g mysql [root@localhost /]# cd    /usr/local [root@localhost local]#    tar -zxv -f mysql-cluster-gpl-7.2.6-linux2.6-x86_64.tar.gz [root@localhost local]#    mv mysql-cluster-gpl-7.2.6-linux2.6-x86_64 mysql [root@localhost local]# chown    -R mysql:mysql mysql [root@localhost local]#    cd mysql [root@localhost mysql]#    scripts/mysql_install_db –user=mysql [root@localhost mysql]#    cp support-files/my-medium.cnf /etc/my.cnf [root@localhost mysql]#    cp support-files/mysql.server /etc/init.d/mysqld SQL节点配置 执行以下操作： [root@localhost mysql]#    mkdir /var/mysql/data     //创建存储数据的文件夹 [root@localhost mysql]#    mkdir /var/mysql/logs     //创建存储日志的文件夹 [root@localhost mysql]#    vi /usr/local/mysql/my.cnf  //修改配置文件 追加以下内容： [MYSQLD] ndbcluster ndb-connectstring=192.168.15.231 [MYSQL_CLUSTER] ndb-connectstring=192.168.15.231 [NDB_MGM] connect-string=192.168.15.231 SQL节点启动 执行以下操作： [root@localhost    mysql]# service mysqld start Starting    MySQL.. SUCCESS! SQL节点关闭 最直接的方式： [root@localhost mysql]# /usr/local/mysql/bin/mysqladmin    -uroot shutdown [root@localhost /]# /etc/rc.d/init.d/mysqld stop 或者 [root@localhost mysql]# /etc/init.d/mysql stop Shutting down MySQL.. SUCCESS! 功能测试 在管理节点（192.168.15.231）上查看服务状态 [root@localhost ~]#    /usr/local/mysql/bin/ndb_mgm – NDB Cluster – Management Client – ndb_mgm&gt; show Cluster Configuration ——————— [ndbd(NDB)]        2 node(s) id=2       @192.168.15.234  (mysql-5.5.22    ndb-7.2.6, Nodegroup: 0, Master) id=3       @192.168.15.235  (mysql-5.5.22    ndb-7.2.6, Nodegroup: 1) [ndb_mgmd(MGM)] 1 node(s) id=1       @192.168.15.231  (mysql-5.5.22    ndb-7.2.6) [mysqld(API)]      2 node(s) id=4       @192.168.15.232  (mysql-5.5.22    ndb-7.2.6) id=5       @192.168.15.233  (mysql-5.5.22    ndb-7.2.6) 可以看到这里的数据节点、管理节点、sql节点都是正常的。 注意： 在建表的时候一定要用ENGINE=NDB或ENGINE=NDBCLUSTER指定使用NDB集群存储引擎，或用ALTER TABLE选项更改表的存储引擎。 NDB表必须有一个主键，因此创建表的时候必须定义主键，否则NDB存储引擎将自动生成隐含的主键。 Sql节点的用户权限表仍然采用MYISAM存储引擎保存的，所以在一个Sql节点创建的MySql用户只能访问这个节点，如果要用同样的用户访 问别的Sql节点，需要在对应的Sql节点追加用户。虽然在MySql Cluster7.2版本开始提供了”用户权限共享”。 数据同步性测试 在一个数据节点上进行相关数据库的创建，然后到另外一个数据节点上看看数据是否同步。 第1步： SQL节点1（192.168.15.232）上增加数据： [root@localhost    mysql]#  /etc/rc.d/init.d/mysqld status                //检验mysql是否运行 [root@localhost mysql]#    /etc/rc.d/init.d/mysqld start                   //启动mysql [root@localhost mysql]#    /usr/local/mysql/bin/mysql -u root -p Enter password: mysql&gt; show databases; mysql&gt; create database    testdb2; mysql&gt; use testdb2; mysql&gt; CREATE TABLE    td_test2 (i INT) ENGINE=NDB; //这里必须指定数据库表的引擎为NDBCLUSTER，与配置文件中的名称相同 mysql&gt; INSERT INTO    td_test2() VALUES (1); mysql&gt; INSERT INTO    td_test2() VALUES (152); mysql&gt; SELECT <em> FROM    td_test2; 第2步： 进入到SQL节点2（192.168.15.233）上查看数据 mysql&gt; use testdb2; Database changed mysql&gt; SELECT </em> FROM td_test2; +——+ | i    | +——+ |  126 | |    1 | +——+ 2 rows in set (0.01 sec) 查看表的引擎是不是NDB： &gt;show create table td_test2; 第3步： 反向测试，SQL节点2（192.168.15.233）上增加数据： mysql&gt; create database    bb; mysql&gt; use bb; mysql&gt; CREATE TABLE    td_test3 (i INT) ENGINE=NDB; mysql&gt; INSERT INTO    td_test3 () VALUES (98); mysql&gt; SELECT <em> FROM    td_test3; SQL节点1（192.168.15.232）上查看数据： mysql&gt;  use bb; Database changed mysql&gt;  SELECT </em> FROM td_test3; +——+ | i    | +——+ |   98 | +——+ 1 row in set (0.00 sec) 关闭集群 先关闭管理节点，然后关闭SQL节点和数据节点。 集群启动操作顺序 要再次启动集群，按照以下顺序执行： 管理节点 -&gt; 数据节点 –&gt; SQL节点注意：此次启动数据节点时不要加”–initial”参数。 安装及测试中的错误 启动中的错误 错误提示： Can’t connect to local MySQL server through socket ‘/tmp/mysql.sock’ (2) 解决办法1（端口占用） netstat -anp |grep 3306 kill -9 进程号 解决办法1（权限问题） [root@localhost mysql]# chown -R mysql:mysql /var/mysql          //修改自定义文件夹的访问权限 三台服务器篇 一、介绍 ======== 这篇文档旨在介绍如何安装配置基于2台服务器的MySQL集群。并且实现任意一台服务器出现问题或宕机时MySQL依然能够继续运行。 注意！ 虽 然这是基于2台服务器的MySQL集群，但也必须有额外的第三台服务器作为管理节点，但这台服务器可以在集群启动完成后关闭。同时需要注意的是 并不推荐在集群启动完成后关闭作为管理节点的服务器。尽管理论上可以建立基于只有2台服务器的MySQL集群，但是这样的架构，一旦一台服务器宕机之后集 群就无法继续正常工作了，这样也就失去了集群的意义了。出于这个原因，就需要有第三台服务器作为管理节点运行。 另外，可能很多朋友都没有3台服务器的实际环境，可以考虑在VMWare或其他虚拟机中进行实验。 下面假设这3台服务的情况： Server1: mysql1.vmtest.net 192.168.0.1 Server2: mysql2.vmtest.net 192.168.0.2 Server3: mysql3.vmtest.net 192.168.0.3 Servers1 和Server2作为实际配置MySQL集群的服务器。对于作为管理节点的Server3则要求较低，只需对Server3的系 统进行很小的调整并且无需安装MySQL，Server3可以使用一台配置较低的计算机并且可以在Server3同时运行其他服务。 二、在Server1和Server2上安装MySQL ================================= 从<a href="http://www.mysql.com上下载mysql-max-4.1.9-pc-linux-gnu-i686.tar.gz" target="_blank" rel="noopener">http://www.mysql.com上下载mysql-max-4.1.9-pc-linux-gnu-i686.tar.gz</a> 注意：必须是max版本的MySQL，Standard版本不支持集群部署！ 以下步骤需要在Server1和Server2上各做一次 # mv mysql-max-4.1.9-pc-linux-gnu-i686.tar.gz /usr/local/ # cd /usr/local/ # groupadd mysql # useradd -g mysql mysql # tar -zxvf mysql-max-4.1.9-pc-linux-gnu-i686.tar.gz # rm -f mysql-max-4.1.9-pc-linux-gnu-i686.tar.gz # mv mysql-max-4.1.9-pc-linux-gnu-i686 mysql # cd mysql # scripts/mysql_install_db –user=mysql # chown -R root  . # chown -R mysql data # chgrp -R mysql . # cp support-files/mysql.server /etc/rc.d/init.d/mysqld # chmod +x /etc/rc.d/init.d/mysqld # chkconfig –add mysqld 此时不要启动MySQL！ 三、安装并配置管理节点服务器(Server3) ===================================== 作为管理节点服务器，Server3需要ndb_mgm和ndb_mgmd两个文件： 从<a href="http://www.mysql.com上下载mysql-max-4.1.9-pc-linux-gnu-i686.tar.gz" target="_blank" rel="noopener">http://www.mysql.com上下载mysql-max-4.1.9-pc-linux-gnu-i686.tar.gz</a> # mkdir /usr/src/mysql-mgm # cd /usr/src/mysql-mgm # tar -zxvf mysql-max-4.1.9-pc-linux-gnu-i686.tar.gz # rm mysql-max-4.1.9-pc-linux-gnu-i686.tar.gz # cd mysql-max-4.1.9-pc-linux-gnu-i686 # mv bin/ndb_mgm . # mv bin/ndb_mgmd . # chmod +x ndb_mg<em> # mv ndb_mg</em> /usr/bin/ # cd # rm -rf /usr/src/mysql-mgm 现在开始为这台管理节点服务器建立配置文件： # mkdir /var/lib/mysql-cluster # cd /var/lib/mysql-cluster # vi config.ini 在config.ini中添加如下内容： [NDBD DEFAULT] NoOfReplicas=2 [MYSQLD DEFAULT] [NDB_MGMD DEFAULT] [TCP DEFAULT] # Managment Server [NDB_MGMD] HostName=192.168.0.3 #管理节点服务器Server3的IP地址 # Storage Engines [NDBD] HostName=192.168.0.1 #MySQL集群Server1的IP地址 DataDir= /var/lib/mysql-cluster [NDBD] HostName=192.168.0.2 #MySQL集群Server2的IP地址 DataDir=/var/lib/mysql-cluster # 以下2个[MYSQLD]可以填写Server1和Server2的主机名。 # 但为了能够更快的更换集群中的服务器，推荐留空，否则更换服务器后必须对这个配置进行更改。 [MYSQLD] [MYSQLD] 保存退出后，启动管理节点服务器Server3： # ndb_mgmd 启动管理节点后应该注意，这只是管理节点服务，并不是管理终端。因而你看不到任何关于启动后的输出信息。 四、配置集群服务器并启动MySQL ============================= 在Server1和Server2中都需要进行如下改动： # vi /etc/my.cnf [mysqld] ndbcluster ndb-connectstring=192.168.0.3 #Server3的IP地址 [mysql_cluster] ndb-connectstring=192.168.0.3 #Server3的IP地址 保存退出后，建立数据目录并启动MySQL： # mkdir /var/lib/mysql-cluster # cd /var/lib/mysql-cluster # /usr/local/mysql/bin/ndbd –initial # /etc/rc.d/init.d/mysqld start 可以把/usr/local/mysql/bin/ndbd加到/etc/rc.local中实现开机启动。 注意：只有在第一次启动ndbd时或者对Server3的config.ini进行改动后才需要使用–initial参数！ 五、检查工作状态 ================ 回到管理节点服务器Server3上，并启动管理终端： # /usr/bin/ndb_mgm 键入show命令查看当前工作状态：（下面是一个状态输出示例） [root@mysql3 root]# /usr/bin/ndb_mgm – NDB Cluster – Management Client – ndb_mgm&gt; show Connected to Management Server at: localhost:1186 Cluster Configuration ——————— [ndbd(NDB)]     2 node(s) id=2    @192.168.0.1  (Version: 4.1.9, Nodegroup: 0, Master) id=3    @192.168.0.2  (Version: 4.1.9, Nodegroup: 0) [ndb_mgmd(MGM)] 1 node(s) id=1    @192.168.0.3  (Version: 4.1.9) [mysqld(API)]   2 node(s) id=4   (Version: 4.1.9) id=5   (Version: 4.1.9) ndb_mgm&gt; 如果上面没有问题，现在开始测试MySQL： 注意，这篇文档对于MySQL并没有设置root密码，推荐你自己设置Server1和Server2的MySQL root密码。 在Server1中： # /usr/local/mysql/bin/mysql -u root -p &gt; use test; &gt; CREATE TABLE ctest (i INT) ENGINE=NDBCLUSTER; &gt; INSERT INTO ctest () VALUES (1); &gt; SELECT * FROM ctest; 应该可以看到1 row returned信息（返回数值1）。 如果上述正常，则换到Server2上重复上面的测试，观察效果。如果成功，则在Server2中执行INSERT再换回到Server1观察是否工作正常。 如果都没有问题，那么恭喜成功！ 六、破坏性测试 ============== 将Server1或Server2的网线拔掉，观察另外一台集群服务器工作是否正常（可以使用SELECT查询测试）。测试完毕后，重新插入网线即可。 如果你接触不到物理服务器，也就是说不能拔掉网线，那也可以这样测试： 在Server1或Server2上： # ps aux | grep ndbd 将会看到所有ndbd进程信息： root      5578  0.0  0.3  6220 1964 ?        S    03:14   0:00 ndbd root      5579  0.0 20.4 492072 102828 ?     R    03:14   0:04 ndbd root     23532  0.0  0.1  3680  684 pts/1    S    07:59   0:00 grep ndbd 然后杀掉一个ndbd进程以达到破坏MySQL集群服务器的目的： # kill -9 5578 5579 之后在另一台集群服务器上使用SELECT查询测试。并且在管理节点服务器的管理终端中执行show命令会看到被破坏的那台服务器的状态。 测试完成后，只需要重新启动被破坏服务器的ndbd进程即可： # ndbd 注意！前面说过了，此时是不用加–inital参数的！ 至此，MySQL集群就配置完成了！</p>

            
            <p class="more">
                <a href="/2015/12/07/2019030500107/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/07/2019030500107/" title="mysql集群">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/7.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/04/2019030500066/">
    		MySQL主从复制（Master-Slave）与读写分离
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-04T05:31:11.000Z">2015-12-04</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/Master/" title="Master">Master</a> / 
    
        <a href="/tags/Slave/" title="Slave">Slave</a> / 
    
        <a href="/tags/主从复制/" title="主从复制">主从复制</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>1. 主从复制通过修改 mysql 配置文件实现。 2. 读写分离通过 Amoeba for Mysql/MySQL-Proxy <img src="/uploads/2015/12/42f7d87b-0c40-33a6-bc09-af7ff4f195f0.jpg" alt> 3. 4台服务器做的一套集群方案 <img src="/uploads/2015/12/935df5ae-e425-39c6-9bac-bbc9ab0c43de.png" alt> Amoeba for Mysql和 MySQL-Proxy： 1. Amoeba 是用JAVA写的功能异常强大，支持读写分离，表和库级别的读写分离，数据库水平分割，垂直分割，还有集群。 2.mysql-proxy 只是轻量级的读写分离程序C写的，驱动是需要lua的脚本跑，而且在高并发下经常挂掉。程序还忽略了一些字符设定，如果数据库不是同一编码还会出现乱码,amoeba就不存在 。 3. mysql proxy没有现成的 lua脚本。mysql proxy根本没有配置文件，lua脚本就是它的全部 。 而moeba for Mysql只需要进行相关的配置就可以满足需求</p>

            
            <p class="more">
                <a href="/2015/12/04/2019030500066/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/04/2019030500066/" title="MySQL主从复制（Master-Slave）与读写分离">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/4.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/03/2019030500090/">
    		MySQL性能优化 - 修改配置文件my.cnf
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-03T06:45:30.000Z">2015-12-03</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/my-cnf/" title="my.cnf">my.cnf</a> / 
    
        <a href="/tags/优化/" title="优化">优化</a> / 
    
        <a href="/tags/性能/" title="性能">性能</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>在Apache, PHP, MySQL的体系架构中，MySQL对于性能的影响最大，也是关键的核心部分。对于Discuz!论坛程序也是如此，MySQL的设置是否合理优化，直接影响到论坛的速度和承载量！同时，MySQL也是优化难度最大的一个部分，不但需要理解一些MySQL专业知识，同时还需要长时间的观察统计并且根据经验进行判断，然后设置合理的参数。 下面我们了解一下MySQL优化的一些基础，MySQL的优化我分为两个部分，一是服务器物理硬件的优化，二是MySQL自身(my.cnf)的优化。 一、服务器硬件对MySQL性能的影响 ①磁盘寻道能力（磁盘I/O）,以目前高转速SCSI硬盘(7200转/秒)为例，这种硬盘理论上每秒寻道7200次，这是物理特性决定的，没有办法改变。MySQL每秒钟都在进行大量、复杂的查询操作，对磁盘的读写量可想而知。所以，通常认为磁盘I/O是制约MySQL性能的最大因素之一，对于日均访问量在100万PV以上的Discuz!论坛，由于磁盘I/O的制约，MySQL的性能会非常低下！解决这一制约因素可以考虑以下几种解决方案： 使用RAID-0+1磁盘阵列，注意不要尝试使用RAID-5，MySQL在RAID-5磁盘阵列上的效率不会像你期待的那样快。 ②CPU 对于MySQL应用，推荐使用S.M.P.架构的多路对称CPU，例如：可以使用两颗Intel Xeon 3.6GHz的CPU，现在我较推荐用4U的服务器来专门做数据库服务器，不仅仅是针对于mysql。 ③物理内存对于一台使用MySQL的Database Server来说，服务器内存建议不要小于2GB，推荐使用4GB以上的物理内存，不过内存对于现在的服务器而言可以说是一个可以忽略的问题，工作中遇到了高端服务器基本上内存都超过了16G。 二、MySQL自身因素当解决了上述服务器硬件制约因素后，让我们看看MySQL自身的优化是如何操作的。 对MySQL自身的优化主要是对其配置文件my.cnf中的各项参数进行优化调整。下面我们介绍一些对性能影响较大的参数。 由于my.cnf文件的优化设置是与服务器硬件配置息息相关的， 因而我们指定一个假想的服务器硬件环境：CPU: 2颗Intel Xeon 2.4GHz 内存: 4GB DDR 硬盘: SCSI 73GB(很常见的2U服务器 ) 。 下面，我们根据以上硬件配置结合一份已经优化好的my.cnf进行说明： [mysqld] port = 3306 serverid = 1 socket = /tmp/mysql.sock skip-locking #避免MySQL的外部锁定，减少出错几率增强稳定性。 skip-name-resolve #禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！ back_log = 384 #back_log参数的值指出在MySQL暂时停止响应新请求之前的短时间内多少个请求可以被存在堆栈中。 如果系统在一个短时间内有很多连接，则需要增大该参数的值，该参数值指定到来的TCP/IP连接的侦听队列的大小。不同的操作系统在这个队列大小上有它自己的限制。 试图设定back_log高于你的操作系统的限制将是无效的。默认值为50。对于Linux系统推荐设置为小于512的整数。 key_buffer_size = 256M #key_buffer_size指定用于索引的缓冲区大小，增加它可得到更好的索引处理性能。对于内存在4GB左右的服务器该参数可设置为256M或384M。注意：该参数值设置的过大反而会是服务器整体效率降低！ max_allowed_packet = 4M thread_stack = 256K table_cache = 128K sort_buffer_size = 6M #查询排序时所能使用的缓冲区大小。注意：该参数对应的分配内存是每连接独占，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6 ＝ 600MB。所以，对于内存在4GB左右的服务器推荐设置为6-8M。 read_buffer_size = 4M #读查询操作所能使用的缓冲区大小。和sort_buffer_size一样，该参数对应的分配内存也是每连接独享。 join_buffer_size = 8M #联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每连接独享。 myisam_sort_buffer_size = 64M table_cache = 512 thread_cache_size = 64 query_cache_size = 64M #指定MySQL查询缓冲区的大小。可以通过在MySQL控制台观察，如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓冲；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。 tmp_table_size = 256M max_connections = 768 #指定MySQL允许的最大连接进程数。如果在访问论坛时经常出现Too Many Connections的错误提 示，则需要增大该参数值。 max_connect_errors = 10000000 wait_timeout = 10 #指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。 thread_concurrency = 8 #该参数取值为服务器逻辑CPU数量*2，在本例中，服务器有2颗物理CPU，而每颗物理CPU又支持H.T超线程，所以实际取值为4*2=8 skip-networking #开启该选项可以彻底关闭MySQL的TCP/IP连接方式，如果WEB服务器是以远程连接的方式访问MySQL数据库服务器则不要开启该选项！否则将无法正常连接！ table_cache=1024 #物理内存越大,设置就越大.默认为2402,调到512-1024最佳 innodb_additional_mem_pool_size=4M #默认为2M innodb_flush_log_at_trx_commit=1 #设置为0就是等到innodb_log_buffer_size列队满后再统一储存,默认为1 innodb_log_buffer_size=2M #默认为1M innodb_thread_concurrency=8 #你的服务器CPU有几个就设置为几,建议用默认一般为8 key_buffer_size=256M #默认为218，调到128最佳 tmp_table_size=64M #默认为16M，调到64-256最挂 read_buffer_size=4M #默认为64K read_rnd_buffer_size=16M #默认为256K sort_buffer_size=32M #默认为256K thread_cache_size=120 #默认为60 query_cache_size=32M ※值得注意的是： 很多情况需要具体情况具体分析 一、如果Key_reads太大，则应该把my.cnf中Key_buffer_size变大，保持Key_reads/Key_read_requests至少1/100以上，越小越好。 二、如果Qcache_lowmem_prunes很大，就要增加Query_cache_size的值。</p>

            
            <p class="more">
                <a href="/2015/12/03/2019030500090/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/03/2019030500090/" title="MySQL性能优化 - 修改配置文件my.cnf">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/3.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/03/2019030500078/">
    		mysql-存储引擎
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-03T06:44:18.000Z">2015-12-03</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/InnoDB/" title="InnoDB">InnoDB</a> / 
    
        <a href="/tags/MyISAM/" title="MyISAM">MyISAM</a> / 
    
        <a href="/tags/BDB/" title="BDB">BDB</a> / 
    
        <a href="/tags/EXAMPLE/" title="EXAMPLE">EXAMPLE</a> / 
    
        <a href="/tags/Federated/" title="Federated">Federated</a> / 
    
        <a href="/tags/Memory/" title="Memory">Memory</a> / 
    
        <a href="/tags/Merge/" title="Merge">Merge</a> / 
    
        <a href="/tags/存储引擎/" title="存储引擎">存储引擎</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <h1 id="mysql-存储引擎"><a href="#mysql-存储引擎" class="headerlink" title="mysql-存储引擎"></a>mysql-存储引擎</h1><p>mysql 存储引擎一般有 MyISAM、InnoDB、Memory、Merge、BDB、EXAMPLE、Federated 存储引擎。 一、MyISAM存储引擎 不支持事务的存储引擎，它是基于更老的ISAM存储引擎，每个MyISAM 存储引擎类型的表在磁盘上存储3个文件：tablename.frm存储定义文件、tablename.MYD :存储表的数据文件 tableName.MYI存储表的索引文件。我们指明设置一个表的存储引擎为MyISAM 存储引擎可以：Create table t(i int primarykey) engine=MyISAM ，注意老版本（5.1之前）的是使用type关键字 ，而从5.1之后是使用engine关键字。MyISAM存储引擎是mysql默认的存储引擎，但是在5.5以及5.5版本之后mysql的默认存储引擎是InnoDB 存储引擎。 MyISAM存储引擎的特性： 1、每个MyISAM存储引擎的表最大支持64个索引文件 2、blob和text列可以被设置为索引 3、提供高速的存储和压缩表以及全文检索功能 4、MyISAM是对整个表进行加锁的，不是对行锁的，读取时候会对其读取的所有表进行加共享锁，写入的时候会对表加入排他锁，但是在表的读取查询的同时，也可以往表里插入新的记录。 5、MyISAM表使用了B型树的索引 索引文件大小为： （key_length +4） * 0.67 加上所有键的和。 6、MyISAM支持三种不同的存储格式：固定格式、动态格式和压缩格式，固定格式和动态格式根据正在使用的列进行自动选择，对于已经压缩的格式则必须使用myisampack工具来创建。 7、MyISAM存储引擎使用前缀压缩使得索引更小。 二、InnoDB存储引擎 InnoDB给mysql数据库提供了具有提交、回滚和崩溃恢复的事务安全存储引擎，InnoDB锁定在行级别并也在查询的select语句中非锁定读–这些特性增加了mysql数据库的吞吐量，我们都知道mysql在解决高并发的环境下使用了共享锁和排他锁（其实这就像我们在java语言中的JDK1.5中添加的并发包中的ReentrantReadWriteLock 类，多个线程可以持有读锁-共享锁，有且仅当有一个线程具有写锁-排他锁，并且写锁的优先级最高，当写锁到达的时候必须插入到所有读锁之前，其他获得的读锁的线程必须等待写锁完成）那如何看待Innodb的性能呢？ 1、innodb是行级别的锁定适合非常小的空间而不是像MyISAM存储引擎基本上是整张表进行锁定，innodb支持外键特性 innodb是为处理巨大数据量的最大性能而设计的，它为主内存中缓冲数据和索引而维护自己的缓冲池，innodb存储它的表和索引在一个表的空间中，表空间可以包含数个文件 innodb表可以使任何尺寸的，即使文件大小受操作系统的限制也是可以的。 被InnoDB存储引擎所管理的资源包含有innodb的表空间和它的日志文件。   转摘于：<a href="http://qq466862016.iteye.com/blog/2261069" target="_blank" rel="noopener">http://qq466862016.iteye.com/blog/2261069</a></p>

            
            <p class="more">
                <a href="/2015/12/03/2019030500078/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/03/2019030500078/" title="mysql-存储引擎">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/3.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/01/2019030500065/">
    		mysql中的字符串的拼接
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-01T07:01:03.000Z">2015-12-01</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/字符串/" title="字符串">字符串</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>字符串的拼接 1，Mysql 在Java、C#等编程语言中字符串的拼接可以通过加号“+”来实现，比如：”1”+”3”、”a”+”b”。 在MYSQL中也可以使用加号“+”来连接两个字符串，比如下面的SQL： Sql代码 复制代码 收藏代码 1.SELECT ‘12’+’33’,FAge+’1’ FROM T_Employee 执行结果 Sql代码 复制代码 收藏代码 1.’12’+’33’  FAge+’1’ 2.45    26 3.45  29 4.45  24 5.45  26 6.45  29 7.45  28 8.45  24 9.45  29 10.45  23 MYSQL会尝试将加号两端的字段值尝试转换为数字类型，如果转换失败则认为字段值为 0，比如我们执行下面的SQL语句： Sql代码 复制代码 收藏代码 1.SELECT ‘abc’+’123’,FAge+’a’ FROM T_Employee 执行完毕我们就能在输出结果中看到下面的执行结果： Html代码 复制代码 收藏代码 1. 2.’abc’+’123’  FAge+’a’ 3.123  25 4.123  28 5.123  23 6.123  25 7.123  28 8.123  27 9.123  23 10.123  28 11.123  22 在MYSQL中进行字符串的拼接要使用CONCAT函数，CONCAT函数支持一个或者多个参数， 参数类型可以为字符串类型也可以是非字符串类型，对于非字符串类型的参数MYSQL将尝试 将其转化为字符串类型，CONCAT函数会将所有参数按照参数的顺序拼接成一个字符串做为 返回值。比如下面的SQL语句用于将用户的多个字段信息以一个计算字段的形式查询出来： Sql代码 复制代码 收藏代码 1.SELECT CONCAT(‘工号为:’,FNumber,’的员工的幸福指数:’,FSalary/(FAge-21)) FROM T_Employee  执行完毕我们就能在输出结果中看到下面的执行结果： Java代码 复制代码 收藏代码 1.CONCAT(‘工号为:’,FNumber,’的员工的幸福指数:’,FSalary/(FAge-21)) 2.工号为:DEV001的员工的幸福指数:2075.000000 3.工号为:DEV002的员工的幸福指数:328.685714 4.工号为:HR001的员工的幸福指数:1100.440000 MYSQL中还提供了另外一个进行字符串拼接的函数CONCAT_WS， CONCAT_WS可以在待拼接的字符串之间加入指定的分隔符，它的第一个参数值为采用的分 隔符，而剩下的参数则为待拼接的字符串值，比如执行下面的SQL： Sql代码 复制代码 收藏代码 1.SELECT CONCAT_WS(‘,’,FNumber,FAge,FDepartment,FSalary) FROM T_Employee 执行完毕我们就能在输出结果中看到下面的执行结果： Java代码 复制代码 收藏代码 1.CONCAT_WS(‘,’,FNumber,FAge,FDepartment,FSalary) 2.DEV001,25,Development,8300.00 3.DEV002,28,Development,2300.80 4.HR001,23,HumanResource,2200.88 5.HR002,25,HumanResource,5200.36 6.IT001,28,InfoTech,3900.00 7.IT002,27,InfoTech,2800.00 8.SALES001,23,Sales,5000.00 9.SALES002,28,Sales,6200.00 10.SALES003,22,Sales,1200.00 2，oracle Oracle中使用“||”进行字符串拼接，其使用方式和MSSQLServer中的加号“+”一样。 比如执行下面的SQL语句： Sql代码 复制代码 收藏代码 1.SELECT ‘工号为’||FNumber||’的员工姓名为’||FName FROM T_Employee 2.WHERE FName IS NOT NULL 执行完毕我们就能在输出结果中看到下面的执行结果： Html代码 复制代码 收藏代码 1.工号为||FNUMBER||的员工姓名为||FNAME 2.工号为DEV001的员工姓名为Tom 3.工号为DEV002的员工姓名为Jerry 4.工号为SALES001的员工姓名为John 5.工号为SALES002的员工姓名为Kerry 6.工号为SALES003的员工姓名为Stone 7.工号为HR001的员工姓名为Jane 8.工号为HR002的员工姓名为Tina 9.工号为IT001的员工姓名为Smith 除了“||”，Oracle还支持使用CONCAT()函数进行字符串拼接，比如执行下面的SQL语句： Sql代码 复制代码 收藏代码 1.SELECT CONCAT(‘工号:’,FNumber) FROM T_Employee 执行完毕我们就能在输出结果中看到下面的执行结果： Html代码 复制代码 收藏代码 1.CONCAT(工号:,FNUMBER) 2.工号:DEV001 3.工号:DEV002 4.工号:HR001 5.工号:HR002 6.工号:IT001 7.工号:IT002 8.工号:SALES001 9.工号:SALES002 10.工号:SALES003 如果CONCAT中连接的值不是字符串，Oracle会尝试将其转换为字符串， 与MYSQL的CONCAT()函数不同，Oracle的CONCAT()函数只支持两个参数，不支持两个以 上字符串的拼接。如果要进行多个字符串的拼接的话，可以使用多个CONCAT()函数嵌套使用。 Sql代码 复制代码 收藏代码 1.SELECT CONCAT(CONCAT(CONCAT(‘工号为’,FNumber),’的员工姓名为’),FName) FROM 2.T_Employee 3.WHERE FName IS NOT NULL 执行完毕我们就能在输出结果中看到下面的执行结果： Html代码 复制代码 收藏代码 1.CONCAT(CONCAT(CONCAT(工号为,FNUMBER),的员工姓名为),FNAME) 2.工号为DEV001的员工姓名为Tom 3.工号为DEV002的员工姓名为Jerry 4.工号为SALES001的员工姓名为John 5.工号为SALES002的员工姓名为Kerry 6.工号为SALES003的员工姓名为Stone 7.工号为HR001的员工姓名为Jane 8.工号为HR002的员工姓名为Tina 9.工号为IT001的员工姓名为Smith</p>

            
            <p class="more">
                <a href="/2015/12/01/2019030500065/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/01/2019030500065/" title="mysql中的字符串的拼接">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <a class="extend prev" rel="prev" href="/tags/MySQL/page/2/">前一页</a><a class="page-number" href="/tags/MySQL/">1</a><a class="page-number" href="/tags/MySQL/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/tags/MySQL/page/4/">4</a><a class="page-number" href="/tags/MySQL/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/tags/MySQL/page/8/">8</a><a class="extend next" rel="next" href="/tags/MySQL/page/4/">后一页</a>
    </nav>
    


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/MySQL/">MySQL</a>
        <span class="badge">(92)</span>
    </li>
    
    <li>
        <a href="/categories/Oracle/">Oracle</a>
        <span class="badge">(40)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/">NOSQL</a>
        <span class="badge">(17)</span>
    </li>
    
    <li>
        <a href="/categories/开发语言/">开发语言</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="/categories/SQL-Server/">SQL Server</a>
        <span class="badge">(13)</span>
    </li>
    
    <li>
        <a href="/categories/其他数据库/">其他数据库</a>
        <span class="badge">(4)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/">Oracle</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/SQL-Server/">SQL Server</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/开发语言/">开发语言</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/MySQL/" title="MySQL">MySQL (71)</a>
  
    <a class="tag-item" href="/tags/位运算/" title="位运算">位运算 (0)</a>
  
    <a class="tag-item" href="/tags/sqlplus/" title="sqlplus">sqlplus (1)</a>
  
    <a class="tag-item" href="/tags/PL-SQL/" title="PL/SQL">PL/SQL (5)</a>
  
    <a class="tag-item" href="/tags/数据库/" title="数据库">数据库 (7)</a>
  
    <a class="tag-item" href="/tags/视图/" title="视图">视图 (1)</a>
  
    <a class="tag-item" href="/tags/B-Tree/" title="B+Tree">B+Tree (1)</a>
  
    <a class="tag-item" href="/tags/索引/" title="索引">索引 (1)</a>
  
    <a class="tag-item" href="/tags/redis/" title="redis">redis (6)</a>
  
    <a class="tag-item" href="/tags/SSDB/" title="SSDB">SSDB (1)</a>
  
    <a class="tag-item" href="/tags/SQL/" title="SQL">SQL (17)</a>
  
    <a class="tag-item" href="/tags/ORA-00600/" title="ORA-00600">ORA-00600 (1)</a>
  
    <a class="tag-item" href="/tags/存储过程/" title="存储过程">存储过程 (3)</a>
  
    <a class="tag-item" href="/tags/CentOS/" title="CentOS">CentOS (2)</a>
  
    <a class="tag-item" href="/tags/allow/" title="allow">allow (1)</a>
  
    <a class="tag-item" href="/tags/Apache/" title="Apache">Apache (1)</a>
  
    <a class="tag-item" href="/tags/deny/" title="deny">deny (1)</a>
  
    <a class="tag-item" href="/tags/druid/" title="druid">druid (1)</a>
  
    <a class="tag-item" href="/tags/心跳/" title="心跳">心跳 (1)</a>
  
    <a class="tag-item" href="/tags/事务/" title="事务">事务 (5)</a>
  
    <a class="tag-item" href="/tags/分布式/" title="分布式">分布式 (1)</a>
  
    <a class="tag-item" href="/tags/消息/" title="消息">消息 (1)</a>
  
    <a class="tag-item" href="/tags/KeepAlived/" title="KeepAlived">KeepAlived (1)</a>
  
    <a class="tag-item" href="/tags/Oracle/" title="Oracle">Oracle (30)</a>
  
    <a class="tag-item" href="/tags/schedule-job/" title="schedule job">schedule job (1)</a>
  
    <a class="tag-item" href="/tags/分库/" title="分库">分库 (1)</a>
  
    <a class="tag-item" href="/tags/分库分表/" title="分库分表">分库分表 (1)</a>
  
    <a class="tag-item" href="/tags/分表/" title="分表">分表 (1)</a>
  
    <a class="tag-item" href="/tags/结构同步/" title="结构同步">结构同步 (1)</a>
  
    <a class="tag-item" href="/tags/批量/" title="批量">批量 (1)</a>
  
    <a class="tag-item" href="/tags/truncate/" title="truncate">truncate (1)</a>
  
    <a class="tag-item" href="/tags/Hash索引/" title="Hash索引">Hash索引 (1)</a>
  
    <a class="tag-item" href="/tags/InnoDB/" title="InnoDB">InnoDB (3)</a>
  
    <a class="tag-item" href="/tags/MyISAM/" title="MyISAM">MyISAM (3)</a>
  
    <a class="tag-item" href="/tags/索引优化/" title="索引优化">索引优化 (1)</a>
  
    <a class="tag-item" href="/tags/FineReport/" title="FineReport">FineReport (1)</a>
  
    <a class="tag-item" href="/tags/报表/" title="报表">报表 (1)</a>
  
    <a class="tag-item" href="/tags/数据集/" title="数据集">数据集 (1)</a>
  
    <a class="tag-item" href="/tags/Excel/" title="Excel">Excel (1)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="https://jelon.top" target="_blank" title="Jelon个人前端小站">前端博客小站</a>
        </li>
    
        <li>
            <a href="https://www.baidu.com" target="_blank" title="百度搜索">百度</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>