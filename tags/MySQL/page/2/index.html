<!doctype html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8">
    <meta name="baidu-site-verification" content="dIcXMeY8Ya">
    
    <title>`MySQL`标签下的文章 | 软件开发吧</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="keywords" content="SQL云,SQL云开发,SQL笔记,SQL开发,云开发,MySQL,Oralce,数据库,数据库云,数据库开发,数据库云开发,SQL教程,数据库教程,开发笔记,MySQL笔记,MySQL教程">
    <meta name="description" content="为满足广大程序猿兄弟对日常工作中学习数据库、使用使用数据库资料查询需求，SQL云开发免费将自己整理的各种数据库技术资料分享出来，并希望与广大猿兄一起讨论学习与进步,致力于一起更方便、快捷资料学习查询,实现更安全、高效的数据存储.">

    
    <link rel="alternative" href="/atom.xml" title="软件开发吧" type="application/atom+xml">
    
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
</html>
<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">软件开发吧</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/tags/MySQL/page/2/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/tags/MySQL/page/2/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/tags/MySQL/page/2/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/tags/MySQL/page/2/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/cdneitui" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.github.com/" target="_blank">Hosted by GitHub Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon">
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 按标签分类 -->

    <h3 class="widget-hd">
        <strong>
            
                `MySQL`标签下的文章
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/01/28/2019030500091/">
    		MySQL性能优化的最佳经验
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-01-28T05:34:54.000Z">2016-01-28</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>1、为查询优化你的查询 大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。 这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为，我们某些查询语句会让MySQL不使用缓存。请看下面的示例： // 查询缓存不开启 $r = mysql_query(“SELECT username FROM user WHERE     signup_date &gt;= CURDATE()”); // 开启查询缓存 $today = date(“Y-m-d”); $r = mysql_query(“SELECT username FROM user WHERE signup_date &gt;= ‘$today’”); 上面两条SQL语句的差别就是 CURDATE() ，MySQL的查询缓存对这个函数不起作用。所以，像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替MySQL的函数，从而开启缓存。 2、EXPLAIN 你的SELECT查询 使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。 有表关联的查询，如下列： select username, group_name from users u joins groups g on (u.group_id = g.id) 发现查询缓慢，然后在group_id字段上增加索引，则会加快查询 3、当只要一行数据时使用LIMIT 1 当你查询表的有些时候，你已经知道结果只会有一条结果，单因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。 在这种情况下，加上LIMIT 1 可以增加性能。这样一样， MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查找下一条符合记录的数据。 下面的示例，只是为了找一下是否有“中国”的用户，很明显，后面的会比前面的更有效率。（请注意，第一条中是Select <em>，第二条是Select 1） // 没有效率的： $r = mysql_query(“SELECT </em> FROM user WHERE country = ‘China’”); if (mysql_num_rows($r) &gt; 0) { // … } // 有效率的： $r = mysql_query(“SELECT 1 FROM user WHERE country = ‘China’ LIMIT 1”); if (mysql_num_rows($r) &gt; 0) { // … } 宣传语 历经两个半月的准备，三次大改版，十七次小改版。le1024终于要和大家见面了。 le1024每天推荐1~3段，有趣、有爱、有故事的视频。 为您工作、学习、生活之余增加一点快乐的感觉。程序员必看的快乐视频网站 4、为搜索字段建索引 索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么，请为其建立索引吧。 5、在Join表的时候使用相当类型的列，并将其索引 如果你的应用程序有很多JOIN查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。 而且，这些被用来Join的字段，应该是相同的类型的。例如：如果你要把DECIMAL字段和一个INT字段JOIN在一起，MYSQL就无法使用他们的索引。对于那些STRING类型，还需要有相同的字符集才行（两个表的字符集有可能不一样） 6、千万不要ORDER BY RAND() 7、避免SELECT <em> 从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。 所以，你应该养成一个需要什么就取什么的好的习惯。 // 不推荐 $r = mysql_query(“SELECT </em> FROM user WHERE user_id = 1”); $d = mysql_fetch_assoc($r); echo “Welcome {$d[‘username’]}”; // 推荐 $r = mysql_query(“SELECT username FROM user WHERE user_id = 1”); $d = mysql_fetch_assoc($r); echo “Welcome {$d[‘username’]}”; 8、永远为两张表设置一个ID 我们应该为数据库里的每张表都设置一个ID作为其主键，而最好的是一个INT型（推荐使用UNSIGNED），并设置上自动增长的AUTO INCREMENT标志。 就算是你 users 表有一个主键叫 “email”的字段，你也别让它成为主键。使用 VARCHAR 类型来当主键会使用得性能下降。另外，在你的程序中，你应该使用表的ID来构造你的数据结构。 而且，在MySQL数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要，比如，集群，分区…… 9、使用 ENUM 而不是 VARCHAR ？ ENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。 如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。 10、从 PROCEDURE ANALYSE() 取得建议 ？ PROCEDURE ANALYSE() 会让 MySQL 帮你去分析你的字段和其实际的数据，并会给你一些有用的建议。只有表中有实际的数据，这些建议才会变得有用，因为要做一些大的决定是需要有数据作为基础的。 例如，如果你创建了一个 INT 字段作为你的主键，然而并没有太多的数据，那么，PROCEDURE ANALYSE()会建议你把这个字段的类型改成 MEDIUMINT 。或是你使用了一个 VARCHAR 字段，因为数据不多，你可能会得到一个让你把它改成 ENUM 的建议。这些建议，都是可能因为数据不够多，所以决策做得就不够准。 11、尽可能的使用 NOT NULL 除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。这看起来好像有点争议，请往下看。 首先，问问你自己“Empty”和“NULL”有多大的区别（如果是INT，那就是0和NULL）？如果你觉得它们之间没有什么区别，那么你就不要使用NULL。（你知道吗？在 Oracle 里，NULL 和 Empty 的字符串是一样的！) 不要以为 NULL 不需要空间，其需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用NULL了，现实情况是很复杂的，依然会有些情况下，你需要使用NULL值。 下面摘自MySQL自己的文档 “NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.” 12、把IP地址存成 UNSIGNED INT 很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的IP而不是整形的IP。如果你用整形来存放，只需要4个字节，并且你可以有定长的字段。而且，这会为你带来查询上的优势，尤其是当你需要使用这样的WHERE条件：IP between ip1 and ip2。 我们必需要使用UNSIGNED INT，因为 IP地址会使用整个32位的无符号整形 13、固定长度的表会更快 如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static” 或 “fixed-length”。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。 固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。 并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。 14、垂直分割 “垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。（以前，在银行做过项目，见过一张表有100多个字段，很恐怖） 示例一：在Users表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性能。 示例二： 你有一个叫 “last_login” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。 另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。 15、拆分大的 DELETE 或 INSERT 语句 如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。 Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。 如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你泊WEB服务Crash，还可能会让你的整台服务器马上掛了。 所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。下面是一个示例： while (1) { //每次只做1000条 mysql_query(“DELETE FROM logs WHERE log_date &lt;= ‘2009-11-01’ LIMIT 1000”); if (mysql_affected_rows() == 0) { // 没得可删了，退出！ break; } // 每次都要休息一会儿 usleep(50000); } 16、 越小的列会越快 对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。 参看 MySQL 的文档 Storage Requirements 查看所有的数据类型。 如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。 当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看Slashdot的例子（2009年11月06日），一个简单的ALTER TABLE语句花了3个多小时，因为里面有一千六百万条数据。 17、选择一个正确的存储引擎 在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。酷壳以前文章《MySQL: InnoDB 还是 MyISAM?》讨论和这个事情。 MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(<em>) 这类的计算是超快无比的。 InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。 18、小心“永久链接” “永久链接”的目的是用来减少重新创建MySQL链接的次数。当一个链接被创建了，它会永远处在连接的状态，就算是数据库操作已经结束了。而且，自从我们的Apache开始重用它的子进程后——也就是说，下一次的HTTP请求会重用Apache的子进程，并重用相同的 MySQL 链接。 PHP手册：mysql_pconnect() 在理论上来说，这听起来非常的不错。但是从个人经验（也是大多数人的）上来说，这个功能制造出来的麻烦事更多。因为，你只有有限的链接数，内存问题，文件句柄数，等等。 而且，Apache 运行在极端并行的环境中，会创建很多很多的了进程。这就是为什么这种“永久链接”的机制工作地不好的原因。在你决定要使用“永久链接”之前，你需要好好地考虑一下你的整个系统的架构。 参考 19、当查询较慢的时候，可用Join来改写一下该查询来进行优化 mysql&gt; select sql_no_cache </em> from guang_deal_outs where deal_id in (select id from guang_deals where id = 100017151) ; Empty set (18.87 sec) mysql&gt; select sql_no_cache a.<em> from guang_deal_outs a inner join guang_deals b on a.deal_id = b.id where b.id = 100017151; Empty set (0.01 sec) 原因 mysql&gt; desc select sql_no_cache </em> from guang_deal_outs where deal_id in (select id from guang_deals where id = 100017151) ; +—-+——————–+—————–+——-+—————+———+———+——-+———-+————-+ | id | select_type        | table           | type  | possible_keys | key     | key_len | ref   | rows     | Extra       | +—-+——————–+—————–+——-+—————+———    +———+——-+———-+————-+ |  1 | PRIMARY            | guang_deal_outs | ALL   | NULL          | NULL    |     NULL    | NULL  | 18633779 | Using where | |  2 | DEPENDENT SUBQUERY | guang_deals     | const | PRIMARY       | PRIMARY |     4       | const |        1 | Using index | +—-+——————–+—————–+——-+—————+———    +———+——-+———-+————-+ 2 rows in set (0.04 sec) mysql&gt; desc select sql_no_cache a.<em> from guang_deal_outs a inner join guang_deals b on a.deal_id = b.id where b.id = 100017151; +—-+————-+——-+——-+———————-    +———————-+———+——-+——+————-+ | id | select_type | table | type  | possible_keys        | key                      | key_len | ref   | rows | Extra       | +—-+————-+——-+——-+———————-    +———————-+———+——-+——+————-+ |  1 | SIMPLE      | b     | const | PRIMARY              | PRIMARY                  | 4       | const |    1 | Using index | |  1 | SIMPLE      | a     | ref   | idx_guang_dlout_dlid |     idx_guang_dlout_dlid | 4       | const |    1 |             | +—-+————-+——-+——-+———————-    +———————-+———+——-+——+————-+ 2 rows in set (0.05 sec) 其实在  guang_deal_outs 在deal_id 上也是有索引的。 其实我想把子查询设置为 select </em> from guang_deal_outs where deal_id in (select id from guang_deals where id = 100017151); 变成下面的样子 select <em> from guang_deal_outs where deal_id in (100017151); 但不幸的是，实际情况正好相反。MySQL试图让它和外面的表产生联系来“帮助”优化查询，它认为下面的exists形式更有效率 select </em> from guang_deal_outs where exists (select * from guang_deals where id = 100017151 and id = guang_deal_outs.deal_id); 这种in子查询的形式，在外部表（比如上面的guang_deals）数据量比较大的时候效率是很差的（如果对于较小的表，不会造成显著地影响）</p>

            
            <p class="more">
                <a href="/2016/01/28/2019030500091/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/01/28/2019030500091/" title="MySQL性能优化的最佳经验">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/8.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/01/26/2019030500085/">
    		mysql 安装后链接时报 1045 的错误
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-01-26T02:31:21.000Z">2016-01-26</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/access/" title="access">access</a> / 
    
        <a href="/tags/dos/" title="dos">dos</a> / 
    
        <a href="/tags/windows/" title="windows">windows</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>错误信息：Error 1045(280000): access denied for user root localhost windows 下（验证可行）： 1、先要关闭 mysql 服务。 不关闭 mysql 服务，在第三步会没有反应。 2、打开 dos,  cd 到你 mysql 的安装目录中的 bin 目录下。 3、执行&gt;mysqld  –defaults-file=”C:\Program Files\MySQL\MySQL Server 5.1\my.ini” –console –skip-grant-tables “C:\Program Files\MySQL\MySQL Server 5.1\my.ini”，这个 my.ini 在你的 mysql 安装目录下（bin 目录的上一级）。 输出信息： 160126  9:11:39 [Note] Plugin ‘FEDERATED’ is disabled. 160126  9:11:39  InnoDB: Initializing buffer pool, size = 107.0M 160126  9:11:39  InnoDB: Completed initialization of buffer pool 160126  9:11:40  InnoDB: Started; log sequence number 0 44233 160126  9:11:40 [Note] mysqld: ready for connections. Version: ‘5.1.69-community’  socket: ‘’  port: 3306  MySQL Community S erver (GPL) 4、别打开一个 dos 窗口，cd 到你 mysql 的安装目录中的 bin 目录下。 执行&gt;mysql -uroot mysql 执行&gt;mysql&gt; UPDATE user SET Password=PASSWORD(’newpassword’) where USER=’root’; mysql&gt; FLUSH PRIVILEGES; mysql&gt; quit 5、关闭 dos 窗口。 6、重启 mysql 服务（如果重启有错误，重启下机器）。 现在你可以用你的新密码登录了。</p>

            
            <p class="more">
                <a href="/2016/01/26/2019030500085/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/01/26/2019030500085/" title="mysql 安装后链接时报 1045 的错误">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/6.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/01/12/2019030500119/">
    		mysql5.7.10安装
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-01-12T04:34:14.000Z">2016-01-12</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>第一步：从官网下载mysql-5.7.10-win32.zip 或 mysql-5.7.10-winx64.zip 第二步：解压缩，在根目录下复制my-default.ini 为my.ini，在my.ini文件中，加入：skip-grant-tables（不需要密码验证，直接登录） 第三步：初始化mysql目录，bin\mysqld –initialize –user=mysql –console 第四步：记录生成data目录，还有一个随机密码，记下来。 [A temporary password is generated for root@localhost:      Af*E_Mq(N3k9   第五步：mysqld –console 启动mysql，登录mysql -uroot -p 输入刚才记录的密码，执行：set password = password(‘root’)修改密码。   my.ini代码 [mysqld] port = 3306 basedir=d:/ApacheSoftware/mysql-5.7.10-winx64 datadir=d:/ApacheSoftware/mysql-5.7.10-winx64/data max_connections=200 character-set-server=utf8 default-storage-engine=INNODB sql_mode=NO_ENGINE_SUBSTITUTION,STRICT_TRANS_TABLES</p>

            
            <p class="more">
                <a href="/2016/01/12/2019030500119/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/01/12/2019030500119/" title="mysql5.7.10安装">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/01/12/2019030500084/">
    		MySQL实现统计数据并插入数据的存储过程
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-01-12T04:33:24.000Z">2016-01-12</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>统计存储过程，这里是将统计的结果插入一个表中，后台可以有定时任务来调此存储过程。以下业务是统计仓库中商品流转情况，包括：日期、商品总数、入库数量、出库数量。 BEGIN DECLARE ES_COR_CODE VARCHAR(20); – 需要定义接收游标数据的变量 DECLARE table_ VARCHAR(50); – 遍历数据结束标志 DECLARE done INT DEFAULT FALSE; – 游标 DECLARE cur CURSOR FOR SELECT TABLE_NAME FROM (SELECT TABLE_NAME from information_schema.tables WHERE TABLE_NAME LIKE ‘%wm_item_transfer_%’ AND TABLE_SCHEMA=’wmscloud_test’ ) allTables; – 将结束标志绑定到游标 DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE; – 打开游标 OPEN cur; – 开始循环 read_loop: LOOP – 提取游标里的数据，这里只有一个，多个的话也一样； FETCH cur INTO table_; – 声明结束的时候 IF done THEN LEAVE read_loop; END IF; SET ES_COR_CODE=substring(table_,18); SET @INSERT_ITEM_TRANSFER=CONCAT(‘INSERT INTO wm_item_transfer_’,ES_COR_CODE,’ (WMIT_DATE,WMIT_STOCK_NUM,WMIT_INTO_ITEM_NUM,WMIT_OUT_ITEM_NUM) SELECT (SELECT date_sub(curdate(),interval 1 day) ) WMIT_DATE , (SELECT IFNULL(SUM(WMST_NOW_NUMBER),0) FROM wm_stock_’,ES_COR_CODE,’) WMIT_STOCK_NUM, (SELECT IFNULL(SUM(WMST_NOW_NUMBER),0) FROM wm_stock_‘,ES_COR_CODE,’ WHERE WMST_RECEIVE_DATE BETWEEN date_sub(curdate(),interval 1 day) AND NOW() ) WMIT_INTO_ITEM_NUM, (SELECT IFNULL(SUM(WMOO_OUT_NUMBER),0) FROM wm_out_order_’,ES_COR_CODE,’ where SURE_DATE BETWEEN date_sub(curdate(),interval 1 day) AND NOW() ) WMIT_OUT_ITEM_NUM’); PREPARE INSERT_ITEM_TRANSFER FROM @INSERT_ITEM_TRANSFER; EXECUTE INSERT_ITEM_TRANSFER; END LOOP; – 关闭游标 CLOSE cur; END</p>

            
            <p class="more">
                <a href="/2016/01/12/2019030500084/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/01/12/2019030500084/" title="MySQL实现统计数据并插入数据的存储过程">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/01/07/2019030500113/">
    		mysql MyISAM引擎延迟更新索引
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-01-07T05:25:10.000Z">2016-01-07</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/MyISAM/" title="MyISAM">MyISAM</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>MySQL延迟更新索引（Delayed Key Write）： 使用表创建选项DELAY_KEY_WRITE创建的myisam表，在查询结束后，不会将索引的改变数据写入磁盘，而是在内存的健缓冲区（In-memory key buffer）中缓存索引改变数据。它只会在清理缓存区，或关闭表时，才将索引块转储到磁盘。对于数据经常改变，并且使用频繁的表，这种模式大大提高了表的处理性能。 不过，如果在服务器或系统奔溃，索引将肯定损坏，并需要修复。用户可以使用脚本，如运行myisamchk工具，在重启服务器前进行修复，也可以使用自动修复（Automatic Recovery）选项进行修复（即使没有选用DELAY_KEY_WRITE选项，这些修复上的安全措施也是很有价值的）。延迟更新索引特性可以被全局配置，也可以为个别表单独配置。   <strong>MySQL数据库参数DELAY_KEY_WRITE</strong>： DELAY_KEY_WRITE是指在表关闭之前，将对表的update操作只更新数据到磁盘，而不更新索引到磁盘，把对索引的更改记录在内存。（这个选项的作用是暂时制止MySQL在该命令每插入一条新记录和每修改一条现有之后立刻对索引进行刷新，对索引的刷新将等到全部记录插入/修改完毕之后再进行） 这样MyISAM表可以使索引更新更快。在关闭表的时候一起更新索引到磁盘。   <strong>使用：</strong>1：create table的时候，指定DELAY_KEY_WRITE。 2： 当表已经存在的时候：ALTER TABLE table_name DELAY_KEY_WRITE= 1。 <strong>场景：</strong>表有update操作，duang duang的体现出优势了。因为这个参数能延迟更新索引到表关闭。经常更新一个大表的时候，可以用这个参数 <strong>小提示：</strong>当DELAY_KEY_WRITE使用的时候，如果出现重启或者掉电啥的情况，会导致在cache的索引update没来得及更新，所以必须在启动参数加上 –myisam-recover，这样在你启动mysql的时候会检查你的表并同步表和索引.或者在重启服务器之前运行myisamchk。使用该特性，应用–myisam-recover选项启动服务器，为所有MyISAM表添加自动检查。</p>

            
            <p class="more">
                <a href="/2016/01/07/2019030500113/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/01/07/2019030500113/" title="mysql MyISAM引擎延迟更新索引">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/7.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/30/2019030500068/">
    		MySQL会话锁等待关系原理
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-30T12:44:39.000Z">2015-12-30</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/会话锁/" title="会话锁">会话锁</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>会话依赖关系主要需要理解锁等待相关四张表的关系： 先查询当前会话持有哪些事务的锁和依赖哪些事务的锁，通过这两种锁就可以得到一种图关系。 <strong>一：查询当前会话持有的锁：</strong> 1.查询当前会话processlist.id 2.processlist.id对应innodb_trx表中的TRX_MYSQL_THREAD_ID，这样就可以查询到当前会话的事务id 3.到lock_waits中查询blocking_trx_id 为当前会话的事务id,这样就获得了当前会话的持有lock_id 4.根据lock_id到innodb_lock可以查询出当前会话持有锁信息。 其实如果只需要查询会话的依赖的关系不需要知道锁信息的话，到第三步就可以了，通过第三步的REQUESTING_TRX_ID来反查innodb_trx表获取trx_id，反查processlist表就可以得到被当前会话阻塞的会话列表。   <strong>二：查询当前会话正等待的锁</strong> 1.查询当前会话processlist.id 2.processlist.id对应innodb_trx表中的TRX_MYSQL_THREAD_ID，这样就可以查询到当前会话的事务id 3.到lock_waits中查询REQUESTING_TRX_ID为当前会话的事务id,这样就获得了当前会话的正等待lock_id 4.根据lock_id到innodb_lock可以查询出当前会话正在等待的锁信息。 同样，其实如果只需要查询会话的依赖的关系不需要知道锁信息的话，到第三步就可以了，通过第三步的blocking_trx_id来反查innodb_trx表获取trx_id，反查processlist表就可以得到被当前会话等待的锁被哪些会话占用了。     下面列出相关表部分表结构：</p>
<h2 id="1-INFORMATION-SCHEMA-PROCESSLIST"><a href="#1-INFORMATION-SCHEMA-PROCESSLIST" class="headerlink" title="1.INFORMATION_SCHEMA.PROCESSLIST"></a>1.INFORMATION_SCHEMA.PROCESSLIST</h2><p>  The <a href="http://dev.mysql.com/doc/refman/5.6/en/processlist-table.html" title="21.15 The INFORMATION_SCHEMA PROCESSLIST Table" target="_blank" rel="noopener"><code>PROCESSLIST</code></a> table provides information about which threads are running. <code>INFORMATION_SCHEMA</code> Name <a href="http://dev.mysql.com/doc/refman/5.6/en/show.html" title="13.7.5 SHOW Syntax" target="_blank" rel="noopener"><code>SHOW</code></a> Name Remarks</p>
<p><code>ID</code></p>
<p><code>Id</code></p>
<p>MySQL extension</p>
<p><code>USER</code></p>
<p><code>User</code></p>
<p>MySQL extension</p>
<p><code>HOST</code></p>
<p><code>Host</code></p>
<p>MySQL extension</p>
<p><code>DB</code></p>
<p><code>db</code></p>
<p>MySQL extension</p>
<p><code>COMMAND</code></p>
<p><code>Command</code></p>
<p>MySQL extension</p>
<p><code>TIME</code></p>
<p><code>Time</code></p>
<p>MySQL extension</p>
<p><code>STATE</code></p>
<p><code>State</code></p>
<p>MySQL extension</p>
<p><code>INFO</code></p>
<p><code>Info</code></p>
<p>MySQL extension</p>
<h3 id="2-The-INFORMATION-SCHEMA-INNODB-TRX-Table"><a href="#2-The-INFORMATION-SCHEMA-INNODB-TRX-Table" class="headerlink" title="2.The INFORMATION_SCHEMA INNODB_TRX Table"></a>2.The INFORMATION_SCHEMA INNODB_TRX Table</h3><p><strong>Table 21.4 INNODB_TRX Columns</strong></p>
<p>Column name Description</p>
<p><code>TRX_ID</code></p>
<p>Unique transaction ID number, internal to <code>InnoDB</code>. (Starting in MySQL 5.6, these IDs are not created for transactions that are read-only and non-locking. See <a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-performance-ro-txn.html" title="8.5.3 Optimizing InnoDB Read-Only Transactions" target="_blank" rel="noopener">Section 8.5.3, “Optimizing InnoDB Read-Only Transactions”</a>for details.)</p>
<p><code>TRX_MYSQL_THREAD_ID</code></p>
<p>MySQL thread ID. Can be used for joining with <code>PROCESSLIST</code> on <code>ID</code>. See <a href="http://dev.mysql.com/doc/refman/5.6/en/innodb-information-schema-rapidly_changing_internal_data.html#innodb-information-schema-note_inconsistency" title="14.12.2.3.1 Potential Inconsistency with PROCESSLIST Data" target="_blank" rel="noopener">Section 14.12.2.3.1, “Potential Inconsistency with PROCESSLIST Data”</a>.</p>
<p><code>TRX_REQUESTED_LOCK_ID</code></p>
<p>ID of the lock the transaction is currently waiting for (if <code>TRX_STATE</code> is<code>LOCK WAIT</code>, otherwise <code>NULL</code>). Details about the lock can be found by joining with <code>INNODB_LOCKS</code> on <code>LOCK_ID</code>.</p>
<h3 id="3-The-INFORMATION-SCHEMA-INNODB-LOCK-WAITS-Table"><a href="#3-The-INFORMATION-SCHEMA-INNODB-LOCK-WAITS-Table" class="headerlink" title="3.The INFORMATION_SCHEMA INNODB_LOCK_WAITS Table"></a>3.The INFORMATION_SCHEMA INNODB_LOCK_WAITS Table</h3><p><strong>Table 21.6 INNODB_LOCK_WAITS Columns</strong></p>
<p>Column name Description</p>
<p><code>REQUESTING_TRX_ID</code></p>
<p>ID of the requesting transaction.</p>
<p><code>REQUESTED_LOCK_ID</code></p>
<p>ID of the lock for which a transaction is waiting. Details about the lock can be found by joining with <code>INNODB_LOCKS</code> on <code>LOCK_ID</code>.</p>
<p><code>BLOCKING_TRX_ID</code></p>
<p>ID of the blocking transaction.</p>
<p><code>BLOCKING_LOCK_ID</code></p>
<p>ID of a lock held by a transaction blocking another transaction from proceeding. Details about the lock can be found by joining with <code>INNODB_LOCKS</code> on <code>LOCK_ID</code>.</p>
<h3 id="4-The-INFORMATION-SCHEMA-INNODB-LOCKS-Table"><a href="#4-The-INFORMATION-SCHEMA-INNODB-LOCKS-Table" class="headerlink" title="4.The INFORMATION_SCHEMA INNODB_LOCKS Table"></a>4.The INFORMATION_SCHEMA INNODB_LOCKS Table</h3><p><strong>Table 21.5 INNODB_LOCKS Columns</strong></p>
<p>  Column name Description</p>
<p><code>LOCK_ID</code></p>
<p>Unique lock ID number, internal to <code>InnoDB</code>. Treat it as an opaque string. Although <code>LOCK_ID</code>currently contains <code>TRX_ID</code>, the format of the data in <code>LOCK_ID</code> is not guaranteed to remain the same in future releases. Do not write programs that parse the <code>LOCK_ID</code> value.</p>
<p><code>LOCK_TRX_ID</code></p>
<p>ID of the transaction holding this lock. Details about the transaction can be found by joining with <code>INNODB_TRX</code> on <code>TRX_ID</code>.</p>

            
            <p class="more">
                <a href="/2015/12/30/2019030500068/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/30/2019030500068/" title="MySQL会话锁等待关系原理">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/0.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/28/2019030500102/">
    		MySQL的语句执行顺序
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-28T11:23:28.000Z">2015-12-28</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>MySQL的语句一共分为11步，如下图所标注的那样，最先执行的总是 FROM操作，最后执行的是LIMIT操作。其中每一个操作都会产生一张虚拟的表，这个虚拟的表作为一个处理的输入，只是这些虚拟的表对用户来说是透明 的，但是只有最后一个虚拟的表才会被作为结果返回。如果没有在语句中指定某一个子句，那么将会跳过相应的步骤。</p>
<p>Sql代码</p>
<ol>
<li>(8)SELECT (9)DISTINCT&lt;select_list&gt;</li>
<li>(1)FROM&lt;left_table&gt;</li>
<li>(3)&lt;join_type&gt;JOIN&lt;right_table&gt;</li>
<li>(2)        ON&lt;jion_condition&gt;</li>
<li>(4)WHERE&lt;where_condition&gt;</li>
<li>(5)GROUP BY&lt;group_by_list&gt;</li>
<li>(6)WITH{CUBE|ROLLUP}</li>
<li>(7)HAVING&lt;having_condition&gt;</li>
<li>(8)ORDER BY&lt;order_by_list&gt;</li>
<li>(11)LIMIT&lt;limit_member&gt;</li>
</ol>
<h2 id="下面我们来具体分析一下查询处理的每一个阶段"><a href="#下面我们来具体分析一下查询处理的每一个阶段" class="headerlink" title="下面我们来具体分析一下查询处理的每一个阶段"></a>下面我们来具体分析一下查询处理的每一个阶段</h2><ol>
<li><strong>FORM</strong>: 对FROM的左边的表和右边的表计算笛卡尔积。产生虚表VT1</li>
<li><strong>ON</strong>: 对虚表VT1进行ON筛选，只有那些符合<join-condition>的行才会被记录在虚表VT2中。</join-condition></li>
<li><strong>JOIN</strong>： 如果指定了OUTER JOIN（比如left join、 right join），那么保留表中未匹配的行就会作为外部行添加到虚拟表VT2中，产生虚拟表VT3, rug from子句中包含两个以上的表的话，那么就会对上一个join连接产生的结果VT3和下一个表重复执行步骤1~3这三个步骤，一直到处理完所有的表为 止。</li>
<li><strong>WHERE</strong>： 对虚拟表VT3进行WHERE条件过滤。只有符合<where-condition>的记录才会被插入到虚拟表VT4中。</where-condition></li>
<li><strong>GROUP BY</strong>: 根据group by子句中的列，对VT4中的记录进行分组操作，产生VT5.</li>
<li><strong>CUBE | ROLLUP</strong>: 对表VT5进行cube或者rollup操作，产生表VT6.</li>
<li><strong>HAVING</strong>： 对虚拟表VT6应用having过滤，只有符合<having-condition>的记录才会被 插入到虚拟表VT7中。</having-condition></li>
<li><strong>SELECT</strong>： 执行select操作，选择指定的列，插入到虚拟表VT8中。</li>
<li><strong>DISTINCT</strong>： 对VT8中的记录进行去重。产生虚拟表VT9.</li>
<li><strong>ORDER BY</strong>: 将虚拟表VT9中的记录按照&lt;order_by_list&gt;进行排序操作，产生虚拟表VT10.</li>
<li><strong>LIMIT</strong>：取出指定行的记录，产生虚拟表VT11, 并将结果返回。</li>
</ol>

            
            <p class="more">
                <a href="/2015/12/28/2019030500102/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/28/2019030500102/" title="MySQL的语句执行顺序">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/8.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/28/2019030500116/">
    		MySQL Timestamp的几个坑
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-28T11:21:06.000Z">2015-12-28</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/Timestamp/" title="Timestamp">Timestamp</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>问题1：一个表中，是否可以有多个timestamp的列的默认值是 now()? 可以   问题2：timestamp类型，可以为null时，默认插入是 0000-00 还是 null?  null   问题3：timestamp类型，不设置任何属性时，或者设置not null 默认插入是 0000-00 还是 null? 设置not null  插入 null就是now() 不指定值第一个now() 后面都是 0000-00-00 如果可以为null 则插入null时 才是null，不指定的话就是now() 还有一个坑就是你把timestamp调整为第一个timestamp时。他自动加上默认 current_timestamp和on update . 你把带有 default current_timestamp和 on update 的第一个字段调整到其他的timestamp后面时，原来后面的那个不变，原来的第一个属性就丢了。   问题4：replace into 在流模式和statement模式下，会不会自增ID出现问题？ 二者都不会出现问题</p>

            
            <p class="more">
                <a href="/2015/12/28/2019030500116/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/28/2019030500116/" title="MySQL Timestamp的几个坑">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/8.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/28/2019030500074/">
    		MySQL 分区表
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-28T11:05:16.000Z">2015-12-28</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/分区表/" title="分区表">分区表</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>今天统计数据的时候发现一张表使用了表分区，借此机会记录一下。 1. 什么是表分区？ 表分区，是指根据一定规则，将数据库中的一张表分解成多个更小的，容易管理的部分。从逻辑上看，只有一张表，但是底层却是由多个物理分区组成。 2. 表分区与分表的区别 分表：指的是通过一定规则，将一张表分解成多张不同的表。比如将用户订单记录根据时间成多个表。 分表与分区的区别在于：分区从逻辑上来讲只有一张表，而分表则是将一张表分解成多张表。 3. 表分区有什么好处？ 1）分区表的数据可以分布在不同的物理设备上，从而高效地利用多个硬件设备。 2）和单个磁盘或者文件系统相比，可以存储更多数据 3）优化查询。在where语句中包含分区条件时，可以只扫描一个或多个分区表来提高查询效率；涉及sum和count语句时，也可以在多个分区上并行处 理，最后汇总结果。 4）分区表更容易维护。例如：想批量删除大量数据可以清除整个分区。 5）可以使用分区表来避免某些特殊的瓶颈，例如InnoDB的单个索引的互斥访问，ext3问价你系统的inode锁竞争等。 4. 分区表的限制因素 1）一个表最多只能有1024个分区 2） MySQL5.1中，分区表达式必须是整数，或者返回整数的表达式。在MySQL5.5中提供了非整数表达式分区的支持。 3）如果分区字段中有主键或者唯一索引的列，那么多有主键列和唯一索引列都必须包含进来。即：分区字段要么不包含主键或者索引列，要么包含全部主键和索引 列。 4）分区表中无法使用外键约束 5）MySQL的分区适用于一个表的所有数据和索引，不能只对表数据分区而不对索引分区，也不能只对索引分区而不对表分区，也不能只对表的一部分数据分 区。 5. 如何判断当前MySQL是否支持分区？ 命令：show variables like ‘%partition%’ 运行结果: mysql&gt; show variables like ‘%partition%’; +——————-+——-+ | Variable_name     | Value | +——————-+——-+ | have_partitioning | YES   | +——————-+——-+ 1 row in set (0.00 sec) have_partintioning 的值为YES，表示支持分区。 6. MySQL支持的分区类型有哪些？ 1）RANGE分区：按照数据的区间范围分区 2）LIST分区：按照List中的值分区，与RANGE的区别是，range分区的区间范围值是连续的。 3）HASH分区 4）KEY分区 说明 在MySQL5.1版本中，RANGE,LIST,HASH分区要求分区键必须是INT类型，或者通过表达式返回INT类型。但KEY分区的时候，可以使 用其他类型的列（BLOB，TEXT类型除外）作为分区键。 7. Range分区 利用取值范围进行分区，区间要连续并且不能互相重叠。 语法： partition by range(exp)( //exp可以为列名或者表达式，比如to_date(created_date) partition p0 values less than(num) ) 例如： mysql&gt; create table emp( -&gt; id INTNOT null, -&gt; store_id int not null -&gt; ) -&gt; partition by range(store_id)( -&gt;   partition p0 values less than(10), -&gt;   partition p1 values less than(20) -&gt; );上面的语句创建了emp表，并根据store_id字段进行分区，小于10的值存在分区p0中，大于等于10，小于20的值存在分区p1中。 注意 每个分区都是按顺序定义的，从最低到最高。上面的语句，如果将less than(10) 和less than (20)的顺序颠倒过来，那么将报错，如下： ERROR 1493 (HY000): VALUES LESS THAN value must be strictly increasing for each partition RANGE分区存在的问题 1.range范围覆盖问题：当插入的记录中对应的分区键的值不在分区定义的范围中的时候，插入语句会失败。 上面的例子，如果我插入一条store_id = 30的记录会怎么样呢？ 我们上面分区的时候，最大值是20，如果插入一条超过20的记录，会报错: mysql&gt; insert intoemp(id,store_id)values(2,30); ERROR 1526 (HY000): Table has no partition for value 30 提示30这个值没有对应的分区。 解决办法 A. 预估分区键的值，及时新增分区。 B. 设置分区的时候，使用values less than maxvalue 子句,MAXVALUE表示最大的可能的整数值。 C. 尽量选择能够全部覆盖的字段作为分区键，比如一年的十二个月等。 2.Range分区中，分区键的值如果是NULL，将被作为一个最小值来处理。 8. LIST分区 List分区是建立离散的值列表告诉数据库特定的值属于哪个分区。 语法： partition by list(exp)( //exp为列名或者表达式 partition p0 values in (3,5)  //值为3和5的在p0分区 ) 与Range不同的是，list分区不必生命任何特定的顺序。例如： mysql&gt; create table emp1( -&gt; id int not null, -&gt; store_id int not null -&gt; ) -&gt; partition by list(store_id)( -&gt;   partition p0 values in (3,5), -&gt;   partition p1 values in (2,6,7,9) -&gt; );注意 如果插入的记录对应的分区键的值不在list分区指定的值中，将会插入失败。并且，list不能像range分区那样提供maxvalue。 9. Columns分区 MySQL5.5中引入的分区类型，解决了5.5版本之前range分区和list分区只支持整数分区的问题。 Columns分区可以细分为 range columns分区和 list columns分区，他们都支持整数，日期时间，字符串三大数据类型。（不支持text和blob类型作为分区键） columns分区还支持多列分区（这里不详细展开）。 10. Hash分区 Hash分区主要用来分散热点读，确保数据在预先确定个数的分区中尽可能平均分布。 MySQL支持两种Hash分区:常规Hash分区和线性Hash分区。 A. 常规Hash分区:使用取模算法 语法： partition by hash(store_id) partitions 4; 上面的语句，根据store_id对4取模，决定记录存储位置。 比如store_id = 234的记录，MOD(234,4)=2,所以会被存储在第二个分区。 常规Hash分区的优点和不足 优点：能够使数据尽可能的均匀分布。 缺点：不适合分区经常变动的需求。假如我要新增加两个分区，现在有6个分区，那么MOD(234,6)的结果与之前MOD(234,4)的结果就会出现不 一致，这样大部分数据就需要重新计算分区。为解决此问题，MySQL提供了线性Hash分区。 B. 线性Hash分区：分区函数是一个线性的2的幂的运算法则。 语法： partition by LINER hash(store_id) partitions 4; 与常规Hash的不同在于，“Liner”关键字。 算法介绍: 假设要保存记录的分区编号为N,num为一个非负整数,表示分割成的分区的数量，那么N可以通过以下步骤得到： Step 1. 找到一个大于等于num的2的幂，这个值为V，V可以通过下面公式得到： V = Power(2,Ceiling(Log(2,num))) 例如：刚才设置了4个分区，num=4，Log(2,4)=2,Ceiling(2)=2,power(2,2)=4,即V=4 Step 2. 设置N=F(column_list)&amp;(V-1) 例如：刚才V=4，store_id=234对应的N值，N = 234&amp;（4-1） =2 Step 3. 当N&gt;=num,设置V=Ceiling(V/2),N=N&amp;(V-1) 例如：store_id=234,N=2&lt;4,所以N就取值2，即可。 假设上面算出来的N=5，那么V=Ceiling(4/2)=2,N=5&amp;(2-1)=1,即在第一个分区。 线性Hash的优点和不足 优点：在分区维护（增加，删除，合并，拆分分区）时，MySQL能够处理得更加迅速。 缺点：与常规Hash分区相比，线性Hash各个分区之间的数据分布不太均衡。 11. Key分区 类似Hash分区，Hash分区允许使用用户自定义的表达式，但Key分区不允许使用用户自定义的表达式。Hash仅支持整数分区，而Key分区支持除了Blob和text的其他类型的列作为分区键。 语法: partition by key(exp) partitions 4;//exp是零个或多个字段名的列表 key分区的时候，exp可以为空，如果为空，则默认使用主键作为分区键，没有主键的时候，会选择非空惟一键作为分区键。 12. 子分区 分区表中对每个分区再次分割，又成为复合分区。 13. 分区对于NULL值的处理 MySQ允许分区键值为NULL，分区键可能是一个字段或者一个用户定义的表达式。一般情况下，MySQL在分区的时候会把NULL值当作零值或者一个最小值进行处理。 注意 Range分区中：NULL值被当作最小值来处理 List分区中：NULL值必须出现在列表中，否则不被接受 Hash/Key分区中：NULL值会被当作零值来处理 14. 分区管理 分区管理包括对于分区的增加，删除，以及查询。 1.增加分区： 对于Range分区和LIst分区来说： alter table table_name add partition (partition p0 values …(exp)) values后面的内容根据分区的类型不同而不同。 对于Hash分区和Key分区来说： altertable table_name addpartition partitions 8; 上面的语句，指的是新增8个分区 。 2.删除分区 对于Range分区和List分区： altertable table_name droppartition p0; //p0为要删除的分区名称 删除了分区，同时也将删除该分区中的所有数据。同时，如果删除了分区导致分区不能覆盖所有值，那么插入数据的时候会报错。 对于Hash和Key分区： altertable table_name coalescepartition2; //将分区缩减到2个 coalesce [ˌkəʊəˈles] vi. 联合，合并 3.分区查询 1）查询某张表一共有多少个分区 mysql&gt; select -&gt;   partition_name, -&gt;   partition_expression, -&gt;   partition_description, -&gt;   table_rows -&gt; from -&gt;   INFORMATION_SCHEMA.partitions -&gt; where -&gt;   table_schema=’test’ -&gt;   and table_name = ‘emp’; +—————-+———————-+———————–+————+ | partition_name | partition_expression | partition_description | table_rows | +—————-+———————-+———————–+————+ | p0             | store_id             | 10                    |          0 | | p1             | store_id             | 20                    |          1 | +—————-+———————-+———————–+————+ 即，可以从information_schema.partitions表中查询。 2）查看执行计划，判断查询数据是否进行了分区过滤 mysql&gt; explain partitions select <em> from emp where store_id=10 \G; <strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> id: 1 select_type: SIMPLE table: emp partitions: p1 type: system possible_keys: NULL key: NULL key_len: NULL ref: NULL rows: 1 Extra: 1 row in set (0.00 sec) 上面的结果：partitions:p1 表示数据在p1分区进行检索。 [参考资料] 《深入MySQL数据库开发、优化与管理维护（第2版）》 《高性能MySQL》</p>

            
            <p class="more">
                <a href="/2015/12/28/2019030500074/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/28/2019030500074/" title="MySQL 分区表">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/8.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/28/2019030500108/">
    		MYSQL通过SQL脚本创建存储过程(游标删除多表数据)
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-28T11:02:37.000Z">2015-12-28</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/SQL/" title="SQL">SQL</a> / 
    
        <a href="/tags/游标/" title="游标">游标</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>首先描述一下业务处理存储过程功能：删除除系统管理员创建的角色和对应的业务表数据。 [size=medium]</p>
<p>Sql代码</p>
<ol>
<li>–  CALL P_INTSYS(‘%_10006%’,’10006’);</li>
<li><p>drop procedure if exists wmscloud_test.P_INTSYS;</p>
</li>
<li><p>CREATE PROCEDURE wmscloud_test.P_INTSYS(IN likeTableName VARCHAR(30),IN esCorCode VARCHAR(30))</p>
</li>
<li><p>BEGIN</p>
</li>
<li><p>– 需要定义接收游标数据的变量 </p>
</li>
<li>DECLARE table_ VARCHAR(50);</li>
<li>– 遍历数据结束标志</li>
<li>DECLARE done INT DEFAULT FALSE;</li>
<li>– 游标</li>
<li>DECLARE cur CURSOR FOR SELECT TABLE_NAME FROM (SELECT TABLE_NAME from information_schema.tables WHERE TABLE_NAME LIKE likeTableName ) allTables;</li>
<li>– 将结束标志绑定到游标</li>
<li>DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;</li>
<li>– 打开游标</li>
<li>OPEN cur;</li>
<li>– 开始循环</li>
<li><p>read_loop: LOOP</p>
</li>
<li><p>– 提取游标里的数据，这里只有一个，多个的话也一样；</p>
</li>
<li>FETCH cur INTO table_;</li>
<li>– 声明结束的时候</li>
<li>IF done THEN</li>
<li>LEAVE read_loop;</li>
<li><p>END IF;</p>
</li>
<li><p>– 这里做你想做的循环的事件</p>
</li>
<li>SET @delete_table=CONCAT(‘ DELETE FROM ‘,table_,’;’);</li>
<li>PREPARE delete_table FROM @delete_table;</li>
<li><p>EXECUTE delete_table;</p>
</li>
<li><p>END LOOP;</p>
</li>
<li>– 关闭游标</li>
<li><p>CLOSE cur;</p>
</li>
<li><p>– 删除,除去系统管理员创建的外其余用户和角色</p>
</li>
<li>SET @delete_table=CONCAT(‘ DELETE FROM es_user WHERE CREATOR!=1 and ES_COR_CODE=’,esCorCode);</li>
<li>PREPARE delete_table FROM @delete_table;</li>
<li><p>EXECUTE delete_table;</p>
</li>
<li><p>SET @delete_table=CONCAT(‘ DELETE FROM es_role WHERE CREATOR!=1 and ES_COR_CODE=’,esCorCode);</p>
</li>
<li>PREPARE delete_table FROM @delete_table;</li>
<li><p>EXECUTE delete_table;</p>
</li>
<li><p>END</p>
</li>
</ol>
<p>[/size] 执行脚本生成的函数</p>
<p>Sql代码</p>
<ol>
<li><p>[size=medium]BEGIN</p>
</li>
<li><p>– 需要定义接收游标数据的变量 </p>
</li>
<li>DECLARE table_ VARCHAR(50);</li>
<li>– 遍历数据结束标志</li>
<li>DECLARE done INT DEFAULT FALSE;</li>
<li>– 游标</li>
<li>DECLARE cur CURSOR FOR SELECT TABLE_NAME FROM (SELECT TABLE_NAME from information_schema.tables WHERE TABLE_NAME LIKE likeTableName ) allTables;</li>
<li>– 将结束标志绑定到游标</li>
<li>DECLARE CONTINUE HANDLER FOR NOT FOUND SET done = TRUE;</li>
<li>– 打开游标</li>
<li>OPEN cur;</li>
<li>– 开始循环</li>
<li><p>read_loop: LOOP</p>
</li>
<li><p>– 提取游标里的数据，这里只有一个，多个的话也一样；</p>
</li>
<li>FETCH cur INTO table_;</li>
<li>– 声明结束的时候</li>
<li>IF done THEN</li>
<li>LEAVE read_loop;</li>
<li><p>END IF;</p>
</li>
<li><p>– 这里做你想做的循环的事件</p>
</li>
<li>SET @delete_table=CONCAT(‘ DELETE FROM ‘,table_,’;’);</li>
<li>PREPARE delete_table FROM @delete_table;</li>
<li><p>EXECUTE delete_table;</p>
</li>
<li><p>END LOOP;</p>
</li>
<li>– 关闭游标</li>
<li><p>CLOSE cur;</p>
</li>
<li><p>– 删除,除去系统管理员创建的外其余用户和角色</p>
</li>
<li>SET @delete_table=CONCAT(‘ DELETE FROM es_user WHERE CREATOR!=1 and ES_COR_CODE=’,esCorCode);</li>
<li>PREPARE delete_table FROM @delete_table;</li>
<li><p>EXECUTE delete_table;</p>
</li>
<li><p>SET @delete_table=CONCAT(‘ DELETE FROM es_role WHERE CREATOR!=1 and ES_COR_CODE=’,esCorCode);</p>
</li>
<li>PREPARE delete_table FROM @delete_table;</li>
<li><p>EXECUTE delete_table;</p>
</li>
<li><p>END[/size]</p>
</li>
</ol>

            
            <p class="more">
                <a href="/2015/12/28/2019030500108/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/28/2019030500108/" title="MYSQL通过SQL脚本创建存储过程(游标删除多表数据)">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/8.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <a class="extend prev" rel="prev" href="/tags/MySQL/">前一页</a><a class="page-number" href="/tags/MySQL/">1</a><span class="page-number current">2</span><a class="page-number" href="/tags/MySQL/page/3/">3</a><a class="page-number" href="/tags/MySQL/page/4/">4</a><span class="space">&hellip;</span><a class="page-number" href="/tags/MySQL/page/8/">8</a><a class="extend next" rel="next" href="/tags/MySQL/page/3/">后一页</a>
    </nav>
    


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/MySQL/">MySQL</a>
        <span class="badge">(92)</span>
    </li>
    
    <li>
        <a href="/categories/Oracle/">Oracle</a>
        <span class="badge">(40)</span>
    </li>
    
    <li>
        <a href="/categories/开发语言/">开发语言</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/">NOSQL</a>
        <span class="badge">(17)</span>
    </li>
    
    <li>
        <a href="/categories/其他数据库/">其他数据库</a>
        <span class="badge">(4)</span>
    </li>
    
    <li>
        <a href="/categories/SQL-Server/">SQL Server</a>
        <span class="badge">(13)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/">Oracle</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/SQL-Server/">SQL Server</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/开发语言/">开发语言</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/MySQL/" title="MySQL">MySQL (71)</a>
  
    <a class="tag-item" href="/tags/位运算/" title="位运算">位运算 (0)</a>
  
    <a class="tag-item" href="/tags/sqlplus/" title="sqlplus">sqlplus (1)</a>
  
    <a class="tag-item" href="/tags/allow/" title="allow">allow (1)</a>
  
    <a class="tag-item" href="/tags/Apache/" title="Apache">Apache (1)</a>
  
    <a class="tag-item" href="/tags/deny/" title="deny">deny (1)</a>
  
    <a class="tag-item" href="/tags/CentOS/" title="CentOS">CentOS (2)</a>
  
    <a class="tag-item" href="/tags/druid/" title="druid">druid (1)</a>
  
    <a class="tag-item" href="/tags/心跳/" title="心跳">心跳 (1)</a>
  
    <a class="tag-item" href="/tags/事务/" title="事务">事务 (5)</a>
  
    <a class="tag-item" href="/tags/分布式/" title="分布式">分布式 (1)</a>
  
    <a class="tag-item" href="/tags/消息/" title="消息">消息 (1)</a>
  
    <a class="tag-item" href="/tags/redis/" title="redis">redis (6)</a>
  
    <a class="tag-item" href="/tags/KeepAlived/" title="KeepAlived">KeepAlived (1)</a>
  
    <a class="tag-item" href="/tags/Oracle/" title="Oracle">Oracle (30)</a>
  
    <a class="tag-item" href="/tags/schedule-job/" title="schedule job">schedule job (1)</a>
  
    <a class="tag-item" href="/tags/分库/" title="分库">分库 (1)</a>
  
    <a class="tag-item" href="/tags/分库分表/" title="分库分表">分库分表 (1)</a>
  
    <a class="tag-item" href="/tags/分表/" title="分表">分表 (1)</a>
  
    <a class="tag-item" href="/tags/SQL/" title="SQL">SQL (17)</a>
  
    <a class="tag-item" href="/tags/批量/" title="批量">批量 (1)</a>
  
    <a class="tag-item" href="/tags/数据库/" title="数据库">数据库 (7)</a>
  
    <a class="tag-item" href="/tags/结构同步/" title="结构同步">结构同步 (1)</a>
  
    <a class="tag-item" href="/tags/truncate/" title="truncate">truncate (1)</a>
  
    <a class="tag-item" href="/tags/Excel/" title="Excel">Excel (1)</a>
  
    <a class="tag-item" href="/tags/Sqlite/" title="Sqlite">Sqlite (1)</a>
  
    <a class="tag-item" href="/tags/Hash索引/" title="Hash索引">Hash索引 (1)</a>
  
    <a class="tag-item" href="/tags/InnoDB/" title="InnoDB">InnoDB (3)</a>
  
    <a class="tag-item" href="/tags/MyISAM/" title="MyISAM">MyISAM (3)</a>
  
    <a class="tag-item" href="/tags/索引优化/" title="索引优化">索引优化 (1)</a>
  
    <a class="tag-item" href="/tags/Linux/" title="Linux">Linux (2)</a>
  
    <a class="tag-item" href="/tags/FineReport/" title="FineReport">FineReport (1)</a>
  
    <a class="tag-item" href="/tags/报表/" title="报表">报表 (1)</a>
  
    <a class="tag-item" href="/tags/数据集/" title="数据集">数据集 (1)</a>
  
    <a class="tag-item" href="/tags/rowid/" title="rowid">rowid (2)</a>
  
    <a class="tag-item" href="/tags/重复/" title="重复">重复 (1)</a>
  
    <a class="tag-item" href="/tags/Character-set/" title="Character set">Character set (1)</a>
  
    <a class="tag-item" href="/tags/NLS-LANG/" title="NLS_LANG">NLS_LANG (1)</a>
  
    <a class="tag-item" href="/tags/mysqldump/" title="mysqldump">mysqldump (2)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="http://www.devba.com" target="_blank" title="软件开发吧">软件开发吧</a>
        </li>
    
        <li>
            <a href="https://www.sqlyun.cn" target="_blank" title="SQL云笔记">SQL云</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>