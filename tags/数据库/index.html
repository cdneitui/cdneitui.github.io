<!doctype html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8">
    <meta name="baidu-site-verification" content="dIcXMeY8Ya">
    
    <title>`数据库`标签下的文章 | 软件开发吧</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="keywords" content="SQL云,SQL云开发,SQL笔记,SQL开发,云开发,MySQL,Oralce,数据库,数据库云,数据库开发,数据库云开发,SQL教程,数据库教程,开发笔记,MySQL笔记,MySQL教程">
    <meta name="description" content="为满足广大程序猿兄弟对日常工作中学习数据库、使用使用数据库资料查询需求，SQL云开发免费将自己整理的各种数据库技术资料分享出来，并希望与广大猿兄一起讨论学习与进步,致力于一起更方便、快捷资料学习查询,实现更安全、高效的数据存储.">

    
    <link rel="alternative" href="/atom.xml" title="软件开发吧" type="application/atom+xml">
    
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
</html>
<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">软件开发吧</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/tags/数据库/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/tags/数据库/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/tags/数据库/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/tags/数据库/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/sxyyhj" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.coding.me" target="_blank">Hosted by Coding Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon">
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 按标签分类 -->

    <h3 class="widget-hd">
        <strong>
            
                `数据库`标签下的文章
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/16/2019030500100/">
    		MySQL数据库调优分享
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-16T03:13:15.000Z">2015-12-16</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/数据库/" title="数据库">数据库</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>日常的困扰 *<em>反映查询某个数据越来越慢，怎么办？ 数据库监控页面显示某个操作频繁执行，每次执行都非常耗时，怎么办？ 1.Sql优化 2.合理使用索引 一、sql优化—常用方法 1）not in 子查询优化 2）模糊匹配 like ‘%abc%’ 3）limit分页优化 4）count(</em>)统计数据如何加快速度 5）or条件如何优化 6）用where子句代替having子句 1、not in 子查询优化 SELECT count(<em>) FROM t_cps t1  where t1.flag&gt;=2 and  sample_md5 not in (select sample_hash from t_sfa_sample  t2 where t2.sample_hash=t1.sample_md5); -1052661行记录 33.530s SELECT count(</em>) FROM t_cps t1  where t1.flag&gt;=2 and not exists(select sample_hash from t_sfa_sample   t2 where t2.sample_hash=t1.sample_md5); -1052661行记录 18.617s SELECT count(<em>) FROM t_cps t1 left join t_sfa_sample t2 on t1.sample_md5=t2.sample_hash where t1.flag&gt;=2  and t2.sample_hash is null; -1052661行记录 14.544s 生产环境中，尽量避免使用子查询，可用表连接join代替。可避免mysql在内存中创建临时表 in和exists SELECT count(</em>) FROM t_cps t1  where t1.flag&gt;=2 and  sample_md5  in (select sample_hash  from t_sfa_sample   t2 where t2.sample_hash=t1.sample_md5); 1227992行记录 30.762s SELECT count(<em>) FROM t_cps t1  where t1.flag&gt;=2 and  exists (select sample_hash from t_sfa_sample   t2 where t2.sample_hash=t1.sample_md5); 1227992行记录 15.581s in和exists执行时: in是先执行子查询中的查询，然后再执行主查询。 exists是先执行主查询，即外层表的查询，然后再执行子查询 exists 和 in 在执行时效率单从执行时间来说差不多，exists要稍微优于in。在使用时一般应该是用exists而不用in 而在not in 和 not exists比较时，not exists的效率要比not in的效率要高。 但也有少数时候并非如此。 建议是尽量多使用exists和not exists，少用in 和not in 2、模糊匹配 like ‘%abc%’ mysql&gt; explain select </em> from update_log_test where msg like ‘e%’; +—-+————-+—————–+——-+—————+———+———+——+——+———————–+ | id | select_type | table           | type  | possible_keys | key     | key_len | ref  | rows | Extra                 | +—-+————-+—————–+——-+—————+———+———+——+——+———————–+ |  1 | SIMPLE      | update_log_test | range | idx_msg       | idx_msg | 768     | NULL |    1 | Using index condition | +—-+————-+—————–+——-+—————+———+———+——+——+———————–+ 1 row in set (0.00 sec) mysql&gt; explain select <em> from update_log_test where msg like ‘%e%’; +—-+————-+—————–+——+—————+——+———+——+——+————-+ | id | select_type | table           | type | possible_keys | key  | key_len | ref  | rows | Extra       | +—-+————-+—————–+——+—————+——+———+——+——+————-+ |  1 | SIMPLE      | update_log_test | ALL  | NULL          | NULL | NULL    | NULL |    4 | Using where | +—-+————-+—————–+——+—————+——+———+——+——+————-+ 1 row in set (0.00 sec) like ‘abc%’可以用到索引，但like‘%abc%’却不行。 SELECT </em> FROM books  WHERE name like “MySQL%” ; 但是如果换用下面的查询，返回的结果一样，但速度就要快上很多： SELECT <em> FROM books  WHERE name&gt;=”MySQL”and name&lt;”MySQM” ; 补充：explain列的解释 table  显示这一行的数据是关于哪张表的 type   这是重要的列，显示连接使用了何种类型。从最好到最差的连接类型为const、eq_reg、ref、range、index和ALL possible_keys  显示可能应用在这张表中的索引。如果为空，没有可能的索引。 key 实际使用的索引。如果为NULL，则没有使用索引。很少的情况下，MYSQL会选择优化不足的索引。这种情况下，可以在SELECT语句中使用USE INDEX（indexname）来强制使用一个索引或者用IGNORE INDEX（indexname）来强制MYSQL忽略索引 key_len  使用的索引的长度。在不损失精确性的情况下，长度越短越好 ref     显示索引的哪一列被使用了，显示了哪些字段或者常量被用来和 key配合从表中查询记录出来。 rows   MYSQL认为必须检查的用来返回请求数据的行数 Extra  关于MYSQL如何解析查询的额外信息。这里可以看到的坏的例子是Using temporary和Using filesort，意思MYSQL根本不能使用索引，检索会很慢 type不同连接类型的解释（按照效率高低的顺序排序） const   索引可以是主键或惟一索引，因为只有一行，这个值实际就是常数，因为MYSQL先读这个值然后把它当做常数来对待 mysql&gt; explain select </em> from update_log_20141111 where id=2; +—-+————-+———————+——-+—————+———+———+——-+——+——-+ | id | select_type | table               | type  | possible_keys | key     | key_len | ref   | rows | Extra | +—-+————-+———————+——-+—————+———+———+——-+——+——-+ |  1 | SIMPLE      | update_log_20141111 | const | PRIMARY       | PRIMARY | 4       | const |    1 | NULL  | +—-+————-+———————+——-+—————+———+———+——-+——+——-+ eq_ref     从前面的表中，对每一个记录的联合都从表中读取一个记录，它在查询使用了索引为主键或惟一键的全部时使用 mysql&gt; explain select <em> from t1,t2 where t1.id=t2.id; +—-+————-+——-+——–+—————+———+———+————+——+——-+ | id | select_type | table | type   | possible_keys | key     | key_len | ref        | rows | Extra | +—-+————-+——-+——–+—————+———+———+————+——+——-+ |  1 | SIMPLE      | t2    | ALL    | PRIMARY       | NULL    | NULL    | NULL       |    9 | NULL  | |  1 | SIMPLE      | t1    | eq_ref | PRIMARY       | PRIMARY | 4       | test.t2.id |    1 | NULL  | +—-+————-+——-+——–+—————+———+———+————+——+——-+ 2 rows in set (0.00 sec) ref      只有在查询使用了不是惟一或主键的键或者是这些类型的部分（比如，利用最左边前缀）时发生。对于之前的表的每一个行联合，全部记录都将从表中读出。这个类型严重依赖于根据索引匹配的记录多少—越少越好 mysql&gt; explain select </em> from update_log_20141110 t1,update_log_test t2 where t1.action=t2.action; +—-+————-+——-+——+—————+———-+———+—————-+——+————-+ | id | select_type | table | type | possible_keys | key      | key_len | ref            | rows | Extra       | +—-+————-+——-+——+—————+———-+———+—————-+——+————-+ |  1 | SIMPLE      | t1    | ALL  | i_action      | NULL     | NULL    | NULL           |    2 | Using where | |  1 | SIMPLE      | t2    | ref  | i_action      | i_action | 2       | test.t1.action |    1 | NULL        | +—-+————-+——-+——+—————+———-+———+—————-+——+————-+ 2 rows in set (0.00 sec) range   返回一个范围中的行，比如使用&gt;或&lt;查找东西时 mysql&gt; explain select <em> from t1 where id&gt;=9900 order by id limit 10; +—-+————-+——-+——-+—————+———+———+——+——+————-+ | id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       | +—-+————-+——-+——-+—————+———+———+——+——+————-+ |  1 | SIMPLE      | t1    | range | PRIMARY       | PRIMARY | 4       | NULL |  101 | Using where | +—-+————-+——-+——-+—————+———+———+——+——+————-+ 1 row in set (0.00 sec) index   对前面的表中的每一个记录联合进行完全扫描（比ALL更好，因为索引一般小于表数据） ALL      对每一个记录联合进行完全扫描，这一般比较糟糕，应该尽量避免 Extra 列返回的描述的意义 Distinct  一旦MYSQL找到了与行相联合匹配的行，就不再搜索了 Not exists  MYSQL优化了LEFT JOIN，一旦它找到了匹配LEFT JOIN标准的行，就不再搜索 Record（index map:#）没有找到理想的索引，因此对于从前面表中来的每一个行组合，MYSQL检查使用哪个索引，并用它来从表中返回行。这是使用索引的最慢的连接之一 Using filesort   看到这个的时候，查询就需要优化了。MYSQL需要进行额外的步骤来发现如何对返回的行排序。它根据连接类型以及存储排序键值和匹配条件的全部行的行指针来排序全部行 Using index  列数据是从仅仅使用了索引中的信息而没有读取实际的行动的表返回的，这发生在对表的全部的请求列都是同一个索引的部分的时候 Using temporary 看到这个的时候，查询需要优化了。这里，MYSQL需要创建一个临时表来存储结果，这通常发生在对不同的列集进行ORDER BY上，而不是GROUP BY上 Using where 使用了WHERE从句来限制哪些行将与下一张表匹配或者是返回给用户。如果不想返回表中的全部行，并且连接类型ALL或index，这就会发生，或者是查询有问题 3、limit分页优化 Select  </em> from t1 order by id limit 9900,10; 上面的语句，虽然用到了id索引，但是从第一行开始起定位至9900行，然后再扫描后10行，相当于进行了一次全扫描，显然效率不高。 Select <em> from t1 where id&gt;=9900 order by id limit 10; 利用id索引直接定位到9900行，然后在扫描出后10行，相当于一个range范围扫描 mysql&gt; explain select  </em> from t1 order by id limit 9900,10; +—-+————-+——-+——-+—————+———+———+——+——+——-+ | id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra | +—-+————-+——-+——-+—————+———+———+——+——+——-+ |  1 | SIMPLE      | t1    | index | NULL          | PRIMARY | 4       | NULL | 9910 | NULL  | +—-+————-+——-+——-+—————+———+———+——+——+——-+ 1 row in set (0.00 sec) mysql&gt; explain select <em> from t1 where id&gt;=9900 order by id limit 10; +—-+————-+——-+——-+—————+———+———+——+——+————-+ | id | select_type | table | type  | possible_keys | key     | key_len | ref  | rows | Extra       | +—-+————-+——-+——-+—————+———+———+——+——+————-+ |  1 | SIMPLE      | t1    | range | PRIMARY       | PRIMARY | 4       | NULL |  101 | Using where | +—-+————-+——-+——-+—————+———+———+——+——+————-+ 1 row in set (0.00 sec) 4、count(</em>)统计数据如何加快速度 select count(<em>)  from update_log; select count(</em>)  from update_log  where sid&gt;=0; 利用辅助索引 select count(distinct k) from t; select count(<em>) from (select distinct k from t) tmp;  利用索引来做排重操作。 注意：innodb count（</em>）必须全表扫，而不像myisam那样有一个计数器，直接从中取出数据。Innodb必须要全表扫一次才能得到count，而且会锁表。 5、or条件如何优化 select <em> from user where name=’d’ or age=31; name和age都建立了索引，但explain发现这个or条件用不到索引。 改成union all结果集合并 select </em> from user where name=’d’ union all select <em> from user where age=31; 6、用where子句代替having子句 select </em> from user group by id having id&gt;40 limit 3; select <em> from user where id&gt;40 group by id limit 3; having只会在检索出所有记录之后才对结果集进行过滤。这个处理需要排序、总计等操作。 如果能通过where子句限制记录的数目，那就能减少这方面的开销。 SQL优化的一般步骤 1、通过 show status 命令了解各种SQL的执行频率 show status like ‘uptime’ 当前MySQL运行时间 show status like ‘com_select’ 当前MySQL执行了多少次查询 show status like ‘com_insert’ 当前MySQL执行了多少次添加 show status like ‘com_update’ 当前MySQL执行了多少次更新 show status like ‘com_delete’ 当前MySQL执行了多少次删除 show status 语法： show [session|global] status like ‘’; 如果不写 [session|global] 表示默认是 session 指取出当前窗口的执行情况 如果想看所有(mysql启动到现在)的情况 加上 global show global status like ‘com_insert’; 2、 定位执行效率较低的SQL语句 （重点select） 3、通过 explain 分析低效率的SQL语句的执行情况 4、确定问题并采取相应的优化措施 二、合理使用索引 使用索引，why? 单列索引和联合索引 字段使用函数，将不能走索引 当取出的数据量超过表中数据的20%，索引是否有效？ order by 和group by优化 全文索引 1、适当的索引对应用的性能来说至关重要。 2、索引只对select有加速作用，但对写入（insert,update、delete）操作会带来额外的开销，如果带有一个或多个索引，那么数据更新的时候，mysql也要更新各个索引。 3、并不是所有经常查询的列都适合创建索引，区分度不高的，通常走全表扫浏览会更快。例如性别，只有男女两种，就不适合。 4、一条sql只能用一个索引，如果有多个，优化器会选择最优的。 1、单列索引和联合索引 mysql&gt; create index i_s_time on update_log(server,time); 联合索引要遵循最左侧原则 mysql&gt; explain select </em> from update_log where server=’115.29.138.24’ and time=’13:00:00’; +—-+————-+————+——+—————–+———-+———+————-+——+———————–+ | id | select_type | table      | type | possible_keys   | key      | key_len | ref         | rows | Extra                 | +—-+————-+————+——+—————–+———-+———+————-+——+———————–+ |  1 | SIMPLE      | update_log | ref  | i_time,i_s_time | i_s_time | 50      | const,const |    7 | Using index condition | +—-+————-+————+——+—————–+———-+———+————-+——+———————–+ 1 row in set (0.00 sec) mysql&gt; explain select <em> from update_log where server=’115.29.138.24’; +—-+————-+————+——+—————+———-+———+——-+———+———————–+ | id | select_type | table      | type | possible_keys | key      | key_len | ref   | rows    | Extra                 | +—-+————-+————+——+—————+———-+———+——-+———+———————–+ |  1 | SIMPLE      | update_log | ref  | i_s_time      | i_s_time | 46      | const | 2653264 | Using index condition | +—-+————-+————+——+—————+———-+———+——-+———+———————–+ 1 row in set (0.00 sec) mysql&gt; explain select </em> from update_log where server=’115.29.138.24’ and client=’14.197.74.21’ and time=’13:00:00’; +—-+————-+————+——+—————–+———-+———+————-+——+————————————+ | id | select_type | table      | type | possible_keys   | key      | key_len | ref         | rows | Extra                              | +—-+————-+————+——+—————–+———-+———+————-+——+————————————+ |  1 | SIMPLE      | update_log | ref  | i_time,i_s_time | i_s_time | 50      | const,const |    7 | Using index condition; Using where | +—-+————-+————+——+—————–+———-+———+————-+——+————————————+ 1 row in set (0.00 sec) mysql&gt; explain select <em> from update_log where  time=’13:00:00’; +—-+————-+————+——+—————+——+———+——+———-+————-+ | id | select_type | table      | type | possible_keys | key  | key_len | ref  | rows     | Extra       | +—-+————-+————+——+—————+——+———+——+———-+————-+ |  1 | SIMPLE      | update_log | ALL  | NULL          | NULL | NULL    | NULL | 21615394 | Using where | +—-+————-+————+——+—————+——+———+——+———-+————-+ 1 row in set (0.00 sec) 2、字段使用函数，将不能走索引 –mysql目前还不支持函数索引 mysql&gt; explain select </em> from update_log where year(date)&lt;2014; +—-+————-+————+——+—————+——+———+——+———-+————-+ | id | select_type | table      | type | possible_keys | key  | key_len | ref  | rows     | Extra       | +—-+————-+————+——+—————+——+———+——+———-+————-+ |  1 | SIMPLE      | update_log | ALL  | NULL          | NULL | NULL    | NULL | 21615394 | Using where | +—-+————-+————+——+—————+——+———+——+———-+————-+ 1 row in set (0.00 sec) 在where后面的查询条件字段使用了date()函数，是不会用到索引的。 mysql&gt; explain select <em> from update_log where date&lt;’2014-01-01’; +—-+————-+————+——-+—————+——+———+——+——+———————–+ | id | select_type | table      | type  | possible_keys | key  | key_len | ref  | rows | Extra                 | +—-+————-+————+——-+—————+——+———+——+——+———————–+ |  1 | SIMPLE      | update_log | range | date          | date | 4       | NULL |    1 | Using index condition | +—-+————-+————+——-+—————+——+———+——+——+———————–+ 1 row in set (0.00 sec) 同样的情形也会发生在对数值型字段进行计算的时候： SELECT </em> FROM t1  WHERE Amount/7&lt;24; SELECT <em> FROM t1  WHERE Amount&lt;24\</em>7; 3、无引号导致全表扫描，无法使用索引 mysql&gt; explain select * from update_log_test where msg=123; +—-+————-+—————–+——+—————+——+———+——+——+————-+ | id | select_type | table           | type | possible_keys | key  | key_len | ref  | rows | Extra       | +—-+————-+—————–+——+—————+——+———+——+——+————-+ |  1 | SIMPLE      | update_log_test | ALL  | i_msg         | NULL | NULL    | NULL |    4 | Using where | +—-+————-+—————–+——+—————+——+———+——+——+————-+ 1 row in set (0.00 sec) mysql&gt; explain select <em> from update_log_test where msg=’yoyo’; +—-+————-+—————–+——+—————+——-+———+——-+——+———————–+ | id | select_type | table           | type | possible_keys | key   | key_len | ref   | rows | Extra                 | +—-+————-+—————–+——+—————+——-+———+——-+——+———————–+ |  1 | SIMPLE      | update_log_test | ref  | i_msg         | i_msg | 768     | const |    1 | Using index condition | +—-+————-+—————–+——+—————+——-+———+——-+——+———————–+ 由于msg是varchar类型，因此查询的时候，必须加‘’ 数字当字符类型使用时，也一定要加上。 4、当取出的数据量超过表中数据的20%，优化器认为全表扫更快，不会走索引 mysql&gt; explain select </em> from update_log where time&lt;’14:00:00’; +—-+————-+————+——+—————+——+———+——+———-+————-+ | id | select_type | table      | type | possible_keys | key  | key_len | ref  | rows     | Extra       | +—-+————-+————+——+—————+——+———+——+———-+————-+ |  1 | SIMPLE      | update_log | ALL  | i_time        | NULL | NULL    | NULL | 21615394 | Using where | +—-+————-+————+——+—————+——+———+——+———-+————-+ 1 row in set (0.00 sec) mysql&gt; explain select <em> from update_log where time&lt;’14:00:00’ and time&gt;’13:00:00’; +—-+————-+————+——-+—————+——–+———+——+———+———————–+ | id | select_type | table      | type  | possible_keys | key    | key_len | ref  | rows    | Extra                 | +—-+————-+————+——-+—————+——–+———+——+———+———————–+ |  1 | SIMPLE      | update_log | range | i_time        | i_time | 4       | NULL | 3013332 | Using index condition | +—-+————-+————+——-+—————+——–+———+——+———+———————–+ 1 row in set (0.00 sec) 5、order by 和group by优化 mysql&gt; explain select </em> from update_log where server=’115.29.138.24’ order by time; +—-+————-+————+——+—————+——+———+——+———-+—————————–+ | id | select_type | table      | type | possible_keys | key  | key_len | ref  | rows     | Extra                       | +—-+————-+————+——+—————+——+———+——+———-+—————————–+ |  1 | SIMPLE      | update_log | ALL  | NULL          | NULL | NULL    | NULL | 21615394 | Using where; Using filesort | +—-+————-+————+——+—————+——+———+——+———-+—————————–+ 1 row in set (0.00 sec) 创建联合索引 mysql&gt; create index i_s_time on update_log(server,time); Query OK, 0 rows affected (3 min 18.94 sec) Records: 0  Duplicates: 0  Warnings: 0 mysql&gt; explain select <em> from update_log where server=’115.29.138.24’ order by time; +—-+————-+————+——+—————+———-+———+——-+———+————————————+ | id | select_type | table      | type | possible_keys | key      | key_len | ref   | rows    | Extra                              | +—-+————-+————+——+—————+———-+———+——-+———+————————————+ |  1 | SIMPLE      | update_log | ref  | i_s_time      | i_s_time | 46      | const | 2653264 | Using index condition; Using where | +—-+————-+————+——+—————+———-+———+——-+———+————————————+ 1 row in set (0.01 sec) 如果order by 后面有多个字段排序，它们的顺序要一致，如果一个是降序，一个是升序，也会出现using filesort排序。 6、全文索引 全文索引：主要是针对文件，文本的索引，比如文章(5.6开始innodb也支持） 字段类型：char、varchar、text 全文搜索通过 MATCH() 函数完成. mysql&gt; create table articles( -&gt; id int unsigned auto_increment not null primary key, -&gt; title varchar(200), -&gt; body text, -&gt; fulltext(title,body)); Query OK, 0 rows affected (0.05 sec) mysql&gt; INSERT INTO articles VALUES -&gt; (NULL,’MySQL Tutorial’, ‘DBMS stands for DataBase …’), -&gt;  (NULL,’How To Use MySQL Efficiently’, ‘After you went through a …’), -&gt; (NULL,’Optimising MySQL’,’In this tutorial we will show …’), -&gt; (NULL,’1001 MySQL Tricks’,’1. Never run mysqld as root. 2. …’), -&gt; (NULL,’MySQL vs. YourSQL’, ‘In the following database comparison …’), -&gt; (NULL,’MySQL Security’, ‘When configured properly, MySQL …’); Query OK, 6 rows affected (0.01 sec) Records: 6  Duplicates: 0  Warnings: 0 mysql&gt; explain select </em> from articles where match(title,body) against(‘database’); +—-+————-+———-+———-+—————+——-+———+——+——+————-+ | id | select_type | table    | type     | possible_keys | key   | key_len | ref  | rows | Extra       | +—-+————-+———-+———-+—————+——-+———+——+——+————-+ |  1 | SIMPLE      | articles | fulltext | title         | title | 0       | NULL |    1 | Using where | +—-+————-+———-+———-+—————+——-+———+——+——+————-+ 1 row in set (0.00 sec) 但如果某个单词单词出现在至少全文的50%的行中，它会被列入停止字。对于大型数据集，使用这个操作最合适不过了—-一个自然语言问询不会从一个1GB 的表每隔一行返回一次。对于小型数据集，它的用处可能比较小。不是大型的数据量，就不要用他，影响插入速度 7、mysql 5.6支持explain update/delete mysql&gt; explain update update_log_test set msg=’gugu’ where id=4; +—-+————-+—————–+——-+—————+———+———+——-+——+————-+ | id | select_type | table           | type  | possible_keys | key     | key_len | ref   | rows | Extra       | +—-+————-+—————–+——-+—————+———+———+——-+——+————-+ |  1 | SIMPLE      | update_log_test | range | PRIMARY       | PRIMARY | 4       | const |    1 | Using where | +—-+————-+—————–+——-+—————+———+———+——-+——+————-+ 1 row in set (0.01 sec) mysql&gt; explain delete from update_log_test  where id=4; +—-+————-+—————–+——-+—————+———+———+——-+——+————-+ | id | select_type | table           | type  | possible_keys | key     | key_len | ref   | rows | Extra       | +—-+————-+—————–+——-+—————+———+———+——-+——+————-+ |  1 | SIMPLE      | update_log_test | range | PRIMARY       | PRIMARY | 4       | const |    1 | Using where | +—-+————-+—————–+——-+—————+———+———+——-+——+————-+ 1 row in set (0.00 sec) 8、mysql5.6优化了合并索引 mysql&gt; explain select <em> from update_log where date=’2014-11-12’ or time=’14:00:00’; +—-+————-+————+————-+—————+————-+———+——+———-+—————————————+ | id | select_type | table      | type        | possible_keys | key         | key_len | ref  | rows     | Extra                                 | +—-+————-+————+————-+—————+————-+———+——+———-+—————————————+ |  1 | SIMPLE      | update_log | index_merge | date,i_time   | date,i_time | 4,4     | NULL | 10808103 | Using union(date,i_time); Using where | +—-+————-+————+————-+—————+————-+———+——+———-+—————————————+ 1 row in set (0.01 sec) mysql&gt; explain select </em> from update_log where date=’2014-11-12’ union select * from update_log where time=’14:00:00’; +—-+————–+————+——+—————+——–+———+——-+———-+———————–+ | id | select_type  | table      | type | possible_keys | key    | key_len | ref   | rows     | Extra                 | +—-+————–+————+——+—————+——–+———+——-+———-+———————–+ |  1 | PRIMARY      | update_log | ref  | date          | date   | 4       | const | 10807697 | NULL                  | |  2 | UNION        | update_log | ref  | i_time        | i_time | 4       | const |      406 | Using index condition | | NULL | UNION RESULT | &lt;union1,2&gt; | ALL  | NULL          | NULL   | NULL    | NULL  |     NULL | Using temporary       | +—-+————–+————+——+—————+——–+———+——-+———-+———————–+ 3 rows in set (0.00 sec) 实际测试2条sql，or的执行时间是union执行时间的两倍。 1、union all 不一定就比 or及in 快，要结合实际情况分析到底使用哪种情况。 2、对于索引列来最好使用union all，因复杂的查询【包含运算等】将使or、in放弃索引而全表扫描，除非你能确定or、in会使用索引。 3、对于只有非索引字段来说你就老老实实的用or 或者in，因为 非索引字段本来要全表扫描而union all 只成倍增加表扫描的次数。 Union：对两个结果集进行并集操作，不包括重复行，同时进行默认规则的排序；Union All：对两个结果集进行并集操作，包括重复行，不进行排序； union因为要进行重复值扫描，所以效率低。</p>

            
            <p class="more">
                <a href="/2015/12/16/2019030500100/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/16/2019030500100/" title="MySQL数据库调优分享">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/6.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/11/05/2019030500030/">
    		数据库对于开发应该知道的优化操作
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-11-05T12:01:04.000Z">2015-11-05</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/数据库/" title="数据库">数据库</a> / 
    
        <a href="/tags/优化/" title="优化">优化</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p><strong>对于数据库的一些优化操作</strong> 1：<em>访问少，查询小，</em> 应用程序中，保证在实现功能的基础上，尽量减少对数据库的访问次数；通过搜索参数，尽量减少对表的访问行数,最小化结果集，从而减轻网络负担；能够分开的操作尽量分开处理，提高每次的响应速度；在数据窗口使用SQL时，尽量把使用的索引放在选择的首列；算法的结构尽量简单；在查询时，不要过多地使用通配符如： SELECT <em> FROM T1语句， 要用到几列就选择几列如：SELECT COL1,COL2 FROM T1； 在可能的情况下尽量限制尽量结果集行数如：SELECT TOP 300 COL1,COL2,COL3 FROM T1,因为某些情况下用户是不需要那么多的数据的。 不要在应用中使用数据库游标，游标是非常有用的工具，但比使用常规的、面向集的SQL语句需要更大的开销；按照特定顺序提取数据的查找。 2：<em>类型不乱用</em> 避免使用不兼容的数据类型。 例如float和int、char和varchar、binary和varbinary是不兼容的。数据类型的不兼容可能使优化器无法执行一些本来可以进行的优化操作。例如: SELECT name FROM employee WHERE salary ＞ 60000 在这条语句中,如salary字段是money型的,则优化器很难对其进行优化,因为60000 是个整型数。我们应当在编程时将整型转化成为钱币型,而不要等到运行时转化。 3：<em>避免在WHERE子句中对字段进行函数或表达式操作</em>， 这将导致引擎放弃使用索引而进行全表扫描。如： SELECT </em> FROM T1 WHERE F1/2=100 应改为: SELECT <em> FROM T1 WHERE F1=100\</em>2 SELECT * FROM RECORD WHERE SUBSTRING(CARD_NO,1,4)=’5378’ 应改为: SELECT <em> FROM RECORD WHERE CARD_NO LIKE ‘5378%’ SELECT member_number, first_name, last_name FROM members WHERE DATEDIFF(yy,datofbirth,GETDATE()) &gt; 21 应改为: SELECT member_number, first_name, last_name FROM members WHERE dateofbirth &lt; DATEADD(yy,-21,GETDATE()) 即：任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询 时要尽可能将操作移至等号右边。 4、 <em>避免使用操作符</em> 如：!=或＜＞、IS NULL或IS NOT NULL、IN ，NOT IN等这样的操作符, 因为这会使系统无法使用索引,而只能直接搜索表中的数据。例如: SELECT id FROM employee WHERE id != ‘B%’ 优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。 5、 尽量使用数字型字段，一部分开发人员和数据库管理人员喜欢把包含数值信 息的字段 设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在 处理查询和连接回逐个比较字符串中每一个字符，而对于数字型而言只需要比较一 次就够了。 6、 <em>合理使用EXISTS,NOT EXISTS子句</em> 如下所示： a.SELECT SUM(T1.C1)FROM T1 WHERE( (SELECT COUNT(</em>)FROM T2 WHERE T2.C2=T1.C2&gt;0) b.SELECT SUM(T1.C1) FROM T1WHERE EXISTS( SELECT <em> FROM T2 WHERE T2.C2=T1.C2) 两者产生相同的结果，但是后者的效率显然要高于前者。因为后者不会产生大量锁 定的表扫描或是索引扫描。 如果你想校验表里是否存在某条纪录，不要用count(</em>)那样效率很低，而且浪费服 务器资源。可以用EXISTS代替。如： IF (SELECT COUNT(<em>) FROM table_name WHERE column_name = ‘xxx’) 可以写成： IF EXISTS (SELECT </em> FROM table_name WHERE column_name = ‘xxx’) 经常需要写一个T_SQL语句比较一个父结果集和子结果集，从而找到是否存在在父 结果集中有而在子结果集中没有的记录，如： a.SELECT a.hdr_key FROM hdr_tbl a WHERE NOT EXISTS (SELECT <em> FROM dtl_tbl b WHERE a.hdr_key = b.hdr_key) b.SELECT a.hdr_key FROM hdr_tbl a LEFT JOIN dtl_tbl b ON a.hdr_key = b.hdr_key WHERE b.hdr_key IS NULL c.SELECT hdr_key FROM hdr_tbl WHERE hdr_key NOT IN (SELECT hdr_key FROM dtl_tbl) 三种写法都可以得到同样正确的结果，但是效率依次降低。 7、 尽量避免在索引过的字符数据中，使用非打头字母搜索。这也使得引擎无法 利用索引。 见如下例子： SELECT </em> FROM T1 WHERE NAME LIKE ‘%L%’ SELECT <em> FROM T1 WHERE SUBSTING(NAME,2,1)=’L’ SELECT </em> FROM T1 WHERE NAME LIKE ‘L%’ 即使NAME字段建有索引，前两个查询依然无法利用索引完成加快操作，引擎不得不 对全表所有数据逐条操作来完成任务。而第三个查询能够使用索引来加快操作。 8、<em>利用多条件查询</em> 分利用连接条件，在某种情况下，两个表之间可能不只一个的连接条件，这 时在 WHERE 子句中将连接条件完整的写上，有可能大大提高查询速度。 例： SELECT SUM(A.AMOUNT) FROM ACCOUNT A,CARD B WHERE A.CARD_NO = B.CARD_NO SELECT SUM(A.AMOUNT) FROM ACCOUNT A,CARD B WHERE A.CARD_NO = B.CARD_NO AND A.ACCOUNT_NO=B.ACCOUNT_NO 第二句将比第一句执行快得多。 9、 <em>消除对大型表行数据的顺序存取</em> 尽管在所有的检查列上都有索引，但某些形式的WHERE子句强迫优化器使用 顺序存取。如： SELECT <em> FROM orders WHERE (customer_num=104 AND order_num&gt;1001) OR order_num=1008 解决办法可以使用并集来避免顺序存取： SELECT </em> FROM orders WHERE customer_num=104 AND order_num&gt;1001 UNION SELECT <em> FROM orders WHERE order_num=1008 这样就能利用索引路径处理查询。 10、 <em>避免困难的正规表达式</em> LIKE关键字支持通配符匹配，技术上叫正规表达式。但这种匹配特别耗费时 间。例如：SELECT </em> FROM customer WHERE zipcode LIKE “98_ _ _” 即使在zipcode字段上建立了索引，在这种情况下也还是采用顺序扫描的方式。如 果把语句改为SELECT <em> FROM customer WHERE zipcode &gt;“98000”，在执行查询 时就会利用索引来查询，显然会大大提高速度。 11、 <em>使用视图加速查询</em> 把表的一个子集进行排序并创建视图，有时能加速查询。它有助于避免多重排序操作，而且在其他方面还能简化优化器的工作。例如： SELECT cust.name，rcvbles.balance，……other columns FROM cust，rcvbles WHERE cust.customer_id = rcvlbes.customer_id AND rcvblls.balance&gt;0 AND cust.postcode&gt;“98000” ORDER BY cust.name 如果这个查询要被执行多次而不止一次，可以把所有未付款的客户找出来放在一个 视图中，并按客户的名字进行排序： CREATE VIEW DBO.V_CUST_RCVLBES AS SELECT cust.name，rcvbles.balance，……other columns FROM cust，rcvbles WHERE cust.customer_id = rcvlbes.customer_id AND rcvblls.balance&gt;0 ORDER BY cust.name 然后以下面的方式在视图中查询： SELECT </em> FROM V_CUST_RCVLBES WHERE postcode&gt;“98000” 视图中的行要比主表中的行少，而且物理顺序就是所要求的顺序，减少了磁盘 I/O，所以查询工作量可以得到大幅减少。 12、 <em>能够用BETWEEN的就不要用IN</em> SELECT <em> FROM T1 WHERE ID IN (10,11,12,13,14) 改成： SELECT </em> FROM T1 WHERE ID BETWEEN 10 AND 14 因为IN会使系统无法使用索引,而只能直接搜索表中的数据。 13、 <em>DISTINCT的就不用GROUP BY</em> SELECT OrderID FROM Details WHERE UnitPrice &gt; 10 GROUP BY OrderID 可改为： SELECT DISTINCT OrderID FROM Details WHERE UnitPrice &gt; 10 14、 部分利用索引 1.SELECT employeeID, firstname, lastname FROM names WHERE dept = ‘prod’ or city = ‘Orlando’ or division = ‘food’ 2.SELECT employeeID, firstname, lastname FROM names WHERE dept = ‘prod’ UNION ALL SELECT employeeID, firstname, lastname FROM names WHERE city = ‘Orlando’ UNION ALL SELECT employeeID, firstname, lastname FROM names WHERE division = ‘food’ 如果dept 列建有索引则查询2可以部分利用索引，查询1则不能。 15、 <em>能用UNION ALL就不要用UNION</em> UNION ALL不执行SELECT DISTINCT函数，这样就会减少很多不必要的资源 16、 <em>不要写一些不做任何事的查询</em> 如：SELECT COL1 FROM T1 WHERE 1=0 SELECT COL1 FROM T1 WHERE COL1=1 AND COL1=2 这类死码不会返回任何结果集，但是会消耗系统资源。 17、 <em>尽量不要用SELECT INTO语句。</em> SELECT INTO 语句会导致表锁定，阻止其他用户访问该表。 18、 <em>必要时强制查询优化器使用某个索引</em> SELECT <em> FROM T1 WHERE nextprocess = 1 AND processid IN (8,32,45) 改成： SELECT </em> FROM T1 (INDEX = IX_ProcessID) WHERE nextprocess = 1 AND processid IN (8,32,45) 则查询优化器将会强行利用索引IX_ProcessID 执行查询。 19、 虽然UPDATE、DELETE语句的写法基本固定，但是还是对UPDATE语句给点建 议： <em>a) 尽量不要修改主键字段。 b) 当修改VARCHAR型字段时，尽量使用相同长度内容的值代替。 c) 尽量最小化对于含有UPDATE触发器的表的UPDATE操作。 d) 避免UPDATE将要复制到其他数据库的列。 e) 避免UPDATE建有很多索引的列。 f) 避免UPDATE在WHERE子句条件中的列</em>。 上面我们提到的是一些基本的提高查询速度的注意事项,但是在更多的情况下,往往 需要反复试验比较不同的语句以得到最佳方案。最好的方法当然是测试，看实现相 同功能的SQL语句哪个执行时间最少，但是数据库中如果数据量很少，是比较不出 来的，这时可以用查看执行计划，即：把实现相同功能的多条SQL语句考到查询分 析器，按CTRL+L看查所利用的索引，表扫描次数（这两个对性能影响最大），总体 上看询成本百分比即可。 简单的存储过程可以用向导自动生成：在企业管理器工具栏点击运行向导图标，点 击”数据库”、”创建存储过程向导”。复杂存储过程的调试：在查询分析器左边 的对象浏览器（没有？按F8）选择要调试的存储过程,点右键，点调试，输入参数 执行，出现一个浮动工具条，上面有单步执行，断点设置等。</p>

            
            <p class="more">
                <a href="/2015/11/05/2019030500030/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/11/05/2019030500030/" title="数据库对于开发应该知道的优化操作">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/5.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/17/2019030500039/">
    		用plsql连接数据库创建视图
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-17T09:00:26.000Z">2015-09-17</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/数据库/" title="数据库">数据库</a> / 
    
        <a href="/tags/PL-SQL/" title="PL/SQL">PL/SQL</a> / 
    
        <a href="/tags/视图/" title="视图">视图</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>1 视图介绍 视图是一个逻辑表，也是一个非常重要的方案对象。实际上，视图是查看表的一种方式。视图是对根据预定义的选择标准由一个或多个行的集合建立起来的动态表的静态定义。视图可以用来定义来自一个或多个表的行和列的多种连接。通过视图，可以查看到表中的数据。 视图是查看数据库表中的数据的一种方法。视图提供了存储预定义的查询语句作为数据库中的对象以备以后使用的能力。视图只是一种逻辑对象，是一种虚拟表，并不是物理对象，因为视图不占物理存储空间。在视图中被查询的表称为视图的基表。 通常通过它就像使用表一样访问数据。要记住通过视图引用的数据通常来自它后面的基表。视图应该使用一致的命名约定。例如，给所有的视图增加一个前缀，如每一个视图都以v_、view_或vw_开头。这样，可以使用户在看到名称时就立即知道它代表的对象是视图。 2 视图好处 使用视图的优点，如集中用户使用的数据、掩码数据的复杂性、简化权限管理以及为向其他应用程序输出而重新组织数据等。 集中用户使用的数据： 视图创建了一种可以控制的环境，即表中的一部分数据允许访问，而另外一部分数据则不允许访问。那些没有必要的，敏感的或不适合的数据都从视图中排除掉了。 掩盖数据库的复杂性： 视图把数据库设计的复杂性与用户屏蔽分开。这样就为数据库开发人员提供了一种改变数据库的设计而不影响用户使用的能力。用户只需要查询视图就可以得到所需的数据，而不用编写复杂的查询语句或者执行脚本。 简化用户权限的管理：   数据库所有者可以把视图的权限授予需要查询的用户，而不必将基表中某些列的查询权限授予用户。 3 视图创建 可以使用3种方法创建视图，一种方法是使用create view 语句，另一种方法是使用DBA studio 图形工具，还可以使用创建视图向导来创建。 使用create view 语句创建视图 create [or replace][force | noforce] view [user.] viewName (column [,column2]…) as query [with check option[Constraint constraint]] [with read only] or replace 表示如果同名的视图存在，则使用新视图替代已有的视图。 force 强制创建视图，不考虑基表是否存在，是否具有使用基表数据的权限。 noforce 只有基表存在且具有权限，才可以创建视图。 user    表示创建视图的用户名。 viewName  表示将要在数据库上创建的视图名称。 column  指定视图中的列名。 query 表示生成视图的select语句。 with check option 指定强制检查通过视图修改数据的操作。 constraint  表示指定的约束名称。 with read only： 表示创建的视图只能检索数据，不能修改数据。   <img src="/uploads/2015/09/0_1315294657xlxy.bmp" alt>   4 视图和表的关系 视图和表是两种不同的数据库对象，其中的区别之一是在修改数据方面。修改表中的数据是直接修改数据，而修改视图中的数据是间接修改数据。因为视图本身并不包含数据，修改视图中的数据就是通过视图修改表中的数据。因此，修改视图中的数据有许多特殊的限制。 <img src="/uploads/2015/09/0_1315294856I5t5.bmp" alt></p>

            
            <p class="more">
                <a href="/2015/09/17/2019030500039/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/17/2019030500039/" title="用plsql连接数据库创建视图">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/7.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/11/2019030500011/">
    		加快mydumper与myloader导出导入
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-11T04:58:23.000Z">2015-09-11</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/数据库/" title="数据库">数据库</a> / 
    
        <a href="/tags/SQL/" title="SQL">SQL</a> / 
    
        <a href="/tags/Database/" title="Database">Database</a> / 
    
        <a href="/tags/dba/" title="dba">dba</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>mydumper与myloader是一个优秀的第三方mysql数据库逻辑备份恢复工具，使用多线程的导出与导入。弥补了mysqldump单线程的不足。本文描述的是如何加快mydumper与myloader的导出与导入供大家参考。 1、基于MyIsam引擎导出导入 a、表不分块导出及导入 [root@GZAPP tmp]# mydumper -u inno -p xxx -B bsom -T tb_access_log -o /backup/tmp/ [root@GZAPP tmp]# ls -hltr   ###导出的数据文件为单个文件，大小在2.6GB total 2.6G -rw-r–r– 1 root root 1.6K Jul 24 08:51 bsom.tb_access_log-schema.sql -rw-r–r– 1 root root  214 Jul 24 08:52 metadata -rw-r–r– 1 root root 2.6G Jul 24 08:52 bsom.tb_access_log.sql ###基于缺省线程数导入，且设定每个事务查询数为10000，此参数此时其实作用不大，因为表为myisam引擎 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -d /backup/tmp -v 3 -q 10000 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -d /backup/tmp -v 3 -q 10000 <strong> Message: 4 threads created </strong> Message: Creating table `tempdb`.`tb_access_log` <strong> Message: Thread 4 shutting down </strong> Message: Thread 1 restoring `bsom`.`tb_access_log` part 0 <strong> Message: Thread 3 shutting down </strong> Message: Thread 2 shutting down root@localhost[tempdb]&gt; show processlist; +———+———+———-+——–+———+——–+———+————————————————+ | Id      | User    | Host     | db     | Command | Time   | State   | Info                                           | +———+———+———-+——–+———+——–+———+————————————————+ | 4452079 | root    | localhost| tempdb | Query   |      0 | init    | show processlist                               | | 4453793 | inno    | localhost| tempdb | Sleep   |    420 |         | NULL                                           | | 4453794 | inno    | localhost| tempdb | Query   |      4 | update  | INSERT INTO `tb_access_log` VALUES (506873,”325| +———+———+———-+——–+———+——–+———+————————————————+ ###从上面的线程数可以看出只有一个单线程在执行insert操作 b、表分块导出及导入 ###下面的示例中使用500MB进行分块 [root@GZAPP tmp]# mydumper -u inno -p xxx -B bsom -T tb_access_log -F 500 -o /backup/tmp/ [root@GZAPP tmp]# ls -hltr total 2.6G -rw-r–r– 1 root root 1.6K Jul 24 08:21 bsom.tb_access_log-schema.sql -rw-r–r– 1 root root 478M Jul 24 08:21 bsom.tb_access_log.00001.sql -rw-r–r– 1 root root 478M Jul 24 08:21 bsom.tb_access_log.00002.sql -rw-r–r– 1 root root 478M Jul 24 08:21 bsom.tb_access_log.00003.sql -rw-r–r– 1 root root 478M Jul 24 08:21 bsom.tb_access_log.00004.sql -rw-r–r– 1 root root 478M Jul 24 08:22 bsom.tb_access_log.00005.sql -rw-r–r– 1 root root  214 Jul 24 08:22 metadata -rw-r–r– 1 root root 241M Jul 24 08:22 bsom.tb_access_log.00006.sql ###由上可知，大表tb_access_log按接近500M被分割成了多个文件 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -t 6 -d /backup/tmp -v 3 <strong> Message: 6 threads created </strong> Message: Creating database `tempdb` <strong> Message: Creating table `tempdb`.`tb_access_log` </strong> Message: Thread 1 restoring `bsom`.`tb_access_log` part 3 <strong> Message: Thread 2 restoring `bsom`.`tb_access_log` part 5 </strong> Message: Thread 5 restoring `bsom`.`tb_access_log` part 4 <strong> Message: Thread 3 restoring `bsom`.`tb_access_log` part 6 </strong> Message: Thread 4 restoring `bsom`.`tb_access_log` part 1 <strong> Message: Thread 6 restoring `bsom`.`tb_access_log` part 2 #在下面的processlist可以看到，存在表级锁等待 +———+——-+———–+———+———+——–+—————————–+————————————————+ | Id      | User  | Host      | db      | Command | Time   | State                       | Info                                           | +———+——-+———–+———+———+——–+—————————–+————————————————+ | 4452079 | root  | localhost | bsom    | Query   |      0 | init                        | show processlist                               | | 4452167 | inno  | localhost | tempdb  | Sleep   |    769 |                             | NULL                                           | | 4452168 | inno  | localhost | tempdb  | Query   |     36 | update                      | INSERT INTO `tb_access_log` VALUES (6367402,”0,| | 4452169 | inno  | localhost | tempdb  | Query   |     21 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (12593865,” | | 4452170 | inno  | localhost | tempdb  | Query   |     26 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (15643029,””| | 4452171 | inno  | localhost | tempdb  | Query   |      6 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (173947,”70 | | 4452172 | inno  | localhost | tempdb  | Query   |     15 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (9490507,”7 | | 4452173 | inno  | localhost | tempdb  | Query   |     30 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (3271602,”4 | +———+———+———–+———+———+——–+—————————–+———————————————-+ c、调整myisam有关参数后导入 [root@GZ-APP-BAK01 tmp]# time myloader -u innobk -p InnoBK -B tempdb -t 6 -d /backup/tmp -v 3 </strong> Message: 6 threads created <strong> Message: Creating table `tempdb`.`tb_mobile_access_log` </strong> Message: Thread 1 restoring `blossom`.`tb_mobile_access_log` part 3 <strong> Message: Thread 6 restoring `blossom`.`tb_mobile_access_log` part 6 </strong> Message: Thread 2 restoring `blossom`.`tb_mobile_access_log` part 5 <strong> Message: Thread 3 restoring `blossom`.`tb_mobile_access_log` part 4 </strong> Message: Thread 4 restoring `blossom`.`tb_mobile_access_log` part 1 <strong> Message: Thread 5 restoring `blossom`.`tb_mobile_access_log` part 2 </strong> Message: Thread 6 shutting down <strong> Message: Thread 5 shutting down </strong> Message: Thread 1 shutting down <strong> Message: Thread 2 shutting down </strong> Message: Thread 4 shutting down <strong> Message: Thread 3 shutting down real    266m28.903s user    0m6.008s sys     0m1.681s ###调整以下相关参数，后尝试再次导入， concurrent_insert  AUTO 改成 ALWAYS bulk_insert_buffer_size 8388608 改成 256M myisam_sort_buffer_size 67108864 改成 128M [root@GZ-APP-BAK01 tmp]# time myloader -u innobk -p InnoBK -B tempdb -t 6 -o -d /backup/tmp -v 3 </strong> Message: 6 threads created <strong> Message: Dropping table (if exists) `tempdb`.`tb_mobile_access_log` </strong> Message: Creating table `tempdb`.`tb_mobile_access_log` <strong> Message: Thread 1 restoring `blossom`.`tb_mobile_access_log` part 3 </strong> Message: Thread 2 restoring `blossom`.`tb_mobile_access_log` part 6 <strong> Message: Thread 3 restoring `blossom`.`tb_mobile_access_log` part 5 </strong> Message: Thread 4 restoring `blossom`.`tb_mobile_access_log` part 4 <strong> Message: Thread 6 restoring `blossom`.`tb_mobile_access_log` part 1 </strong> Message: Thread 5 restoring `blossom`.`tb_mobile_access_log` part 2 <strong> Message: Thread 2 shutting down </strong> Message: Thread 1 shutting down <strong> Message: Thread 6 shutting down </strong> Message: Thread 5 shutting down <strong> Message: Thread 3 shutting down </strong> Message: Thread 4 shutting down real    253m42.460s   ###此时导入时间并无明显减少 user    0m5.924s sys     0m1.637s 2、基于innodb引擎的导出导入 a、表未分块导出，数据文件大小为3.9GB [root@GZAPP tmp]# ls -hltr total 3.9G -rw-r–r– 1 root root 1.8K Jul 24 00:09 bscom.tb_message-schema.sql -rw-r–r– 1 root root 3.9G Jul 24 00:25 bscom.tb_message.sql -rw-r–r– 1 root root  215 Jul 24 09:14 metadata ###下面使用6个线程导入，实际上可以看到，只有1个线程在工作，因为数据文件只有1个 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -t 6 -d /backup/tmp -v 3 <strong> Message: 6 threads created </strong> Message: Creating table `tempdb`.`tb_message` <strong> Message: Thread 1 restoring `bscom`.`tb_message` part 0 </strong> Message: Thread 5 shutting down <strong> Message: Thread 2 shutting down </strong> Message: Thread 6 shutting down <strong> Message: Thread 3 shutting down </strong> Message: Thread 4 shutting down b、表分块导出 [root@GZAPP tmp]# mydumper -u inno -p xxx -B bscom -T tb_message -F 500 -o /backup/tmp/ [root@GZAPP tmp]# ls -hltr total 3.9G -rw-r–r– 1 root root 1.8K Jul 24 09:55 bscom.tb_message-schema.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00001.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00002.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00003.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00004.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00005.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00006.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00007.sql -rw-r–r– 1 root root 481M Jul 24 09:55 bscom.tb_message.00008.sql -rw-r–r– 1 root root  135 Jul 24 09:55 metadata -rw-r–r– 1 root root  93M Jul 24 09:55 bscom.tb_message.00009.sql ###下面尝试使用6线程导入，可以看到有6个线程在并发导入 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -t 6 -d /backup/tmp/ -v 3 <strong> Message: 6 threads created </strong> Message: Creating database `tempdb` <strong> Message: Creating table `tempdb`.`tb_message` </strong> Message: Thread 2 restoring `bscom`.`tb_message` part 5 <strong> Message: Thread 1 restoring `bscom`.`tb_message` part 9 </strong> Message: Thread 3 restoring `bscom`.`tb_message` part 1 <strong> Message: Thread 4 restoring `bscom`.`tb_message` part 8 </strong> Message: Thread 5 restoring `bscom`.`tb_message` part 4 <strong> Message: Thread 6 restoring `bscom`.`tb_message` part 6 </strong> Message: Thread 1 restoring `bscom`.`tb_message` part 7 <strong> Message: Thread 6 restoring `bscom`.`tb_message` part 3 </strong> Message: Thread 2 restoring `bscom`.`tb_message` part 2 <strong> Message: Thread 3 shutting down </strong> Message: Thread 5 shutting down <strong> Message: Thread 4 shutting down </strong> Message: Thread 1 shutting down <strong> Message: Thread 2 shutting down </strong> Message: Thread 6 shutting down 3、小结 a、mydumper在导出的时候可以根据服务器可用资源来合理地设置线程数。 b、mydumper在导出的时候尽可能地指定chunk-filesize或者rows参数以分块导出。 c、myloader在针对myisam引擎时建议调整相关参数至合理值以提高无法提高性能，主要是表级锁的问题。 d、myloader在针对innodb引擎时建议调整参数至合理值以提高性能，如以下参数等： innodb_buffer_pool_size innodb_flush_log_at_trx_commit innodb_log_buffer_size e、通过使用分块导出与导入可以显著利用并发来加快inndbo表导入。 f、注意mydumper导出时不会导出存储过程，函数，触发器等。</p>

            
            <p class="more">
                <a href="/2015/09/11/2019030500011/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/11/2019030500011/" title="加快mydumper与myloader导出导入">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/01/2019030500077/">
    		mysql备份与还原
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-01T07:35:13.000Z">2015-09-01</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/数据库/" title="数据库">数据库</a> / 
    
        <a href="/tags/mysqldump/" title="mysqldump">mysqldump</a> / 
    
        <a href="/tags/mysql备份/" title="mysql备份">mysql备份</a> / 
    
        <a href="/tags/mysql还原/" title="mysql还原">mysql还原</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<h1 id="1-mysqldump"><a href="#1-mysqldump" class="headerlink" title="1.mysqldump"></a>1.mysqldump</h1><h2 id="1-1-备份方法："><a href="#1-1-备份方法：" class="headerlink" title="1.1.备份方法："></a>1.1.备份方法：</h2><p>（1）导出整个数据库并指定字符集(包括数据库中的数据）</p>
<pre><code>mysqldump -u root -p --default-character-set=utf8 dbname &gt; 存放路径 
</code></pre><p>（2）导出数据库结构（不含数据）</p>
<pre><code>mysqldump -u username -p -d dbname &gt; dbname.sql    
</code></pre><p>（3）导出数据库中的某张数据表（包含数据）</p>
<pre><code>mysqldump -u username -p dbname tablename &gt; tablename.sql    
</code></pre><p>（4）导出数据库中的某张数据表的表结构（不含数据）</p>
<pre><code>mysqldump -u username -p -d dbname tablename &gt; tablename.sql
</code></pre><h2 id="1-2-mysqldump常用参数"><a href="#1-2-mysqldump常用参数" class="headerlink" title="1.2.mysqldump常用参数"></a>1.2.mysqldump常用参数</h2><blockquote>
<p>–compatible=name 它告诉 mysqldump，导出的数据将和哪种数据库或哪个旧版本的 MySQL 服务器相兼容。值可以为 ansi、mysql323、mysql40、postgresql、oracle、mssql、db2、maxdb、no_key_options、no_tables_options、no_field_options 等，要使用几个值，用逗号将它们隔开。当然了，它并不保证能完全兼容，而是尽量兼容。</p>
<hr>
<p>–all-databases , -A 导出全部数据库mysqldump -uroot -p –all-databases</p>
<hr>
<p>–all-tablespaces , -Y导出全部表空间。mysqldump -uroot -p –all-databases</p>
<hr>
<p>–all-tablespaces–no-tablespaces , -y不导出任何表空间信息。mysqldump -uroot -p –all-databases –no-tablespaces</p>
<hr>
<p>–add-drop-database每个数据库创建之前添加drop数据库语句。mysqldump -uroot -p –all-databases –add-drop-database</p>
<hr>
<p>–add-drop-table每个数据表创建之前添加drop数据表语句。(默认为打开状态，使用–skip-add-drop-table取消选项)mysqldump -uroot -p –all-databases (默认添加drop语句)mysqldump -uroot -p –all-databases –skip-add-drop-table (取消drop语句)</p>
<hr>
<p>–add-locks在每个表导出之前增加LOCK TABLES并且之后UNLOCK TABLE。(默认为打开状态，使用–skip-add-locks取消选项)mysqldump -uroot -p –all-databases (默认添加LOCK语句)mysqldump -uroot -p –all-databases –skip-add-locks (取消LOCK语句)</p>
<hr>
<p>–comments附加注释信息。默认为打开，可以用–skip-comments取消mysqldump -uroot -p –all-databases (默认记录注释)mysqldump -uroot -p –all-databases –skip-comments (取消注释)</p>
<hr>
<p>–compact导出更少的输出信息(用于调试)。去掉注释和头尾等结构。可以使用选项：–skip-add-drop-table –skip-add-locks –skip-comments –skip-disable-keysmysqldump -uroot -p –all-databases –compact</p>
<hr>
<p>–complete-insert, -c使用完整的insert语句(包含列名称)。这么做能提高插入效率，但是可能会受到max_allowed_packet参数的影响而导致插入失败。mysqldump -uroot -p –all-databases –complete-insert</p>
<hr>
<p>–compress, -C在客户端和服务器之间启用压缩传递所有信息mysqldump -uroot -p –all-databases –compress</p>
<hr>
<p>–databases, -B导出几个数据库。参数后面所有名字参量都被看作数据库名。mysqldump -uroot -p –databases test mysql</p>
<hr>
<p>–debug输出debug信息，用于调试。默认值为：d:t:o,/tmp/mysqldump.tracemysqldump -uroot -p –all-databases –debugmysqldump -uroot -p –all-databases –debug=” d:t:o,/tmp/debug.trace”</p>
<hr>
<p>–debug-info输出调试信息并退出mysqldump -uroot -p –all-databases –debug-info</p>
<hr>
<p>–default-character-set设置默认字符集，默认值为utf8mysqldump -uroot -p –all-databases –default-character-set=latin1</p>
<hr>
<p>–delayed-insert采用延时插入方式（INSERT DELAYED）导出数据mysqldump -uroot -p –all-databases –delayed-insert</p>
<hr>
<p>–events, -E导出事件。mysqldump -uroot -p –all-databases –events</p>
<hr>
<p>–flush-logs开始导出之前刷新日志。请注意：假如一次导出多个数据库(使用选项–databases或者–all-databases)，将会逐个数据库刷新日志。除使用–lock-all-tables或者–master-data外。在这种情况下，日志将会被刷新一次，相应的所以表同时被锁定。因此，如果打算同时导出和刷新日志应该使用–lock-all-tables 或者–master-data 和–flush-logs。mysqldump -uroot -p –all-databases –flush-logs</p>
<hr>
<p>–flush-privileges在导出mysql数据库之后，发出一条FLUSH PRIVILEGES 语句。为了正确恢复，该选项应该用于导出mysql数据库和依赖mysql数据库数据的任何时候。mysqldump -uroot -p –all-databases –flush-privileges</p>
<hr>
<p>–force在导出过程中忽略出现的SQL错误。mysqldump -uroot -p –all-databases –force</p>
<hr>
<p>–host, -h需要导出的主机信息mysqldump -uroot -p –host=localhost –all-databases</p>
<hr>
<p>–ignore-table不导出指定表。指定忽略多个表时，需要重复多次，每次一个表。每个表必须同时指定数据库和表名。例如：–ignore-table=database.table1 –ignore-table=database.table2 ……mysqldump -uroot -p –host=localhost –all-databases –ignore-table=mysql.user</p>
<hr>
<p>–lock-all-tables, -x提交请求锁定所有数据库中的所有表，以保证数据的一致性。这是一个全局读锁，并且自动关闭–single-transaction 和–lock-tables 选项。mysqldump -uroot -p –host=localhost –all-databases –lock-all-tables</p>
<hr>
<p>–lock-tables, -l开始导出前，锁定所有表。用READ LOCAL锁定表以允许MyISAM表并行插入。对于支持事务的表例如InnoDB和BDB，–single-transaction是一个更好的选择，因为它根本不需要锁定表。请注意当导出多个数据库时，–lock-tables分别为每个数据库锁定表。因此，该选项不能保证导出文件中的表在数据库之间的逻辑一致性。不同数据库表的导出状态可以完全不同。mysqldump -uroot -p –host=localhost –all-databases –lock-tables</p>
<hr>
<p>–no-create-db, -n只导出数据，而不添加CREATE DATABASE 语句。mysqldump -uroot -p –host=localhost –all-databases –no-create-db</p>
<hr>
<p>–no-create-info, -t只导出数据，而不添加CREATE TABLE 语句。mysqldump -uroot -p –host=localhost –all-databases –no-create-info</p>
<hr>
<p>–no-data, -d不导出任何数据，只导出数据库表结构。mysqldump -uroot -p –host=localhost –all-databases –no-data</p>
<hr>
<p>–opt 这只是一个快捷选项，等同于同时添加 –add-drop-tables –add-locking –create-option –disable-keys –extended-insert –lock-tables –quick –set-charset 选项。本选项能让 mysqldump 很快的导出数据，并且导出的数据能很快导回。该选项默认开启，但可以用 –skip-opt 禁用。注意，如果运行 mysqldump 没有指定 –quick 或 –opt 选项，则会将整个结果集放在内存中。如果导出大数据库的话可能会出现问题</p>
</blockquote>
<h2 id="1-3-还原"><a href="#1-3-还原" class="headerlink" title="1.3.还原"></a>1.3.还原</h2><p>转载或分享请标明地址:<a href="http://blog.csdn.net/w19981220" target="_blank" rel="noopener">http://blog.csdn.net/w19981220</a> mysqldump -u用户名 -p密码 数据库 &lt; 路径 mysql -uroot -p1234 数据库名称&lt;路径 还可以使用这一种方法 首先先use 那一个数据库</p>
<pre><code>mysql&gt; source sql文件路径
</code></pre></blockquote>

            
            <p class="more">
                <a href="/2015/09/01/2019030500077/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/01/2019030500077/" title="mysql备份与还原">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/其他数据库/">其他数据库</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/14/2019030500003/">
    		Android ORMLite数据库简介
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-14T07:35:23.000Z">2015-07-14</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/数据库/" title="数据库">数据库</a> / 
    
        <a href="/tags/Android/" title="Android">Android</a> / 
    
        <a href="/tags/ORMLite/" title="ORMLite">ORMLite</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>一般的项目中，Android自身提供的SQLite数据库，可以满足轻量级的数据存储应用，但是，只要是存储模型稍微复杂的项目，以及数据结构模型复杂的应用，就很难再用SQLite支撑整个项目的数据存储。何况，使用SQLite编写的代码，代码后续维护和管理不容易，所以，上规模的项目中，很有必要引入一种更好用、对开发者更友好的第三方ORM数据库框架：ORMlite。 ORMLite官方的简介说：“Object Relational Mapping Lite (ORM Lite) provides some simple, lightweight functionality for persisting Java objects to SQL databases while avoiding the complexity and overhead of more standard ORM packages.”。 ORMLite是对象关系映射（Object Relational Mapping）数据库的一种轻量级SQL数据库的开发包（packages）。提供简单易用的DAO。 ORMLite官方主页：<a href="http://ormlite.com/" target="_blank" rel="noopener">http://ormlite.com</a> Java语言编写，支持Java，Android平台，本文重点介绍如何在Android平台的应用开发中使用ORMLite。 在Android应用开发中使用ORMLite，首先要下载ORMLite的开发jar包，jar资源包下载主页：<a href="http://ormlite.com/releases" target="_blank" rel="noopener">http://ormlite.com/releases</a> 具体到Android，需要在 <a href="http://ormlite.com/releases" target="_blank" rel="noopener">http://ormlite.com/releases</a> 页面下载两个jar 包（本文基于ORMLite的版本是：ormlite 4.49-SNAPSHOT）： （1）core列表下的jar包； （2）android列表下的jar包。 如图所示： <img src="http://img.blog.csdn.net/20150714145643701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> 将上面的两个jar包下载后放到Android工程项目中的libs包中，如图所示： <img src="http://img.blog.csdn.net/20150714145710073?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> 以上完成后，ORMLite开发环境搭建就完成了，接下来就可以使用了。 首先需要创建和定义一张ORMLite用以存储的数据库表，这个表，用Java的一个类实现，例如User.java：</p>
<p><strong>[java]</strong></p>
<ol>
<li><p>package zhangphil.ormlitetest.database;</p>
</li>
<li><p>import com.j256.ormlite.field.DatabaseField;</p>
</li>
<li><p>import com.j256.ormlite.table.DatabaseTable;</p>
</li>
<li><p>@DatabaseTable(tableName = “users”)</p>
</li>
<li><p>public class User {</p>
</li>
<li><p>public final static String USER_ID = “user_id”;</p>
</li>
<li>public final static String NAME = “name”;</li>
<li><p>public final static String AGE = “age”;</p>
</li>
<li><p>public User() {</p>
</li>
<li><p>}</p>
</li>
<li><p>public User(String name, int age) {</p>
</li>
<li>this.name = name;</li>
<li>this.age = age;</li>
<li><p>}</p>
</li>
<li><p>// @DatabaseField(generatedId = true)</p>
</li>
<li><p>// public int id;</p>
</li>
<li><p>@DatabaseField(id = true, columnName = USER_ID)</p>
</li>
<li><p>public int user_id;</p>
</li>
<li><p>@DatabaseField(columnName = NAME)</p>
</li>
<li><p>public String name;</p>
</li>
<li><p>@DatabaseField(columnName = AGE)</p>
</li>
<li><p>public int age;</p>
</li>
<li><p>public int getUserId() {</p>
</li>
<li>return user_id;</li>
<li><p>}</p>
</li>
<li><p>public void setUserId(int uid) {</p>
</li>
<li>this.user_id = uid;</li>
<li><p>}</p>
</li>
<li><p>public String getName() {</p>
</li>
<li>return name;</li>
<li><p>}</p>
</li>
<li><p>public void setName(String name) {</p>
</li>
<li>this.name = name;</li>
<li><p>}</p>
</li>
<li><p>public int getAge() {</p>
</li>
<li>return age;</li>
<li><p>}</p>
</li>
<li><p>public void setAge(int age) {</p>
</li>
<li>this.age = age;</li>
<li><p>}</p>
</li>
<li><p>@Override</p>
</li>
<li>public String toString() {</li>
<li>return “user_id:” + user_id + “ 姓名:” + name + “ 年龄:” + age;</li>
<li>}</li>
<li>}</li>
</ol>
<p>上面的这个Java类User中开始一段代码：</p>
<p><strong>[java]</strong></p>
<ol>
<li>@DatabaseTable(tableName = “users”)</li>
</ol>
<p>此代码声明了User类中定义的数据模型，将存储在数据库表“users”中。换句话说，数据库表users中，存储的数据单元也即是类User中定义的数据模型。 其中： @DatabaseField(columnName = “xxx”) xxx 表示此数据字段在数据库表中的列名。 DatabaseField中，若设定id=true，则声明此id为主键。 ORMLite的数据库表定义可设置的参数比较多，这点可以参考官方文档。剩余的就是创建ORMLite数据库，和SQLite类似。ORMLite查插删改主要通过DAO。 现在给出一个简单的代码加以说： 定义一个ORMLite数据库表User.java，假设该User表存储用户的id、名字、年龄信息：</p>
<p><strong>[java]</strong></p>
<ol>
<li><p>package zhangphil.ormlitetest.database;</p>
</li>
<li><p>import com.j256.ormlite.field.DatabaseField;</p>
</li>
<li><p>import com.j256.ormlite.table.DatabaseTable;</p>
</li>
<li><p>@DatabaseTable(tableName = “users”)</p>
</li>
<li><p>public class User {</p>
</li>
<li><p>public final static String USER_ID = “user_id”;</p>
</li>
<li>public final static String NAME = “name”;</li>
<li><p>public final static String AGE = “age”;</p>
</li>
<li><p>public User() {</p>
</li>
<li><p>}</p>
</li>
<li><p>public User(String name, int age) {</p>
</li>
<li>this.name = name;</li>
<li>this.age = age;</li>
<li><p>}</p>
</li>
<li><p>// @DatabaseField(generatedId = true)</p>
</li>
<li><p>// public int id;</p>
</li>
<li><p>@DatabaseField(id = true, columnName = USER_ID)</p>
</li>
<li><p>public int user_id;</p>
</li>
<li><p>@DatabaseField(columnName = NAME)</p>
</li>
<li><p>public String name;</p>
</li>
<li><p>@DatabaseField(columnName = AGE)</p>
</li>
<li><p>public int age;</p>
</li>
<li><p>public int getUserId() {</p>
</li>
<li>return user_id;</li>
<li><p>}</p>
</li>
<li><p>public void setUserId(int uid) {</p>
</li>
<li>this.user_id = uid;</li>
<li><p>}</p>
</li>
<li><p>public String getName() {</p>
</li>
<li>return name;</li>
<li><p>}</p>
</li>
<li><p>public void setName(String name) {</p>
</li>
<li>this.name = name;</li>
<li><p>}</p>
</li>
<li><p>public int getAge() {</p>
</li>
<li>return age;</li>
<li><p>}</p>
</li>
<li><p>public void setAge(int age) {</p>
</li>
<li>this.age = age;</li>
<li><p>}</p>
</li>
<li><p>@Override</p>
</li>
<li>public String toString() {</li>
<li>return “user_id:” + user_id + “ 姓名:” + name + “ 年龄:” + age;</li>
<li>}</li>
<li><p>}</p>
<p>创建ORMLite数据库管理工具类ORMLiteDatabaseHelper.java：</p>
</li>
</ol>
<p><strong>[java]</strong></p>
<ol>
<li><p>package zhangphil.ormlitetest.database;</p>
</li>
<li><p>import java.sql.SQLException;</p>
</li>
<li><p>import android.content.Context;</p>
</li>
<li>import android.database.sqlite.SQLiteDatabase;</li>
<li>import android.database.sqlite.SQLiteDatabase.CursorFactory;</li>
<li><p>import android.util.Log;</p>
</li>
<li><p>import com.j256.ormlite.android.apptools.OrmLiteSqliteOpenHelper;</p>
</li>
<li>import com.j256.ormlite.dao.Dao;</li>
<li>import com.j256.ormlite.support.ConnectionSource;</li>
<li><p>import com.j256.ormlite.table.TableUtils;</p>
</li>
<li><p>public class ORMLiteDatabaseHelper extends OrmLiteSqliteOpenHelper {</p>
</li>
<li><p>private static ORMLiteDatabaseHelper mDatabaseHelper = null;</p>
</li>
<li><p>private Dao&lt;User, Integer&gt; mUserDao = null;</p>
</li>
<li><p>private final static String DataBase_NAME = “ormlite.db”;</p>
</li>
<li><p>private final static int DataBase_VERSION = 1;</p>
</li>
<li><p>public ORMLiteDatabaseHelper(Context context, String databaseName,</p>
</li>
<li>CursorFactory factory, int databaseVersion) {</li>
<li>super(context, DataBase_NAME, factory, DataBase_VERSION);</li>
<li><p>}</p>
</li>
<li><p>public static ORMLiteDatabaseHelper getInstance(Context context) {</p>
</li>
<li>if (mDatabaseHelper == null) {</li>
<li>mDatabaseHelper = new ORMLiteDatabaseHelper(context, DataBase_NAME,</li>
<li>null, DataBase_VERSION);</li>
<li><p>}</p>
</li>
<li><p>return mDatabaseHelper;</p>
</li>
<li><p>}</p>
</li>
<li><p>@Override</p>
</li>
<li><p>public void onCreate(SQLiteDatabase arg0, ConnectionSource connectionSource) {</p>
</li>
<li><p>Log.d(this.getClass().getName(), “ORMLite数据库 -&gt; onCreate”);</p>
</li>
<li><p>try {</p>
</li>
<li>TableUtils.createTableIfNotExists(connectionSource, User.class);</li>
<li>} catch (Exception e) {</li>
<li>e.printStackTrace();</li>
<li>}</li>
<li><p>}</p>
</li>
<li><p>@Override</p>
</li>
<li>public void onUpgrade(SQLiteDatabase database, ConnectionSource arg1,</li>
<li><p>int arg2, int arg3) {</p>
</li>
<li><p>Log.i(this.getClass().getName(), “数据库 -&gt; onUpgrade”);</p>
</li>
<li><p>try {</p>
</li>
<li>// 删除旧的数据库表。</li>
<li><p>TableUtils.dropTable(connectionSource, User.class, true);</p>
</li>
<li><p>// 重新创建新版的数据库。</p>
</li>
<li>onCreate(database, connectionSource);</li>
<li>} catch (SQLException e) {</li>
<li>e.printStackTrace();</li>
<li>}</li>
<li><p>}</p>
</li>
<li><p>/**</p>
</li>
<li><ul>
<li>每一个数据库中的表，要有一个获得Dao的方法。 可以使用一种更通用的模板方法如：</li>
</ul>
</li>
<li>* </li>
<li><ul>
<li>public Dao&lt;Class, Integer&gt; getORMLiteDao(Class cls) throws SQLException {</li>
</ul>
</li>
<li><ul>
<li>if (dao == null) { dao = getDao(cls); }</li>
</ul>
</li>
<li>* </li>
<li><ul>
<li>return dao; }</li>
</ul>
</li>
<li>*/</li>
<li>public Dao&lt;User, Integer&gt; getUserDao() {</li>
<li>if (mUserDao == null) {</li>
<li>try {</li>
<li>mUserDao = getDao(User.class);</li>
<li>} catch (java.sql.SQLException e) {</li>
<li>e.printStackTrace();</li>
<li>}</li>
<li><p>}</p>
</li>
<li><p>return mUserDao;</p>
</li>
<li><p>}</p>
</li>
<li><p>@Override</p>
</li>
<li>public void close() {</li>
<li>super.close();</li>
<li>mUserDao = null;</li>
<li>}</li>
<li><p>}</p>
<p>然后就可以在自己的应用中直接使用：</p>
</li>
</ol>
<p><strong>[java]</strong></p>
<ol>
<li><p>package zhangphil.ormlitetest;</p>
</li>
<li><p>import java.sql.SQLException;</p>
</li>
<li>import java.util.List;</li>
<li><p>import java.util.Random;</p>
</li>
<li><p>import com.j256.ormlite.dao.Dao;</p>
</li>
<li><p>import zhangphil.ormlitetest.database.ORMLiteDatabaseHelper;</p>
</li>
<li>import zhangphil.ormlitetest.database.User;</li>
<li>import android.support.v7.app.ActionBarActivity;</li>
<li>import android.widget.Toast;</li>
<li><p>import android.os.Bundle;</p>
</li>
<li><p>public class MainActivity extends ActionBarActivity {</p>
</li>
<li><p>private Dao&lt;User, Integer&gt; mUserDao;</p>
</li>
<li><p>@Override</p>
</li>
<li>protected void onCreate(Bundle savedInstanceState) {</li>
<li><p>super.onCreate(savedInstanceState);</p>
</li>
<li><p>ORMLiteDatabaseHelper mDatabaseHelper = ORMLiteDatabaseHelper</p>
</li>
<li>.getInstance(this);</li>
<li><p>mUserDao = mDatabaseHelper.getUserDao();</p>
</li>
<li><p>Random rand = new Random();</p>
</li>
<li>for (int i = 0; i &lt; 3; i++) {</li>
<li>User user = new User();</li>
<li>user.setUserId(i);</li>
<li>user.setName(“name” + i);</li>
<li>// 生成随机测试的年龄。</li>
<li><p>user.setAge(rand.nextInt(100));</p>
</li>
<li><p>try {</p>
</li>
<li>mUserDao.createOrUpdate(user);</li>
<li>} catch (SQLException e) {</li>
<li>e.printStackTrace();</li>
<li>}</li>
<li>}</li>
<li><p>}</p>
</li>
<li><p>@Override</p>
</li>
<li>public void onStart() {</li>
<li><p>super.onStart();</p>
</li>
<li><p>// 全局查询</p>
</li>
<li>try {</li>
<li><p>List<user> users = mUserDao.queryForAll();</user></p>
</li>
<li><p>for (User u : users) {</p>
</li>
<li>Toast.makeText(this, u.toString(), Toast.LENGTH_SHORT).show();</li>
<li>}</li>
<li>} catch (SQLException e) {</li>
<li>e.printStackTrace();</li>
<li><p>}</p>
</li>
<li><p>// 条件查询QueryBuilder</p>
</li>
<li>// 假设我们给定一个用户的id=1</li>
<li>int uid = 1;</li>
<li>try {</li>
<li>List<user> users = mUserDao.queryBuilder().where()</user></li>
<li><p>.eq(User.USER_ID, uid).query();</p>
</li>
<li><p>for (User u : users) {</p>
</li>
<li>Toast.makeText(this, “查询结果 : “ + u.toString(),</li>
<li>Toast.LENGTH_SHORT).show();</li>
<li>}</li>
<li>} catch (SQLException e) {</li>
<li>e.printStackTrace();</li>
<li>}</li>
<li>}</li>
<li>}</li>
</ol>

            
            <p class="more">
                <a href="/2015/07/14/2019030500003/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/14/2019030500003/" title="Android ORMLite数据库简介">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/4.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/05/27/2019030500015/">
    		利用Navicat工具实现MySQL数据库结构同步
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-05-27T06:34:25.000Z">2015-05-27</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/数据库/" title="数据库">数据库</a> / 
    
        <a href="/tags/结构同步/" title="结构同步">结构同步</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p>Navicat 是一套快速、可靠并价格相宜的数据库管理工具，专为简化数据库的管理及降低系统管理成本而设。Navicat提供多达 7 种语言供客户选择，被公认为全球最受欢迎的数据库前端用户界面工具。 Navicat旗下有多个产品成员 ，可以用来对本机或远程的 MySQL、SQL Server、SQLite、Oracle 及 PostgreSQL 数据库进行管理及开发。因为文中介绍的是MySQL数据库，因此我们要用到的是Navicat旗下的Navicat For MySQL工具。Navicat For MySQL下载链接。 我们在开发项目时一般会用到一个开发版和一个正式版的数据库，在开发版中修改了数据库表结构如何才能快速同步到正式版呢？如果自己手动一个个字段或属性去修改，实在是太麻烦，而且容易遗漏，有了Navicat 工具，就能快速实现数据库直接的同步，包括结构同步，数据同步等。下面介绍如何利用Navicat For MySQL实现MySQL数据库间结构同步。</p>
<h4 id="1-打开Navicat-For-MySQL"><a href="#1-打开Navicat-For-MySQL" class="headerlink" title="1.打开Navicat For MySQL"></a>1.打开Navicat For MySQL</h4><h4 id="2-创建数据库连接，可连接本地数据库服务器，也可远程连接。如图所示创建一个本地连接。"><a href="#2-创建数据库连接，可连接本地数据库服务器，也可远程连接。如图所示创建一个本地连接。" class="headerlink" title="2.创建数据库连接，可连接本地数据库服务器，也可远程连接。如图所示创建一个本地连接。"></a>2.创建数据库连接，可连接本地数据库服务器，也可远程连接。如图所示创建一个本地连接。</h4><p><img src="http://img.blog.csdn.net/20150527110818261" alt="这里写图片描述"> 连接名可自己任意命名，方便自己识别就行。填好地址用户名密码等之后，可点击测试连接，看能够创建连接，若成功则会弹窗提示。 <img src="http://img.blog.csdn.net/20150527111134502" alt="这里写图片描述"></p>
<h4 id="3-连接成功后，选中工具→结构同步，便可对该连接下的数据库进行同步操作了。"><a href="#3-连接成功后，选中工具→结构同步，便可对该连接下的数据库进行同步操作了。" class="headerlink" title="3.连接成功后，选中工具→结构同步，便可对该连接下的数据库进行同步操作了。"></a>3.连接成功后，选中工具→结构同步，便可对该连接下的数据库进行同步操作了。</h4><p><img src="http://img.blog.csdn.net/20150527111311753" alt="这里写图片描述"></p>
<h4 id="4-选中要同步的数据的源和目标，源便是结构同步的参考数据库，目标则是要修改结构进行同步的那个数据库。并选择要对比的项。你可以选择仅同步表，或仅同步视图或存储过程等。都设置好后点击比对按钮即可对比这两个数据库的结构，找出其中的不同。"><a href="#4-选中要同步的数据的源和目标，源便是结构同步的参考数据库，目标则是要修改结构进行同步的那个数据库。并选择要对比的项。你可以选择仅同步表，或仅同步视图或存储过程等。都设置好后点击比对按钮即可对比这两个数据库的结构，找出其中的不同。" class="headerlink" title="4.选中要同步的数据的源和目标，源便是结构同步的参考数据库，目标则是要修改结构进行同步的那个数据库。并选择要对比的项。你可以选择仅同步表，或仅同步视图或存储过程等。都设置好后点击比对按钮即可对比这两个数据库的结构，找出其中的不同。"></a>4.选中要同步的数据的源和目标，源便是结构同步的参考数据库，目标则是要修改结构进行同步的那个数据库。并选择要对比的项。你可以选择仅同步表，或仅同步视图或存储过程等。都设置好后点击比对按钮即可对比这两个数据库的结构，找出其中的不同。</h4><p><img src="http://img.blog.csdn.net/20150527111308842" alt="这里写图片描述"></p>
<h4 id="5-比对结果如下图所示，可以在上面的源对象和目标对象列表中看出哪些表或视图或函数等结构有不同，具体的不同则可以通过下面的查询语句来看。选中要执行的查询语句点击运行便可进行同步修改。"><a href="#5-比对结果如下图所示，可以在上面的源对象和目标对象列表中看出哪些表或视图或函数等结构有不同，具体的不同则可以通过下面的查询语句来看。选中要执行的查询语句点击运行便可进行同步修改。" class="headerlink" title="5.比对结果如下图所示，可以在上面的源对象和目标对象列表中看出哪些表或视图或函数等结构有不同，具体的不同则可以通过下面的查询语句来看。选中要执行的查询语句点击运行便可进行同步修改。"></a>5.比对结果如下图所示，可以在上面的源对象和目标对象列表中看出哪些表或视图或函数等结构有不同，具体的不同则可以通过下面的查询语句来看。选中要执行的查询语句点击运行便可进行同步修改。</h4><p><img src="http://img.blog.csdn.net/20150527111642032" alt="这里写图片描述"></p>
<h4 id="6-运行结果将在信息日志中显示，如果出现执行不成功的查询，则会以红色字体显示，可自己再手动进行修改。若无错误，则结构同步完成。可到数据库中查看，两个表要同步的部分是否结构已经一致。"><a href="#6-运行结果将在信息日志中显示，如果出现执行不成功的查询，则会以红色字体显示，可自己再手动进行修改。若无错误，则结构同步完成。可到数据库中查看，两个表要同步的部分是否结构已经一致。" class="headerlink" title="6.运行结果将在信息日志中显示，如果出现执行不成功的查询，则会以红色字体显示，可自己再手动进行修改。若无错误，则结构同步完成。可到数据库中查看，两个表要同步的部分是否结构已经一致。"></a>6.运行结果将在信息日志中显示，如果出现执行不成功的查询，则会以红色字体显示，可自己再手动进行修改。若无错误，则结构同步完成。可到数据库中查看，两个表要同步的部分是否结构已经一致。</h4><p><img src="http://img.blog.csdn.net/20150527112235429" alt="这里写图片描述"></p>
</blockquote>

            
            <p class="more">
                <a href="/2015/05/27/2019030500015/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/05/27/2019030500015/" title="利用Navicat工具实现MySQL数据库结构同步">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/7.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <span class="page-number current">1</span>
    </nav>
    


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/MySQL/">MySQL</a>
        <span class="badge">(92)</span>
    </li>
    
    <li>
        <a href="/categories/开发语言/">开发语言</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="/categories/Oracle/">Oracle</a>
        <span class="badge">(40)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/">NOSQL</a>
        <span class="badge">(17)</span>
    </li>
    
    <li>
        <a href="/categories/SQL-Server/">SQL Server</a>
        <span class="badge">(13)</span>
    </li>
    
    <li>
        <a href="/categories/其他数据库/">其他数据库</a>
        <span class="badge">(4)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/">Oracle</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/SQL-Server/">SQL Server</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/开发语言/">开发语言</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/MySQL/" title="MySQL">MySQL (71)</a>
  
    <a class="tag-item" href="/tags/位运算/" title="位运算">位运算 (0)</a>
  
    <a class="tag-item" href="/tags/allow/" title="allow">allow (1)</a>
  
    <a class="tag-item" href="/tags/Apache/" title="Apache">Apache (1)</a>
  
    <a class="tag-item" href="/tags/deny/" title="deny">deny (1)</a>
  
    <a class="tag-item" href="/tags/sqlplus/" title="sqlplus">sqlplus (1)</a>
  
    <a class="tag-item" href="/tags/CentOS/" title="CentOS">CentOS (2)</a>
  
    <a class="tag-item" href="/tags/druid/" title="druid">druid (1)</a>
  
    <a class="tag-item" href="/tags/心跳/" title="心跳">心跳 (1)</a>
  
    <a class="tag-item" href="/tags/redis/" title="redis">redis (6)</a>
  
    <a class="tag-item" href="/tags/分库/" title="分库">分库 (1)</a>
  
    <a class="tag-item" href="/tags/分库分表/" title="分库分表">分库分表 (1)</a>
  
    <a class="tag-item" href="/tags/分表/" title="分表">分表 (1)</a>
  
    <a class="tag-item" href="/tags/Oracle/" title="Oracle">Oracle (30)</a>
  
    <a class="tag-item" href="/tags/schedule-job/" title="schedule job">schedule job (1)</a>
  
    <a class="tag-item" href="/tags/事务/" title="事务">事务 (5)</a>
  
    <a class="tag-item" href="/tags/分布式/" title="分布式">分布式 (1)</a>
  
    <a class="tag-item" href="/tags/消息/" title="消息">消息 (1)</a>
  
    <a class="tag-item" href="/tags/KeepAlived/" title="KeepAlived">KeepAlived (1)</a>
  
    <a class="tag-item" href="/tags/数据库/" title="数据库">数据库 (7)</a>
  
    <a class="tag-item" href="/tags/结构同步/" title="结构同步">结构同步 (1)</a>
  
    <a class="tag-item" href="/tags/truncate/" title="truncate">truncate (1)</a>
  
    <a class="tag-item" href="/tags/FineReport/" title="FineReport">FineReport (1)</a>
  
    <a class="tag-item" href="/tags/SQL/" title="SQL">SQL (17)</a>
  
    <a class="tag-item" href="/tags/报表/" title="报表">报表 (1)</a>
  
    <a class="tag-item" href="/tags/数据集/" title="数据集">数据集 (1)</a>
  
    <a class="tag-item" href="/tags/Excel/" title="Excel">Excel (1)</a>
  
    <a class="tag-item" href="/tags/Sqlite/" title="Sqlite">Sqlite (1)</a>
  
    <a class="tag-item" href="/tags/批量/" title="批量">批量 (1)</a>
  
    <a class="tag-item" href="/tags/Linux/" title="Linux">Linux (2)</a>
  
    <a class="tag-item" href="/tags/Character-set/" title="Character set">Character set (1)</a>
  
    <a class="tag-item" href="/tags/NLS-LANG/" title="NLS_LANG">NLS_LANG (1)</a>
  
    <a class="tag-item" href="/tags/rowid/" title="rowid">rowid (2)</a>
  
    <a class="tag-item" href="/tags/重复/" title="重复">重复 (1)</a>
  
    <a class="tag-item" href="/tags/Hash索引/" title="Hash索引">Hash索引 (1)</a>
  
    <a class="tag-item" href="/tags/InnoDB/" title="InnoDB">InnoDB (3)</a>
  
    <a class="tag-item" href="/tags/MyISAM/" title="MyISAM">MyISAM (3)</a>
  
    <a class="tag-item" href="/tags/索引优化/" title="索引优化">索引优化 (1)</a>
  
    <a class="tag-item" href="/tags/mysqldump/" title="mysqldump">mysqldump (2)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="http://www.devba.com" target="_blank" title="软件开发吧">软件开发吧</a>
        </li>
    
        <li>
            <a href="https://www.sqlyun.cn" target="_blank" title="SQL云笔记">SQL云</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>