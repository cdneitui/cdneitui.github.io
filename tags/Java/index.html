<!doctype html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8">
    <meta name="baidu-site-verification" content="dIcXMeY8Ya">
    
    <title>`Java`标签下的文章 | 软件开发吧</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="keywords" content="SQL云,SQL云开发,SQL笔记,SQL开发,云开发,MySQL,Oralce,数据库,数据库云,数据库开发,数据库云开发,SQL教程,数据库教程,开发笔记,MySQL笔记,MySQL教程">
    <meta name="description" content="为满足广大程序猿兄弟对日常工作中学习数据库、使用使用数据库资料查询需求，SQL云开发免费将自己整理的各种数据库技术资料分享出来，并希望与广大猿兄一起讨论学习与进步,致力于一起更方便、快捷资料学习查询,实现更安全、高效的数据存储.">

    
    <link rel="alternative" href="/atom.xml" title="软件开发吧" type="application/atom+xml">
    
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
</html>
<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">软件开发吧</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/tags/Java/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/tags/Java/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/tags/Java/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/tags/Java/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/sxyyhj" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.coding.me" target="_blank">Hosted by Coding Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon">
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 按标签分类 -->

    <h3 class="widget-hd">
        <strong>
            
                `Java`标签下的文章
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/02/16/2019030500058/">
    		mongodb最新java驱动CRUD使用演示
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-02-16T06:08:35.000Z">2016-02-16</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MongoDB/" title="MongoDB">MongoDB</a> / 
    
        <a href="/tags/Java/" title="Java">Java</a> / 
    
        <a href="/tags/CRUD/" title="CRUD">CRUD</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>今天使用java代码调用mongodb数据库，用maven引入了最新版的mongodb驱动，在网上找了demo结果发现将demo贴到eclipse上之后好多过期方法。所以猜想mongodb驱动版本肯定有很大的更新。 果不其然，mongodb的确有了最新版3.x。而网上几乎所有的demo都基于2.x版本。下面是在github上找的一些资料，再结合官方文档总结的3.x版本的CRUD操作。   以下演示源码地址：<a href="https://github.com/smallbug-vip/repo" target="_blank" rel="noopener">https://github.com/smallbug-vip/repo</a>   首先在pom.xml中配置引入jar包：</p>
<p>Xml代码</p>
<ol>
<li><dependency></dependency></li>
<li><groupid>org.mongodb</groupid></li>
<li><artifactid>mongo-java-driver</artifactid></li>
<li><version>3.2.1</version></li>
<li></li>
</ol>
<p>下面演示会使用到一些静态方法，eclipse中使用快捷键不能自动导包，可以手动添加：</p>
<p>Java代码</p>
<ol>
<li>import static com.mongodb.client.model.Filters.and;</li>
<li>import static com.mongodb.client.model.Filters.eq;</li>
<li>import static com.mongodb.client.model.Filters.exists;</li>
<li>import static com.mongodb.client.model.Filters.gt;</li>
<li>import static com.mongodb.client.model.Filters.gte;</li>
<li>import static com.mongodb.client.model.Filters.lt;</li>
<li>import static com.mongodb.client.model.Filters.lte;</li>
<li>import static com.mongodb.client.model.Projections.excludeId;</li>
<li>import static com.mongodb.client.model.Projections.include;</li>
<li>import static com.mongodb.client.model.Sorts.descending;</li>
</ol>
<p>准备工作：</p>
<p>Java代码</p>
<ol>
<li>MongoDatabase db = null;</li>
<li><p>MongoClient client = null;</p>
</li>
<li><p>@Before</p>
</li>
<li>public void before() {</li>
<li>client = new MongoClient(“192.168.88.132”, 27017);</li>
<li>db = client.getDatabase(“its”);</li>
<li><p>}</p>
</li>
<li><p>@After</p>
</li>
<li>public void after() {</li>
<li>if (client != null) {</li>
<li>client.close();</li>
<li>}</li>
<li>}</li>
</ol>
<p>获取连接：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li><p>public void testCollections() {</p>
</li>
<li><p>MongoIterable<string> collections = db.listCollectionNames();</string></p>
</li>
<li>MongoCursor<string> cu = collections.iterator();</string></li>
<li>for (; cu.hasNext();) {</li>
<li>System.out.println(cu.next());</li>
<li>}</li>
<li>}</li>
</ol>
<p>测试增加一个Document：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testAdd() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>Document doc = new Document(“name”, “MongoDB”)//</li>
<li>.append(“type”, “database”)//</li>
<li>.append(“count”, 1)//</li>
<li>.append(“info”, new Document(“x”, 203).append(“y”, 102));</li>
<li>col.insertOne(doc);</li>
<li>}</li>
</ol>
<p>测试增加多个Document：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testAddALL() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>List<document> dos = new ArrayList<document>();</document></document></li>
<li>for (int i = 0; i &lt; 100; i++) {</li>
<li>dos.add(new Document(“i”, i));</li>
<li>}</li>
<li>col.insertMany(dos);</li>
<li>}</li>
</ol>
<p>查看当前有多少记录：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testCount() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>System.out.println(col.count());</li>
<li>}</li>
</ol>
<p>获取第一条记录：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testFirst() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>Document myDoc = col.find().first();</li>
<li>System.out.println(myDoc.toJson());</li>
<li>}</li>
</ol>
<p>获取第所有记录：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testFindAll() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>/<strong><strong><strong><em>**</em></strong></strong></strong> 第一种方法 <strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>/</li>
<li>// MongoCursor<document> cursor = col.find().iterator();</document></li>
<li>// while (cursor.hasNext()) {</li>
<li>// System.out.println(cursor.next().toJson());</li>
<li>// }</li>
<li>/<strong><strong><strong><em>**</em></strong></strong></strong> 第二种方法 <strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>/</li>
<li>for (Document cur : col.find()) {</li>
<li>System.out.println(cur.toJson());</li>
<li>}</li>
<li>}</li>
</ol>
<p>分页：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testLimit() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>for (Document cur : col.find().skip(20).limit(10)) {</li>
<li>System.out.println(cur.toJson());</li>
<li>}</li>
<li>}</li>
</ol>
<p>条件查询：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testFilter() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>// eq为静态导入</li>
<li>Document myDoc = col.find(eq(“i”, 71)).first();</li>
<li>System.out.println(myDoc.toJson());</li>
<li>}</li>
</ol>
<p>获得子集：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testBlock() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>Block<document> printBlock = new Block<document>() {</document></document></li>
<li>@Override</li>
<li>public void apply(final Document document) {</li>
<li>System.out.println(document.toJson());</li>
<li>}</li>
<li>};</li>
<li>col.find(and(gt(“i”, 50), lte(“i”, 80))).forEach(printBlock);</li>
<li>}</li>
</ol>
<p>排序：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testSort() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>// 升序 ascending</li>
<li>FindIterable<document> it = col.find(exists(“i”)).sort(descending(“i”));</document></li>
<li>for (Document d : it) {</li>
<li>System.out.println(d.toJson());</li>
<li>}</li>
<li>}</li>
</ol>
<p>筛选字段：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testProjection() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>FindIterable<document> it = col.find()//</document></li>
<li>.projection(and(include(“name”), excludeId()));</li>
<li>for (Document d : it) {</li>
<li>System.out.println(d.toJson());</li>
<li>}</li>
<li>}</li>
</ol>
<p>更新一条Document：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testUpdateOne() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>col.updateOne(//</li>
<li>eq(“i”, 10), new Document(“$set”, new Document(“i”, 110)));</li>
<li>}</li>
</ol>
<p>更新多条记录：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testUpdateMany() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>// $inc 自增</li>
<li>UpdateResult updateResult = col.updateMany(lt(“i”, 10), new Document(“$inc”, new Document(“i”, 234)));</li>
<li>System.out.println(updateResult.getModifiedCount());</li>
<li>}</li>
</ol>
<p>测试删除一条Document：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testDeleteOne() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>DeleteResult re = col.deleteOne(eq(“i”, 234));</li>
<li>System.out.println(re.getDeletedCount());</li>
<li>}</li>
</ol>
<p>测试删除多条Document：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testDeleteMany() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>DeleteResult deleteResult = col.deleteMany(gte(“i”, 100));</li>
<li>System.out.println(deleteResult.getDeletedCount());</li>
<li>}</li>
</ol>

            
            <p class="more">
                <a href="/2016/02/16/2019030500058/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/02/16/2019030500058/" title="mongodb最新java驱动CRUD使用演示">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/6.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/22/2019030500050/">
    		java插入mysql 300万-2200万数据，优化查询
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-22T06:31:31.000Z">2015-12-22</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/Java/" title="Java">Java</a> / 
    
        <a href="/tags/优化/" title="优化">优化</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>my.ini参数修改了下</p>
<ol>
<li>table_cache=512</li>
<li>bulk_insert_buffer_size = 100M</li>
<li>innodb_additional_mem_pool_size=30M</li>
<li>innodb_flush_log_at_trx_commit=0</li>
<li>innodb_buffer_pool_size=207M</li>
<li>innodb_log_file_size=128M</li>
</ol>
<p>innodb_flush_log_at_trx_commit默认值1的意思是每一次事务提交或事务外的指令都需要把日志写入（flush）硬盘，这是很费时的。特别是使用电 池供电缓存（Battery backed up cache）时。设成2对于很多运用，特别是从MyISAM表转过来的是可以的，它的意思是不写入硬盘而是写入系统缓存。日志仍然会每秒flush到硬 盘，所以你一般不会丢失超过1-2秒的更新。设成0会更快一点，但安全方面比较差，即使MySQL挂了也可能会丢失事务的数据。而值2只会在整个操作系统 挂了时才可能丢数据。对于事务要求很强，设置为0 是存在安全问题的 mysql创建表</p>
<p>Sql代码</p>
<ol>
<li>CREATE TABLE `news` (</li>
<li>`id` int(19) NOT NULL AUTO_INCREMENT,</li>
<li>`title` varchar(30) DEFAULT NULL,</li>
<li>`content` varchar(400) DEFAULT NULL,</li>
<li>`type` varchar(30) DEFAULT NULL,</li>
<li>PRIMARY KEY (`id`),</li>
<li>UNIQUE KEY `PK_NEWS_ID` (`id`),</li>
<li>KEY `INDEX_NEWS_ID_TYPE` (`id`,`type`),</li>
<li>KEY `INDEX_NEWS_TYPE` (`type`)</li>
<li><p>) ENGINE=InnoDB AUTO_INCREMENT=1072779 DEFAULT CHARSET=utf8</p>
<p>插入数据一定要用 addBatch 超过300万条数据在我的笔记本上只需要近10分钟</p>
</li>
</ol>
<p>Java代码</p>
<ol>
<li>public static void main(String[] args) {</li>
<li><p>Connection conn = null;</p>
</li>
<li><p>// MySQL的JDBC URL编写方式：jdbc:mysql://主机名称：连接端口/数据库的名称?参数=值</p>
</li>
<li>// 避免中文乱码要指定useUnicode和characterEncoding</li>
<li>// 执行数据库操作之前要在数据库管理系统上创建一个数据库，名字自己定，</li>
<li>// 下面语句之前就要先创建javademo数据库</li>
<li>String url = “jdbc:mysql://localhost:3306/javademo?”</li>
<li><ul>
<li>“user=root&amp;password=root&amp;useUnicode=true&amp;characterEncoding=UTF8”;</li>
</ul>
</li>
<li>try {</li>
<li>Class.forName(“com.mysql.jdbc.Driver”);// 动态加载mysql驱动</li>
<li><p>conn = DriverManager.getConnection(url);</p>
</li>
<li><p>String   sql = “insert into news(title,content,type) values(?,?,?)”;</p>
</li>
<li><p>PreparedStatement prep = conn.prepareStatement(sql);</p>
</li>
<li>// 将连接的自动提交关闭，数据在传送到数据库的过程中相当耗时</li>
<li>conn.setAutoCommit(false);</li>
<li>long start = System.currentTimeMillis();</li>
<li>String type = “java”;</li>
<li>String content = “SUN公司开发Java语言的时候，在数据库这里只是提供了一个标准的接口，或者说是规范，叫做JDBC，这个东西单独放在那里没有任何作用，根本无法连接任何的数据库，只有当你下载相应的数据库驱动程序之后，才可以用JDBC通过这个驱动程序和数据库通信。sqlsever就有它的专门的驱动程序，在微软网站上可以下载到。SUN公司自己也开发了数据库驱动程序，叫做JDBC-ODBC驱动程序，是通过建立ODBC桥来连接Windows数据库，但是因为效率低并且有限制，现在一般都不推荐使用”;</li>
<li>for (int i = 0; i &lt; 30; i++) {</li>
<li>long start2 = System.currentTimeMillis();</li>
<li>// 一次性执行插入10万条数据</li>
<li>if(i==2){type=”php”;}</li>
<li>else if(i==3){type=”erlang”;}</li>
<li>else if(i==4){type=”go”;}</li>
<li>else if(i==5){type=”javascript”;}</li>
<li>else if(i==6){type=”html”;}</li>
<li>else if(i==7){type=”html5”;}</li>
<li>else if(i==8){type=”css”;}</li>
<li>else if(i==9){type=”python”;}</li>
<li>else if(i==10){type=”ror”;}</li>
<li>else if(i==11){type=”nodejs”;}</li>
<li>else if(i==12){type=”spring”;}</li>
<li>else if(i==13){type=”hibernate”;}</li>
<li>else if(i==14){type=”ibatis”;}</li>
<li>else if(i==15){type=”mybatis”;}</li>
<li>else if(i==16){type=”mysql”;}</li>
<li>else if(i==17){type=”msserver”;}</li>
<li>else if(i==18){type=”oracle”;}</li>
<li>else if(i==19){type=”redis”;}</li>
<li>else if(i==20){type=”mangodb”;}</li>
<li>else if(i==21){type=”c”;}</li>
<li>else if(i==22){type=”c++”;}</li>
<li>else if(i==23){type=”springside”;}</li>
<li>else if(i==24){type=”springroo”;}</li>
<li>else if(i==25){type=”sprintboot”;}</li>
<li>else if(i==26){type=”sprintmvc”;}</li>
<li>else if(i==27){type=”websocket”;}</li>
<li>else if(i==28){type=”restful”;}</li>
<li>else if(i==29){type=”comet”;}</li>
<li>for (int j = 0; j &lt; 100000; j++) {</li>
<li>prep.setString(1, “文章”+j);</li>
<li>prep.setString(2, content);</li>
<li>prep.setString(3, type);</li>
<li>prep.addBatch();</li>
<li>}</li>
<li>// 预处理批量执行</li>
<li>prep.executeBatch();</li>
<li>prep.clearBatch();</li>
<li>conn.commit();</li>
<li>long end2 = System.currentTimeMillis();</li>
<li><p>// 批量执行一次批量打印执行依次的时间</p>
</li>
<li><p>System.out.println(end2 - start2);</p>
</li>
<li>}</li>
<li>long end = System.currentTimeMillis();</li>
<li>System.out.print(“total: “);</li>
<li>System.out.println(end - start);</li>
<li>} catch (Exception e) {</li>
<li>e.printStackTrace();</li>
<li>} finally {</li>
<li>try {</li>
<li>conn.close();</li>
<li>} catch (SQLException e) {</li>
<li>// TODO Auto-generated catch block</li>
<li>e.printStackTrace();</li>
<li>}</li>
<li>}</li>
<li>}</li>
</ol>
<p>测试结果300万插入只需要597秒</p>
<ol>
<li>15031</li>
<li>15248</li>
<li>18522</li>
<li>18419</li>
<li>19223</li>
<li>19613</li>
<li>20822</li>
<li>18701</li>
<li>19468</li>
<li>21290</li>
<li>19766</li>
<li>20956</li>
<li>19490</li>
<li>19089</li>
<li>20290</li>
<li>22568</li>
<li>20079</li>
<li>20556</li>
<li>20922</li>
<li>22659</li>
<li>21155</li>
<li>19782</li>
<li>20378</li>
<li>21053</li>
<li>19459</li>
<li>22388</li>
<li>20323</li>
<li>20011</li>
<li>18158</li>
<li>21199</li>
<li><p>total: 596625</p>
<p>机器上一共插入了300万的数据，测试下查询：</p>
</li>
<li><p>select COUNT(id) from news</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li>Time: 0.729ms</li>
</ol>
<p>查询下分页</p>
<ol>
<li><p>select id,title from news limit 1000000,20</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li><p>Time: 7.839ms</p>
<p>从第100万条查询20条记录，耗费了八秒时间，速度慢  </p>
</li>
<li><p>[SQL] select id from news limit 1000000,20</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li>Time: 0.242ms</li>
</ol>
<p>id 是索引，所以更快点  </p>
<ol>
<li>[SQL]</li>
<li><p>select id from news order by id limit 1000000,20</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li>Time: 7.841ms</li>
</ol>
<p>order 加上去慢的太多了  </p>
<ol>
<li><p>select id,title from news where id&gt;=(select id from news order by id limit 1000000,1) limit 20</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li>Time: 8.115ms</li>
</ol>
<p>只要有order by在效率是上不去  </p>
<ol>
<li>[SQL]</li>
<li>select id  from news where type = ‘ibatis’    limit 1,500000;</li>
<li>Affected rows: 0</li>
<li>Time: 0.076ms</li>
</ol>
<ol>
<li><p>select id,title from news where type = ‘ibatis’  limit 1000000,20</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li>Time: 0.163ms</li>
</ol>
<p>Java代码  <img src="/uploads/2015/12/icon_star.png" alt="收藏代码"></p>
<ol>
<li>[SQL]</li>
<li>select id,title,type from news where type = ‘ibatis’    limit 1,500000;</li>
<li>Affected rows: 0</li>
<li>Time: 0.209ms</li>
</ol>
<p>Java代码  <img src="/uploads/2015/12/icon_star.png" alt="收藏代码"></p>
<ol>
<li>[SQL]</li>
<li>select id,title,content,type from news where type = ‘ibatis’    limit 1,500000;</li>
<li>Affected rows: 0</li>
<li>Time: 0.471ms</li>
</ol>
<p>加上大字段会消耗一点性能 <img src="/uploads/2015/12/137ad894-49bd-31a6-9fa4-3e2f99930c72.png" alt title="点击查看原始大小图片"> 可见复合索引带来性能的优势 <img src="/uploads/2015/12/f54e794d-5d08-3f01-9aff-6f251ae141b1.png" alt title="点击查看原始大小图片"> in的速度是惊人的，300万条记录里面里用in仅仅 0.004ms，最主要也是因为加了索引。 这里面有2个惊人的查询，这也刚好是分页的功能的查询</p>
<ol>
<li>select id  from news where type = ‘ibatis’    limit 1,500000;</li>
<li><p>select *  from news where id in(xxx,xxx,xxx,xxx……………)</p>
<p>最后把in的代码贴出来，大家也试试in的威力</p>
</li>
<li><p>select *  from news where id in(</p>
</li>
<li>2999999,2999998,2999997,2999996,2999995,2999994,2999993,2999992,2999991,2999990,2999989,</li>
<li>2999988,2999987,2999986,2999985,2999984,2999983,2999982,2999981,2999980,2999979,2999978,</li>
<li>2999977,2999976,2999975,2999974,2999973,2999972,2999971,2999970,2999969,2999968,2999967,</li>
<li>2999966,2999965,2999964,2999963,2999962,2999961,2999960,2999959,2999958,2999957,2999956,</li>
<li>2999955,2999954,2999953,2999952,2999951,2999950,2999949,2999948,2999947,2999946,2999945,</li>
<li>2999944,2999943,2999942,2999941,2999940,2999939,2999938,2999937,2999936,2999935,2999934,</li>
<li>2999933,2999932,2999931,2999930,2999929,2999928,2999927,2999926,2999925,2999924,2999923,</li>
<li>2999922,2999921,2999920,2999919,2999918,2999917,2999916,2999915,2999914,2999913,2999912,</li>
<li>2999911,2999910,2999909,2999908,2999907,2999906,2999905,2999904,2999903,2999902,2999901,</li>
<li>2999900,2999899,2999898,2999897,2999896,2999895,2999894,2999893,2999892,2999891,2999890,</li>
<li>2999889,2999888,2999887,2999886,2999885,2999884,2999883,2999882,2999881,2999880,2999879,</li>
<li>2999878,2999877,2999876,2999875,2999874,2999873,2999872,2999871,2999870,2999869,2999868,</li>
<li>2999867,2999866,2999865,2999864,2999863,2999862,2999861,2999860,2999859,2999858,2999857,</li>
<li>2999856,2999855,2999854,2999853,2999852,2999851,2999850,2999849,2999848,2999847,2999846,</li>
<li>2999845,2999844,2999843,2999842,2999841,2999840,2999839,2999838,2999837,2999836,2999835,</li>
<li>2999834,2999833,2999832,2999831,2999830,2999829,2999828,2999827,2999826,2999825,2999824,</li>
<li>2999823,2999822,2999821,2999820,2999819,2999818,2999817,2999816,2999815,2999814,2999813,2999812</li>
<li><p>)</p>
<p><img src="/uploads/2015/12/b70cf91e-9fac-3792-bfed-5c6474d64ae0.png" alt title="点击查看原始大小图片"> 最快的是0.003ms   试试in里面放1188个参数   <img src="/uploads/2015/12/8830527f-e550-3795-b315-d15c7bf395a3.jpg" alt title="点击查看原始大小图片"> 速度依然很惊人   现在数据已经添加到了至少2200万条数据，看看in的效果 <img src="/uploads/2015/12/09409dd7-0647-382b-a090-0a17a785894b.png" alt title="点击查看原始大小图片"> 几千万数据中in语句只需0.001ms <img src="/uploads/2015/12/500dea44-6342-3b6e-bfa5-9b0f35408310.png" alt title="点击查看原始大小图片"> 数据大了，这个语句消耗的时间也增加了点 0.406ms 返回记录49.9999万条</p>
</li>
</ol>

            
            <p class="more">
                <a href="/2015/12/22/2019030500050/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/22/2019030500050/" title="java插入mysql 300万-2200万数据，优化查询">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/04/2019030500029/">
    		数据库中的字段和Java里面的类型匹配
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-04T05:29:42.000Z">2015-12-04</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/SQL/" title="SQL">SQL</a> / 
    
        <a href="/tags/hibernate/" title="hibernate">hibernate</a> / 
    
        <a href="/tags/Java/" title="Java">Java</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>当在hibernate中运用原始的sql语句进行操作的的时候，常常会报错，错误很多都是关于 No Dialect mapping for JDBC type:?这里的问号是不同的数字如：-1,1，-9,3等等，每种数字代表一种类型。经过分析和查找，问题常常发生在几个地方 1、错误的配置了hibernate的方言 2、就是你的数据库中的字段和Java里面的类型不匹配的问题 错误如下： org.hibernate.MappingException: No Dialect mapping for JDBC type: -1 Error message: org.hibernate.MappingException: No Dialect mapping for JDBC type: -1 at org.hibernate.dialect.TypeNames.get(TypeNames.java:56) at org.hibernate.dialect.TypeNames.get(TypeNames.java:81) at org.hibernate.dialect.Dialect.getHibernateTypeName(Dialect.java:370) at org.hibernate.loader.custom.CustomLoader$Metadata.getHibernateType(CustomLoader.java:559) at org.hibernate.loader.custom.CustomLoader$ScalarResultColumnProcessor.performDiscovery(CustomLoader.java:485) at org.hibernate.loader.custom.CustomLoader.autoDiscoverTypes(CustomLoader.java:501) at org.hibernate.loader.Loader.getResultSet(Loader.java:1796) at org.hibernate.loader.Loader.doQuery(Loader.java:674) at org.hibernate.loader.Loader.doQueryAndInitializeNonLazyCollections(Loader.java:236) at org.hibernate.loader.Loader.doList(Loader.java:2220) at org.hibernate.loader.Loader.listIgnoreQueryCache(Loader.java:2104) at org.hibernate.loader.Loader.list(Loader.java:2099) at org.hibernate.loader.custom.CustomLoader.list(CustomLoader.java:289) at org.hibernate.impl.SessionImpl.listCustomQuery(SessionImpl.java:1695) at org.hibernate.impl.AbstractSessionImpl.list(AbstractSessionImpl.java:142) at org.hibernate.impl.SQLQueryImpl.list(SQLQueryImpl.java:152) at com.tilsi.solr.dao.summary.EntryDAO.queryByEntryId(EntryDAO.java:164) at com.tilsi.solr.service.db.DbSearchThread.searchSummary(DbSearchThread.java:69) at com.tilsi.solr.service.db.DbSearchThread.call(DbSearchThread.java:48) at com.tilsi.solr.service.db.DbSearchThread.call(DbSearchThread.java:1) at java.util.concurrent.FutureTask$Sync.innerRun(FutureTask.java:303) at java.util.concurrent.FutureTask.run(FutureTask.java:138) at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886) at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908) at java.lang.Thread.run(Thread.java:662) 解决方法为：通过查询hibernate的源码，找到问题的根本所在，就是hibernate中不支持对应的数据类型，具体数据类型的值，请查看下表 查看 java.sql.Types 类，可以找到对应类型，调整相应的数据库里的类型，或者其他支持这个类型的方言。 public final static int BIT   =  -7; public final static int TINYINT  =  -6; public final static int SMALLINT =   5; public final static int INTEGER  =   4; public final static int BIGINT   =  -5; public final static int FLOAT   =   6; public final static int REAL   =   7; public final static int DOUBLE   =   8; public final static int NUMERIC  =   2; public final static int DECIMAL  =   3; public final static int CHAR  =   1; public final static int VARCHAR  =  12; public final static int LONGVARCHAR  =  -1; public final static int DATE   =  91; public final static int TIME   =  92; public final static int TIMESTAMP  =  93; public final static int BINARY  =  -2; public final static int VARBINARY  =  -3; public final static int LONGVARBINARY  =  -4; public final static int NULL  =   0; public final static int OTHER  = 1111; public final static int JAVA_OBJECT         = 2000; public final static int DISTINCT            = 2001; public final static int STRUCT              = 2002; public final static int ARRAY               = 2003; public final static int BLOB                = 2004; public final static int CLOB                = 2005; public final static int REF                 = 2006; public final static int DATALINK = 70; public final static int BOOLEAN = 16; public final static int ROWID = -8; public static final int NCHAR = -15; public static final int NVARCHAR = -9; public static final int LONGNVARCHAR = -16; public static final int NCLOB = 2011; public static final int SQLXML = 2009; 这类错误，最后的问号表示不确定的数字，但是解决的方法都一样。 首先，自定义一个方言类——Hibernate Dialect，该类需要继承与我们使用的数据库相应的方言类。比如：如果我们用的是mysql（版本为5.x.x），我们需要继承“org.hibernate.dialect.MySQL5Dialect”；如果我们使用的是DB2，那么我们应该继承“org.hibernate.dialect.DB2Dialect”；我用的是SqlServer2008，所以我要继承“org.hibernate.dialect.SQLServerDialect”，参考代码如下： import java.sql.Types; import org.hibernate.Hibernate; import org.hibernate.dialect.SQLServerDialect; public class SqlServer2008Dialect extends SQLServerDialect { public SqlServer2008Dialect() { super(); registerHibernateType(Types.CHAR, Hibernate.STRING.getName()); registerHibernateType(Types.NVARCHAR, Hibernate.STRING.getName()); registerHibernateType(Types.LONGNVARCHAR, Hibernate.STRING.getName()); registerHibernateType(Types.DECIMAL, Hibernate.DOUBLE.getName()); } } 总之大家可以在“org.hibernate.dialect”这个package中找到与数据库相对应的方言类。在其中，我们需要注意三点： a、在默认构造方法中继承父类构造方法，同时调用“registerHibernateType(int code, String name)”方法将数据库中该数据类型映射到相应的java类型。code表示数据库中的数据类型整数表示，可以在“java.sql.Types”类中查到相应的数据库类型。name表示我们要映射的java类型。可以从“org.hibernate.Hibernate”中查到。 b、Types类。在Types中定义了数据库常用的字段类型，如： …… public final static int LONGVARCHAR =  -1; public final static int TIMESTAMP =  93; …… 也就是上面我列出的java.sql.Types。 我们可以根据“No Dialect mapping for JDBC type : ”后面紧跟的数字在该类（Types）中找到相应的类型。我们也可以根据数据表中字段的类型找到相应的值。这个值就是registerHibernateType(int code, String name)的第一个参数。 c、Hibernate类。Hibernate中定义了转换的目的类型，如第一段代码所示。能够转化成什么类型，可以在该类中查找。通过调用“getName()”方法得到一个String型。当然，如果你记住了，我们还可以这样写 import org.hibernate.dialect.SQLServerDialect; public class SqlServer2008Dialect extends SQLServerDialect { public SqlServer2008Dialect() { super(); registerHibernateType(1, “string”); registerHibernateType(-9, “string”); registerHibernateType(-16, “string”); registerHibernateType(3, “double”); } } 其实和上面是一样的，只是把上面所代表的值直接写出来了。需要注意的是super()方法的调用，不调用该方法是否会出现错误，这个我就不知道了，我没有测试，所以最好调一下。 然后，我们还需要在配置文件中作修改，我将连接数据库的方法放在了spring配置文件中了，这段代码就写在applicationContext.xml里面了： <property name="hibernateProperties"> <props> <!-- <prop key="hibernate.dialect">org.hibernate.dialect.SQLServerDialect </prop> --> <prop key="hibernate.dialect">com.sense.workflow.util.SqlServer2008Dialect</prop> <prop key="hibernate.hbm2ddl.auto">update</prop> <prop key="hibernate.show\_sql">true</prop> <prop key="hibernate.cache.use\_query\_cache">false</prop> <!-- 显示sql格式 --> <prop key="hibernate.format_sql">false</prop> </props> </property> 最后还有一个解决方法：如果你的数据库表中某个字段不可以不用text类型的，将其改成其他类型（如：varchar等）也可以，这个方法虽然简单，当数据库字段必须用text类型的时候该方法就不行了。</p>

            
            <p class="more">
                <a href="/2015/12/04/2019030500029/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/04/2019030500029/" title="数据库中的字段和Java里面的类型匹配">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/4.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/开发语言/">开发语言</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/11/23/2019030500049/">
    		java 中的断言assert的使用
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-11-23T12:17:44.000Z">2015-11-23</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/assert/" title="assert">assert</a> / 
    
        <a href="/tags/Java/" title="Java">Java</a> / 
    
        <a href="/tags/断言/" title="断言">断言</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>一、assertion的意义和用法 </p>
<p>J2SE 1.4在语言上提供了一个新特性，就是assertion功能，它是该版本在Java语言方面最大的革新。 </p>
<p>从理论上来说，通过 assertion方式可以证明程序的正确性，但是这是一项相当复杂的工作，目前还没有太多的实践意义。 </p>
<p>在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，系统将给出警告或退出。</p>
<p>一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的。</p>
<p>1、语法表示 </p>
<p>在语法上，为了支持assertion，Java增加了一个关键字assert。它包括两种表达式，分别如下：<br>        assert  expression1;<br>        assert  expression1:expression2;</p>
<p>在两种表达式中，expression1表示一个boolean表达式， expression2表示一个基本类型或者是一个对象(Object)，基本类型包括boolean,char,double,float,int和 long。由于所有类都为Object的子类，因此这个参数可以用于所有对象。 </p>
<p>2、含义 </p>
<p>在运行时，如果关闭了assertion功能，这些语句将不起任何作用。如果打开了assertion功能，那么expression1的值将被计算，如果它的值为false，该语句强抛出一个AssertionError对象。</p>
<p>如果assertion语句包括expression2参数，程序将计算出 expression2的结果，然后将这个结果作为AssertionError的构造函数的参数，来创建AssertionError对象，并抛出该对 象；如果expression1值为true，expression2将不被计算。 </p>
<p>一种特殊情况是，如果在计算表达式时，表达式本身抛出Exception，那么assert将停止运行，而抛出这个Exception。 </p>
<p>3、编译 </p>
<p>由于assert是一个新关键字，使用老版本的JDK是无法编译带有assert的 源程序。因此，我们必须使用JDK1.4(或者更新)的Java编译器，在使用Javac命令时，我们必须加上-source 1.4作为参数。-source 1.4表示使用JDK 1.4版本的方式来编译源代码，否则编译就不能通过，因为缺省的Javac编译器使用JDK1.3的语法规则。 </p>
<p>大家在使用eclipse,jbuilder等IDE工具的时候,要注意编译器的版本,使用的jre,不等于是javac 的版本</p>
<p><strong>方法入参检测工具类</strong> Web 应用在接受表单提交的数据后都需要对其进行合法性检查，如果表单数据不合法，请求将被驳回。类似的，当我们在编写类的方法时，也常常需要对方法入参进行合法性检查，如果入参不符合要求，方法将通过抛出异常的方式拒绝后续处理。举一个例子：有一个根据文件名获取输入流的方法：InputStream getData(String file)，为了使方法能够成功执行，必须保证 file 入参不能为 null 或空白字符，否则根本无须进行后继的处理。这时方法的编写者通常会在方法体的最前面编写一段对入参进行检测的代码，如下所示： public InputStream getData(String file) { if (file == null || file.length() == 0|| file.replaceAll(“\\s”, “”).length() == 0) { throw new IllegalArgumentException(“file入参不是有效的文件地址”); } … } 类似以上检测方法入参的代码是非常常见，但是在每个方法中都使用手工编写检测逻辑的方式并不是一个好主意。阅读 Spring 源码，您会发现 Spring 采用一个 org.springframework.util.Assert 通用类完成这一任务。 Assert 翻译为中文为“断言”，使用过 JUnit 的读者都熟知这个概念，它断定某一个实际的运行值和预期想一样，否则就抛出异常。Spring 对方法入参的检测借用了这个概念，其提供的 Assert 类拥有众多按规则对方法入参进行断言的方法，可以满足大部分方法入参检测的要求。这些断言方法在入参不满足要求时就会抛出 IllegalArgumentException。下面，我们来认识一下 Assert 类中的常用断言方法： 断言方法 说明 <code>notNull(Object object)</code> 当 object 不为 null 时抛出异常，notNull(Object object, String message) 方法允许您通过 message 定制异常信息。和 notNull() 方法断言规则相反的方法是 isNull(Object object)/isNull(Object object, String message)，它要求入参一定是 null； <code>isTrue(boolean expression) / isTrue(boolean expression, String message)</code> 当 expression 不为 true 抛出异常； <code>notEmpty(Collection collection) / notEmpty(Collection collection, String message)</code> 当集合未包含元素时抛出异常。notEmpty(Map map) / notEmpty(Map map, String message) 和 notEmpty(Object[] array, String message) / notEmpty(Object[] array, String message) 分别对 Map 和 Object[] 类型的入参进行判断； <code>hasLength(String text) / hasLength(String text, String message)</code> 当 text 为 null 或长度为 0 时抛出异常； <code>hasText(String text) / hasText(String text, String message)</code> text 不能为 null 且必须至少包含一个非空格的字符，否则抛出异常； <code>isInstanceOf(Class clazz, Object obj) / isInstanceOf(Class type, Object obj, String message)</code> 如果 obj 不能被正确造型为 clazz 指定的类将抛出异常； <code>isAssignable(Class superType, Class subType) / isAssignable(Class superType, Class subType, String message)</code> subType 必须可以按类型匹配于 superType，否则将抛出异常； 使用 Assert 断言类可以简化方法入参检测的代码，如 InputStream getData(String file) 在应用 Assert 断言类后，其代码可以简化为以下的形式：</p>
<p>public InputStream getData(String file){ Assert.hasText(file,”file入参不是有效的文件地址”); 使用 Spring 断言类进行方法入参检测 … }</p>
<p>可见使用 Spring 的 Assert 替代自编码实现的入参检测逻辑后，方法的简洁性得到了不少的提高。Assert 不依赖于 Spring 容器，您可以大胆地在自己的应用中使用这个工具类。</p>

            
            <p class="more">
                <a href="/2015/11/23/2019030500049/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/11/23/2019030500049/" title="java 中的断言assert的使用">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/3.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/05/25/2019030500099/">
    		mysql数据库的连接以及增删改查Java代码实现（Statement版）
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-05-25T06:52:54.000Z">2015-05-25</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/Java/" title="Java">Java</a> / 
    
        <a href="/tags/Statement/" title="Statement">Statement</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p>数据库：</p>
<p><strong>[sql]</strong></p>
<ol>
<li><p>create table t1(id int primary key not null auto_increment,name varchar(32),password varchar(32));</p>
</li>
<li><p>insert into t1(name,password) values(‘admin’,’123’);</p>
</li>
<li>insert into t1(name,password) values(‘zhangsan’,’123’);</li>
<li>insert into t1(name,password) values(‘lisi’,’123’);</li>
</ol>
<p>Java代码： mysqlDao.java：</p>
<p><strong>[java]</strong></p>
<ol>
<li><p>package com.dao;</p>
</li>
<li><p>import java.sql.Connection;</p>
</li>
<li>import java.sql.DriverManager;</li>
<li>import java.sql.ResultSet;</li>
<li>import java.sql.SQLException;</li>
<li><p>import java.sql.Statement;</p>
</li>
<li><p>import org.junit.Test;</p>
</li>
<li><p>public class mysqlDao {</p>
</li>
<li><p>private static String driver=”com.mysql.jdbc.Driver”;     //驱动</p>
</li>
<li>private String url=”jdbc:mysql://localhost:3306/test”;    //数据库连接地址</li>
<li>private String user=”root”;     //数据库账户</li>
<li><p>private String password=”11”;      //数据库密码</p>
</li>
<li><p>private Connection connection=null;      //连接</p>
</li>
<li>private Statement stmt=null;      //声明</li>
<li><p>private ResultSet rs=null;     //结果集</p>
</li>
<li><p>private int i=-1;</p>
</li>
<li><p>/*</p>
</li>
<li><ul>
<li>创建驱动</li>
</ul>
</li>
<li><ul>
<li>*/</li>
</ul>
</li>
<li>static{</li>
<li>try {</li>
<li>Class.forName(driver);</li>
<li>} catch (ClassNotFoundException e) {</li>
<li>// TODO Auto-generated catch block</li>
<li>e.printStackTrace();</li>
<li>}</li>
<li><p>}</p>
</li>
<li><p>/*</p>
</li>
<li><ul>
<li>加载驱动</li>
</ul>
</li>
<li><ul>
<li>*/</li>
</ul>
</li>
<li>@Test</li>
<li>public void connect() {</li>
<li>// TODO Auto-generated method stub</li>
<li><p>try {</p>
</li>
<li><p>connection=DriverManager.getConnection(url, user, password);</p>
</li>
<li><p>if(connection!=null){</p>
</li>
<li>System.out.println(“数据库连接成功！”);</li>
<li>}else{</li>
<li>System.out.println(“数据库连接失败！”);</li>
<li><p>}</p>
</li>
<li><p>} catch (SQLException e) {</p>
</li>
<li>// TODO Auto-generated catch block</li>
<li>e.printStackTrace();</li>
<li>}</li>
<li><p>}</p>
</li>
<li><p>/*</p>
</li>
<li><ul>
<li>执行sql语句</li>
</ul>
</li>
<li><ul>
<li>*/</li>
</ul>
</li>
<li>public void doSql(String sql) {</li>
<li><p>// TODO Auto-generated method stub</p>
</li>
<li><p>System.out.println(“This Is mysqlDao.doSql() Method!”);</p>
</li>
<li><p>if(sql!=null){</p>
</li>
<li><p>connect();</p>
</li>
<li><p>try {</p>
</li>
<li><p>stmt=connection.createStatement();</p>
</li>
<li><p>stmt.execute(sql);</p>
</li>
<li><p>} catch (SQLException e) {</p>
</li>
<li>// TODO Auto-generated catch block</li>
<li>e.printStackTrace();</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
<li><p>/*</p>
</li>
<li><ul>
<li>获取影响行数</li>
</ul>
</li>
<li><ul>
<li>*/</li>
</ul>
</li>
<li>public int getUpCount() {</li>
<li><p>// TODO Auto-generated method stub</p>
</li>
<li><p>try {</p>
</li>
<li>i=stmt.getUpdateCount();</li>
<li>} catch (SQLException e) {</li>
<li>// TODO Auto-generated catch block</li>
<li>e.printStackTrace();</li>
<li><p>}</p>
</li>
<li><p>return i;</p>
</li>
<li><p>}</p>
</li>
<li><p>/*</p>
</li>
<li><ul>
<li>获取结果集</li>
</ul>
</li>
<li><ul>
<li>*/</li>
</ul>
</li>
<li><p>public ResultSet getRs() {</p>
</li>
<li><p>try {</p>
</li>
<li>rs=stmt.getResultSet();</li>
<li>} catch (SQLException e) {</li>
<li>// TODO Auto-generated catch block</li>
<li>e.printStackTrace();</li>
<li><p>}</p>
</li>
<li><p>return rs;</p>
</li>
<li><p>}</p>
</li>
<li><p>/*</p>
</li>
<li><ul>
<li>执行关闭方法</li>
</ul>
</li>
<li><ul>
<li>*/</li>
</ul>
</li>
<li>public void close() {</li>
<li><p>// TODO Auto-generated method stub</p>
</li>
<li><p>try {</p>
</li>
<li>if(rs!=null){</li>
<li>rs.close();</li>
<li>}</li>
<li>} catch (SQLException e) {</li>
<li>// TODO Auto-generated catch block</li>
<li>e.printStackTrace();</li>
<li><p>}finally{</p>
</li>
<li><p>try {</p>
</li>
<li><p>if(stmt!=null){</p>
</li>
<li>stmt.close();</li>
<li>}</li>
<li>} catch (SQLException e) {</li>
<li>// TODO Auto-generated catch block</li>
<li>e.printStackTrace();</li>
<li>}finally{</li>
<li>if(connection!=null){</li>
<li>try {</li>
<li>connection.close();</li>
<li>} catch (SQLException e) {</li>
<li>// TODO Auto-generated catch block</li>
<li>e.printStackTrace();</li>
<li>}</li>
<li>}</li>
<li>}</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
</ol>
<p>createSql.java</p>
<p><strong>[java]</strong></p>
<ol>
<li><p>package com.dao;</p>
</li>
<li><p>import java.sql.ResultSet;</p>
</li>
<li><p>import java.sql.SQLException;</p>
</li>
<li><p>import org.junit.Test;</p>
</li>
<li><p>public class createSql {</p>
</li>
<li><p>mysqlDao mysqldao=new mysqlDao();</p>
</li>
<li><p>private String sql;</p>
</li>
<li><p>private int i=-1;</p>
</li>
<li><p>private ResultSet rs=null;</p>
</li>
<li><p>/*</p>
</li>
<li><ul>
<li>插入数据</li>
</ul>
</li>
<li><ul>
<li>*/</li>
</ul>
</li>
<li>@Test</li>
<li>public void insert() {</li>
<li><p>// TODO Auto-generated method stub</p>
</li>
<li><p>sql=”insert into t1(name,password) values(‘lisi’,’1234’)”;    //创建sql语句</p>
</li>
<li>mysqldao.doSql(sql);    //执行sql语句</li>
<li>i=mysqldao.getUpCount();     //获取影响行数</li>
<li>if(i!=-1){</li>
<li>System.out.println(“数据插入成功！”);</li>
<li>}else{</li>
<li>System.out.println(“数据插入失败！”);</li>
<li>}</li>
<li><p>mysqldao.close();      //关闭连接</p>
</li>
<li><p>}</p>
</li>
<li><p>/*</p>
</li>
<li><ul>
<li>删除数据</li>
</ul>
</li>
<li><ul>
<li>*/</li>
</ul>
</li>
<li>@Test</li>
<li>public void delete() {</li>
<li>// TODO Auto-generated method stub</li>
<li>sql=”delete from t1 where id=6”;</li>
<li>mysqldao.doSql(sql);</li>
<li>i=mysqldao.getUpCount();</li>
<li>if(i!=-1){</li>
<li>System.out.println(“数据删除成功！”);</li>
<li>}else{</li>
<li>System.out.println(“数据删除失败！”);</li>
<li>}</li>
<li>mysqldao.close();</li>
<li><p>}</p>
</li>
<li><p>/*</p>
</li>
<li><ul>
<li>修改数据</li>
</ul>
</li>
<li><ul>
<li>*/</li>
</ul>
</li>
<li>@Test</li>
<li>public void update() {</li>
<li>// TODO Auto-generated method stub</li>
<li>sql=”update t1 set name=’wangwu’ where id=1”;</li>
<li>mysqldao.doSql(sql);</li>
<li>i=mysqldao.getUpCount();</li>
<li>if(i!=-1){</li>
<li>System.out.println(“数据更新成功！”);</li>
<li>}else{</li>
<li>System.out.println(“数据更新失败！”);</li>
<li>}</li>
<li>mysqldao.close();</li>
<li><p>}</p>
</li>
<li><p>/*</p>
</li>
<li><ul>
<li>遍历数据</li>
</ul>
</li>
<li><ul>
<li>*/</li>
</ul>
</li>
<li>@Test</li>
<li>public void select() throws SQLException {</li>
<li><p>// TODO Auto-generated method stub</p>
</li>
<li><p>sql=”select * from t1”;</p>
</li>
<li><p>mysqldao.doSql(sql);</p>
</li>
<li><p>rs=mysqldao.getRs();</p>
</li>
<li><p>if(rs!=null){</p>
</li>
<li>rs.last();</li>
<li><p>i=rs.getRow();</p>
</li>
<li><p>if(i&gt;0){</p>
</li>
<li>rs.beforeFirst();</li>
<li><p>while(rs.next()){</p>
</li>
<li><p>String id=rs.getString(“id”);</p>
</li>
<li>String name=rs.getString(“name”);</li>
<li>String password=rs.getString(“password”);</li>
<li>System.out.println(“id:”+id+”  “+”name:”+name+”  password:”+password);</li>
<li>}</li>
<li>}else{</li>
<li>System.out.println(“对不起，没有您要查询的信息！”);</li>
<li><p>}</p>
</li>
<li><p>}else{</p>
</li>
<li>System.out.println(“异常………..”);</li>
<li>}</li>
<li><p>mysqldao.close();</p>
</li>
<li><p>}</p>
</li>
<li><p>}</p>
</li>
</ol>
</blockquote>

            
            <p class="more">
                <a href="/2015/05/25/2019030500099/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/05/25/2019030500099/" title="mysql数据库的连接以及增删改查Java代码实现（Statement版）">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/5.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <span class="page-number current">1</span>
    </nav>
    


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/MySQL/">MySQL</a>
        <span class="badge">(92)</span>
    </li>
    
    <li>
        <a href="/categories/开发语言/">开发语言</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="/categories/Oracle/">Oracle</a>
        <span class="badge">(40)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/">NOSQL</a>
        <span class="badge">(17)</span>
    </li>
    
    <li>
        <a href="/categories/SQL-Server/">SQL Server</a>
        <span class="badge">(13)</span>
    </li>
    
    <li>
        <a href="/categories/其他数据库/">其他数据库</a>
        <span class="badge">(4)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/">Oracle</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/SQL-Server/">SQL Server</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/开发语言/">开发语言</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/MySQL/" title="MySQL">MySQL (71)</a>
  
    <a class="tag-item" href="/tags/位运算/" title="位运算">位运算 (0)</a>
  
    <a class="tag-item" href="/tags/allow/" title="allow">allow (1)</a>
  
    <a class="tag-item" href="/tags/Apache/" title="Apache">Apache (1)</a>
  
    <a class="tag-item" href="/tags/deny/" title="deny">deny (1)</a>
  
    <a class="tag-item" href="/tags/sqlplus/" title="sqlplus">sqlplus (1)</a>
  
    <a class="tag-item" href="/tags/CentOS/" title="CentOS">CentOS (2)</a>
  
    <a class="tag-item" href="/tags/druid/" title="druid">druid (1)</a>
  
    <a class="tag-item" href="/tags/心跳/" title="心跳">心跳 (1)</a>
  
    <a class="tag-item" href="/tags/redis/" title="redis">redis (6)</a>
  
    <a class="tag-item" href="/tags/分库/" title="分库">分库 (1)</a>
  
    <a class="tag-item" href="/tags/分库分表/" title="分库分表">分库分表 (1)</a>
  
    <a class="tag-item" href="/tags/分表/" title="分表">分表 (1)</a>
  
    <a class="tag-item" href="/tags/Oracle/" title="Oracle">Oracle (30)</a>
  
    <a class="tag-item" href="/tags/schedule-job/" title="schedule job">schedule job (1)</a>
  
    <a class="tag-item" href="/tags/事务/" title="事务">事务 (5)</a>
  
    <a class="tag-item" href="/tags/分布式/" title="分布式">分布式 (1)</a>
  
    <a class="tag-item" href="/tags/消息/" title="消息">消息 (1)</a>
  
    <a class="tag-item" href="/tags/KeepAlived/" title="KeepAlived">KeepAlived (1)</a>
  
    <a class="tag-item" href="/tags/数据库/" title="数据库">数据库 (7)</a>
  
    <a class="tag-item" href="/tags/结构同步/" title="结构同步">结构同步 (1)</a>
  
    <a class="tag-item" href="/tags/truncate/" title="truncate">truncate (1)</a>
  
    <a class="tag-item" href="/tags/FineReport/" title="FineReport">FineReport (1)</a>
  
    <a class="tag-item" href="/tags/SQL/" title="SQL">SQL (17)</a>
  
    <a class="tag-item" href="/tags/报表/" title="报表">报表 (1)</a>
  
    <a class="tag-item" href="/tags/数据集/" title="数据集">数据集 (1)</a>
  
    <a class="tag-item" href="/tags/Excel/" title="Excel">Excel (1)</a>
  
    <a class="tag-item" href="/tags/Sqlite/" title="Sqlite">Sqlite (1)</a>
  
    <a class="tag-item" href="/tags/批量/" title="批量">批量 (1)</a>
  
    <a class="tag-item" href="/tags/Linux/" title="Linux">Linux (2)</a>
  
    <a class="tag-item" href="/tags/Character-set/" title="Character set">Character set (1)</a>
  
    <a class="tag-item" href="/tags/NLS-LANG/" title="NLS_LANG">NLS_LANG (1)</a>
  
    <a class="tag-item" href="/tags/rowid/" title="rowid">rowid (2)</a>
  
    <a class="tag-item" href="/tags/重复/" title="重复">重复 (1)</a>
  
    <a class="tag-item" href="/tags/Hash索引/" title="Hash索引">Hash索引 (1)</a>
  
    <a class="tag-item" href="/tags/InnoDB/" title="InnoDB">InnoDB (3)</a>
  
    <a class="tag-item" href="/tags/MyISAM/" title="MyISAM">MyISAM (3)</a>
  
    <a class="tag-item" href="/tags/索引优化/" title="索引优化">索引优化 (1)</a>
  
    <a class="tag-item" href="/tags/mysqldump/" title="mysqldump">mysqldump (2)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="http://www.devba.com" target="_blank" title="软件开发吧">软件开发吧</a>
        </li>
    
        <li>
            <a href="https://www.sqlyun.cn" target="_blank" title="SQL云笔记">SQL云</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>