<!doctype html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8">
    <meta name="baidu-site-verification" content="dIcXMeY8Ya">
    
    <title>`redis`标签下的文章 | 软件开发吧</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="keywords" content="SQL云,SQL云开发,SQL笔记,SQL开发,云开发,MySQL,Oralce,数据库,数据库云,数据库开发,数据库云开发,SQL教程,数据库教程,开发笔记,MySQL笔记,MySQL教程">
    <meta name="description" content="为满足广大程序猿兄弟对日常工作中学习数据库、使用使用数据库资料查询需求，SQL云开发免费将自己整理的各种数据库技术资料分享出来，并希望与广大猿兄一起讨论学习与进步,致力于一起更方便、快捷资料学习查询,实现更安全、高效的数据存储.">

    
    <link rel="alternative" href="/atom.xml" title="软件开发吧" type="application/atom+xml">
    
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
</html>
<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">软件开发吧</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/tags/redis/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/tags/redis/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/tags/redis/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/tags/redis/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/cdneitui" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.github.com/" target="_blank">Hosted by GitHub Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon">
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 按标签分类 -->

    <h3 class="widget-hd">
        <strong>
            
                `redis`标签下的文章
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/01/25/2019030500042/">
    		线上业务Redis数据迁移至SSDB
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-01-25T07:56:38.000Z">2016-01-25</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/redis/" title="redis">redis</a> / 
    
        <a href="/tags/SSDB/" title="SSDB">SSDB</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>1，背景 Redis的持久化只是用于备份数据，而如果作为持久化存储会有一些问题（具体？），因此将Redis数据迁移至SSDB，命令列表见<a href="http://ssdb.io/docs/zh_cn/redis-to-ssdb.html" target="_blank" rel="noopener">http://ssdb.io/docs/zh_cn/redis-to-ssdb.html</a> 2，策略 由于Redis存储的数据很重要，因此为了保证数据迁移的可靠性同时不对线上业务造成影响，采取分步过渡并验证的方式： <img src="/uploads/2016/01/863331b3-221a-3204-9fac-8e0817141cb8.jpg" alt title="点击查看原始大小图片"> 3，关键点 a，修改代码，加入开关切换redis和ssdb的读写使上述几种情况都可以通过配置开关来控制。 b，加入读取SSDB数据的lua接口，并发访问量很大，采取nginx+lua解决。 c，测试并验证。写测试脚本对所有对外接口进行测试，查看数据的返回值并校验数据是否一致。 d，数据同步 <img src="/uploads/2016/01/d541fcfe-aea0-3e88-b0ff-f25ffcade3fc.jpg" alt> 4，问题 a) 当redis和ssdb数据同步时，执行测试脚本显示错误：errno=2001    errmsg=server error: closed。经查是Redis主从同步断开，进而导致从从同步也断开。</p>

            
            <p class="more">
                <a href="/2016/01/25/2019030500042/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/01/25/2019030500042/" title="线上业务Redis数据迁移至SSDB">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/5.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/01/19/2019030500008/">
    		优化Redis内存的9个要点
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-01-19T06:58:27.000Z">2016-01-19</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/redis/" title="redis">redis</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>优化Redis内存的9个要点</p>
<p>1.注意在redis.conf中的小聚合数据类型的特殊编码设置：</p>
<p>hash-max-zipmap-entries 64 (hash-max-ziplist-entries for Redis &gt;= 2.6)</p>
<p>hash-max-zipmap-value 512  (hash-max-ziplist-value for Redis &gt;= 2.6)</p>
<p>list-max-ziplist-entries 512</p>
<p>list-max-ziplist-value 64</p>
<p>zset-max-ziplist-entries 128</p>
<p>zset-max-ziplist-value 64</p>
<p>set-max-intset-entries 512</p>
<p>2.使用32位实例将内存受限在4G内，不过他们的RDB和AOF文件是兼容在32位和64位下去切换使用的。</p>
<p>3。使用bit位级别操作和byte字节级别操作来减少不必要的内存使用</p>
<p>bit位级别操作：GETRANGE, SETRANGE, GETBIT and SETBIT</p>
<p>byte字节级别操作：GETRANGE and SETRANGE</p>
<p>4.尽可能地使用hashes哈希，因为小Hashes会被编码成一个非常小的空间。</p>
<p>5.使用哈希来在Redis的顶部在普通key-value存储上来抽象内存使用效率</p>
<p>6.关于内存分配：</p>
<p>如果maxmemory没有设置的Redis会继续分配内存，因为它认为合适的，因此它可以（逐渐）吃了你的全部可用内存。因此，通常建议配置一些限制。您可能还需要设置maxmemory策略，以noeviction（这不是在一些旧版本的Redis的默认值）。</p>
<p>这使得Redis的返回内存不足的错误写命令，如果当它到达了极限 - 这反过来可能会导致应用程序错误，但不会导致因为内存饥饿而整机死亡。</p>
<p>另外redis 的6种过期策略redis 中的默认的过期策略是volatile-lru 。设置方式</p>
<p>　　config set maxmemory-policy volatile-lru</p>
<p>　　maxmemory-policy 六种方式</p>
<p>　　volatile-lru：只对设置了过期时间的key进行LRU（默认值）</p>
<p>　　allkeys-lru ： 是从所有key里 删除 不经常使用的key</p>
<p>　　volatile-random：随机删除即将过期key</p>
<p>　　allkeys-random：随机删除</p>
<p>　　volatile-ttl ： 删除即将过期的</p>
<p>　　noeviction ： 永不过期，返回错误</p>
<p>　　maxmemory-samples 3 是说每次进行淘汰的时候 会随机抽取3个key 从里面淘汰最不经常使用的（默认选项）</p>
<p>7. 在存到Redis之前先把你的数据压缩下</p>
<p>8.尽量使用短的键（Keys）</p>
<p>9.使用Hashes值存储而不带额外的数据元</p>

            
            <p class="more">
                <a href="/2016/01/19/2019030500008/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/01/19/2019030500008/" title="优化Redis内存的9个要点">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/9.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/01/19/2019030500051/">
    		Linux下安装Redis精要
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-01-19T06:48:40.000Z">2016-01-19</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/redis/" title="redis">redis</a> / 
    
        <a href="/tags/Linux/" title="Linux">Linux</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p><strong>Linux下安装Redis</strong>   <strong>安装chkconfig：</strong> rpm -aq |grep chkconfig chkconfig-1.3.30.1-2 # export PATH=/sbin:$PATH # chkconfig   或是 vi /etc/profile 加入 export PATH=/sbin:$PATH 执行 source /etc/profile 执行 chkconfig   <strong>安装redis:</strong> tar -xvf redis-3.0.6.tar.gz cd redis-3.0.6 make PREFIX=/usr/local/redis install   <strong>配置redis服务:</strong> cp utils/redis_init_script /etc/rc.d/init.d/redis   <strong>添加注册服务：</strong> vi /etc/rc.d/init.d/redis   <strong>第2行添加</strong> # chkconfig:   2345 90 10 # description:  Redis is a persistent key-value database   redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10。   <strong>修改EXEC和CLIEXEC路径（安装文件目录）：</strong> EXEC=/app/re/redis-3.0.6/src/redis-server CLIEXEC=/app/re/redis-3.0.6/src/redis-cli   <strong>redis开启的命令，以后台运行的方式执行。</strong> $EXEC $CONF &amp;   <strong>改完了保存！</strong>   mkdir /etc/redis cp redis.conf /etc/redis/6379.conf   <strong>/etc/profile 加入</strong> export REDIS_HOME=/usr/local/redis export PATH=${PATH}:${REDIS_HOME}/bin   <strong>执行 source /etc/profile</strong>   <strong>注册redis服务：</strong> chkconfig –add redis   #设置为开机自启动服务器 chkconfig redis on #打开服务 service redis start #关闭服务 service redis stop     WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add ‘vm.overcommit_memory = 1’ to /etc/sysctl.conf and then reboot or run the command ‘sysctl vm.overcommit_memory=1’ for this to take effect.   sysctl vm.overcommit_memory=1     $ redis-cli 127.0.0.1:6379&gt; ping PONG 127.0.0.1:6379&gt; set aa bb OK 127.0.0.1:6379&gt; get aa “bb” 127.0.0.1:6379&gt;</p>

            
            <p class="more">
                <a href="/2016/01/19/2019030500051/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/01/19/2019030500051/" title="Linux下安装Redis精要">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/9.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/21/2019030500045/">
    		非关系型数据库redis的yum安装及使用
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-21T03:16:12.000Z">2015-12-21</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/redis/" title="redis">redis</a> / 
    
        <a href="/tags/yum/" title="yum">yum</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>安装Apache yum install httpd rpm -qi httpd 查看Apache信息 centos7 安装redis 安装EPEL wget <a href="http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-5.noarch.rpm" target="_blank" rel="noopener">http://dl.fedoraproject.org/pub/epel/7/x86_64/e/epel-release-7-5.noarch.rpm</a> rpm -ivh epel-release-7-5.noarch.rpm yum install redis systemctl start redis.service systemctl status redis.service systemctl enable redis.service 遵循事务，一个不成功都不成功 redis-cli string类型 set name zouhuying get name  同一个建只允许用一次 setnx  key存在则返回0，不存在就设置 setex 指定键值对对应的有效期 setex haircolor 10 red setrange  替换一部分字符串 zouhuiying/ setrange name 1 h /zhuhuiying mset 设置多个key的值 mset name zouhuiying age 18 mesetnx getset name haoning设置新值获取旧值 getrang name 0 3获取name的0-3个字符 mget 获取多个key的值 incr 递增值 incrby incrby age （+-）3(指定的数字增加减) decr decrby 递减 append append name hhh追加，返回新字符串的长度 strlen  value的长度 hashes类型 hset hset myhash(表) field1（字段） Hello hsetnx setnx hmset  hmget hincr hincrby hdecr hdecrby hexits 测试表中字段是否存在 hlen 表中字段的个数 hdel 删除表中某个字段 hmset user:001 age 66 height 178 hmget useer:001 age height hdel user:001 age hkeys 返回所以字段hkeys user:001 hvals hvals user:001 hgetall user:001   keys and values list类型(双向链表 栈和队列) 栈：先进后出（存放值） 队列：先进先出 （从上到下） push pop lpush mylist zouhuiying（先进后出） rpush mylist ying（先进先出） lrange mylist 0 -1 linsert (插入元素) linsert mylist before “ying” “yingying” lset 替换指定下标的元素  lset mylist 0 “xiaoying” lrem 删除n个和value相同的值 返回删除值得个数 lrem mylist 1 “hello” 删除1个 n= 0：全部删除 n&lt;0 :从尾部删除 ltrim:保留ltrim mylist 1 -1（保留的范围），其他删除 lpop 从头部删除元素 rpop 从尾部删除 rpoplpush （边取边加，可以是两个表） lindex: lindex mylist 0（下标为0的元素） llen:llen mylist (mylist的长度) set sadd scard sdiff sdiffstore sinter sinterstore sismember smembers smove spop srandmember srem sunion sunionstore sscan sortedset zadd zcard zcount zrange zrangebyscore zrank zrem zremrangebyrank zremrangebyscore zrevrange zrevrangebyscore zrevrank zscore zunionstore zscan <a href="http://www.icoolxue.com/play/1489" target="_blank" rel="noopener">http://www.icoolxue.com/play/1489</a> 视频 <a href="http://doc.redisfans.com/" target="_blank" rel="noopener">http://doc.redisfans.com/</a>  命令 redis 常用命令 1.建值相关命令 keys * 返回所以建 keys 正则表达式 exists key检查key是否存在 del key expire key time 设置过期时间（key要存在） ttl key 查看建还有几秒过期 -1：表示已经过期 select （0-15）选择数据库 move key (0-15) persist:移除过期时间 randomkey随机返回一个key rename 重命名 type key :返回key的数据类型 2.服务器相关命令 ping (PONG，表示ping 通) echo 普通echo select quit/exit/control-c退出客户端 dbsize 当前数据库中的key的数量 info：返回相关信息 config get key 返回key的信息 flushdb 删除当前数据库下的所有key flushall 删除所有数据库下的所有key redis的高级应用 安全性：redis.conf-&gt;requirepass mima   登陆redis-cli -a mima   或者redis-cli  auth mima 主从复制：修改redis.conf -&gt;增加slaveof 192.168.139.213 6379(主机IP和端口)   and   masterauth mima（主机redis密码）and bind 0.0.0.0  (telnet 检查从机能否访问主机的端口) 事务处理：multi 进去事务 所有的命令保存在queued中，并不执行。exec后再按照顺序执行命令   取消事务：discard取消所有命令 乐观锁：session1：set age 20/ watch age  / multi/ set age 30/ exec(执行会失败) session2 set age 20 unwatch 清除监视 持久化机制：数据快照 redis.conf -&gt; save 9000 1  快照存在/var/lib/redis/dump.rdb中，二进制文件无法查看 存储操作aof   redis.conf -&gt;appendonly yes-&gt;appendfsync always(最快，性能不好)/appendfsync everysec(每一秒0/appendfsync no（完全依赖os，性能最好，持久化没有保证）快照存在/var/lib/redis/dump.rdb 发布订阅信息：subscribe tv1 /publish tv1 zouhuiying(两个session) 虚拟内存的使用：更改配置文件vm-enabled</p>

            
            <p class="more">
                <a href="/2015/12/21/2019030500045/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/21/2019030500045/" title="非关系型数据库redis的yum安装及使用">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/11/24/2019030500006/">
    		CentOS7安装redis
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-11-24T07:09:26.000Z">2015-11-24</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/redis/" title="redis">redis</a> / 
    
        <a href="/tags/CentOS7/" title="CentOS7">CentOS7</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>本文介绍在CentOS7上安装redis数据库。 系统配置信息如下：  </p>
<p>C代码</p>
<ol>
<li>[linus@localhost ~]$ uname -r</li>
<li>3.10.0-229.20.1.el7.x86_64</li>
<li>[linus@localhost ~]$ more /etc/redhat-release</li>
<li>CentOS Linux release 7.1.1503 (Core)</li>
<li>[linus@localhost ~]$</li>
</ol>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>1、下载Redis，当前最新版本是3.0.5，然后安装。</p>
<ol>
<li>[linus@localhost redis]$ wget <a href="http://download.redis.io/releases/redis-3.0.5.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-3.0.5.tar.gz</a></li>
<li>–2015-11-24 13:33:32–  <a href="http://download.redis.io/releases/redis-3.0.5.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-3.0.5.tar.gz</a></li>
<li>Resolving download.redis.io (download.redis.io)… 109.74.203.151</li>
<li>Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80… connected.</li>
<li>HTTP request sent, awaiting response… 200 OK</li>
<li>Length: 1366160 (1.3M) [application/x-gzip]</li>
<li><p>Saving to: ‘redis-3.0.5.tar.gz’</p>
</li>
<li><p>100%[==============================================&gt;] 1,366,160   40.0KB/s   in 25s</p>
</li>
<li><p>2015-11-24 13:33:58 (54.1 KB/s) - ‘redis-3.0.5.tar.gz’ saved [1366160/1366160]</p>
</li>
<li><p>[linus@localhost redis]$</p>
</li>
<li>[linus@localhost redis]$ ls</li>
<li>redis-3.0.5.tar.gz</li>
<li>[linus@localhost redis]$ tar -zxf redis-3.0.5.tar.gz</li>
<li>[linus@localhost redis]$ cd redis-3.0.5/</li>
<li>[linus@localhost redis-3.0.5]$ make</li>
<li>cd src &amp;&amp; make all</li>
<li>make[1]: Entering directory `/home/linus/redis/redis-3.0.5/src’</li>
<li>rm -rf redis-server redis-sentinel redis-cli redis-benchmark redis-check-dump redis-check-aof <em>.o </em>.gcda <em>.gcno </em>.gcov redis.info lcov-html</li>
<li>(cd ../deps &amp;&amp; make distclean)</li>
<li>make[2]: Entering directory `/home/linus/redis/redis-3.0.5/deps’</li>
<li>(cd hiredis &amp;&amp; make clean) &gt; /dev/null || true</li>
<li>(cd linenoise &amp;&amp; make clean) &gt; /dev/null || true</li>
<li>(cd lua &amp;&amp; make clean) &gt; /dev/null || true</li>
<li>(cd jemalloc &amp;&amp; [ -f Makefile ] &amp;&amp; make distclean) &gt; /dev/null || true</li>
<li>(rm -f .make-*)</li>
<li>make[2]: Leaving directory `/home/linus/redis/redis-3.0.5/deps’</li>
<li>(rm -f .make-*)</li>
<li>echo STD=-std=c99 -pedantic &gt;&gt; .make-settings</li>
<li>echo WARN=-Wall -W &gt;&gt; .make-settings</li>
<li>echo OPT=-O2 &gt;&gt; .make-settings</li>
<li>echo MALLOC=jemalloc &gt;&gt; .make-settings</li>
<li>echo CFLAGS= &gt;&gt; .make-settings</li>
<li>echo LDFLAGS= &gt;&gt; .make-settings</li>
<li>echo REDIS_CFLAGS= &gt;&gt; .make-settings</li>
<li>echo REDIS_LDFLAGS= &gt;&gt; .make-settings</li>
<li>echo PREV_FINAL_CFLAGS=-std=c99 -pedantic -Wall -W -O2 -g -ggdb   -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include &gt;&gt; .make-settings</li>
<li>echo PREV_FINAL_LDFLAGS=  -g -ggdb -rdynamic &gt;&gt; .make-settings</li>
<li>。。。</li>
<li>。。。</li>
<li>LINK redis-server</li>
<li>INSTALL redis-sentinel</li>
<li>CC redis-cli.o</li>
<li>LINK redis-cli</li>
<li>CC redis-benchmark.o</li>
<li>LINK redis-benchmark</li>
<li>CC redis-check-dump.o</li>
<li>LINK redis-check-dump</li>
<li>CC redis-check-aof.o</li>
<li><p>LINK redis-check-aof</p>
</li>
<li><p>Hint: It’s a good idea to run ‘make test’ ;)</p>
</li>
<li><p>make[1]: Leaving directory `/home/linus/redis/redis-3.0.5/src’</p>
</li>
</ol>
<p>然后执行make test进行验证，报如下错误，安装tcl之后就可以正常执行了：</p>
<ol>
<li>[linus@localhost redis-3.0.5]$ make test</li>
<li>cd src &amp;&amp; make test</li>
<li>make[1]: Entering directory `/home/linus/redis/redis-3.0.5/src’</li>
<li>You need tcl 8.5 or newer in order to run the Redis test</li>
<li>make[1]: *** [test] Error 1</li>
<li>make[1]: Leaving directory `/home/linus/redis/redis-3.0.5/src’</li>
<li>make: *** [test] Error 2</li>
<li>[linus@localhost redis-3.0.5]$ make test</li>
<li>…</li>
<li>…</li>
<li><p>The End</p>
</li>
<li><p>Execution time of different units:</p>
</li>
<li>1 seconds - unit/printver</li>
<li>2 seconds - unit/scan</li>
<li>2 seconds - unit/quit</li>
<li>3 seconds - unit/auth</li>
<li>3 seconds - unit/multi</li>
<li>5 seconds - unit/protocol</li>
<li>11 seconds - unit/expire</li>
<li>21 seconds - unit/type/list</li>
<li>35 seconds - unit/other</li>
<li>40 seconds - unit/type/list-2</li>
<li>19 seconds - integration/aof</li>
<li>41 seconds - unit/type/hash</li>
<li>42 seconds - unit/dump</li>
<li>3 seconds - integration/logging</li>
<li>2 seconds - unit/pubsub</li>
<li>8 seconds - integration/rdb</li>
<li>3 seconds - unit/slowlog</li>
<li>2 seconds - unit/introspection</li>
<li>6 seconds - integration/convert-zipmap-hash-on-load</li>
<li>2 seconds - unit/limits</li>
<li>12 seconds - unit/scripting</li>
<li>19 seconds - unit/bitops</li>
<li>67 seconds - unit/type/set</li>
<li>72 seconds - integration/replication-2</li>
<li>30 seconds - unit/memefficiency</li>
<li>77 seconds - unit/type/zset</li>
<li>79 seconds - unit/sort</li>
<li>79 seconds - unit/aofrw</li>
<li>84 seconds - unit/basic</li>
<li>42 seconds - unit/maxmemory</li>
<li>91 seconds - unit/type/list-3</li>
<li>117 seconds - integration/replication-4</li>
<li>67 seconds - unit/hyperloglog</li>
<li>122 seconds - integration/replication-3</li>
<li>137 seconds - integration/replication</li>
<li>134 seconds - integration/replication-psync</li>
<li><p>114 seconds - unit/obuf-limits</p>
</li>
<li><p>\o/ All tests passed without errors!</p>
</li>
<li><p>Cleanup: may take some time… OK</p>
</li>
<li>make[1]: Leaving directory `/home/linus/redis/redis-3.0.5/src’</li>
<li>[linus@localhost redis-3.0.5]$</li>
</ol>
<p>安装完成后，可以切换src目录下，执行redis-server命令启动redis服务器：  </p>
<ol>
<li>[linus@localhost src]$ ./redis-server &amp;</li>
<li>[1] 8921</li>
<li>[linus@localhost src]$ 8921:C 24 Nov 13:44:17.995 # Warning: no config file specified, using the default config. In order to specify a config file use ./redis-server /path/to/redis.conf</li>
<li>8921:M 24 Nov 13:44:17.997 # You requested maxclients of 10000 requiring at least 10032 max file descriptors.</li>
<li>8921:M 24 Nov 13:44:17.997 # Redis can’t set maximum open files to 10032 because of OS error: Operation not permitted.</li>
<li>8921:M 24 Nov 13:44:17.997 # Current maximum open files is 4096. maxclients has been reduced to 4064 to compensate for low ulimit. If you need higher maxclients increase ‘ulimit -n’.</li>
<li>_._</li>
<li><em>.-<code></code>__ ‘’-.</em></li>
<li><em>.-<code></code>    <code>.</code></em>.  ‘’-._           Redis 3.0.5 (00000000/0) 64 bit</li>
<li>.-<code>.-`</code>.  <code>`</code>\/    _.,_ ‘’-._</li>
<li>(    ‘      ,       .-<code>|</code>,    )     Running in standalone mode</li>
<li>|<code>-._</code>-…-<code>__...-.`</code>-._|’` _.-‘|     Port: 6379</li>
<li>|    <code>-._</code>._    /     _.-‘    |     PID: 8921</li>
<li><code>-._</code>-._  `-./  _.-‘    _.-‘</li>
<li>|<code>-._</code>-._    `-.__.-‘    <em>.-‘</em>.-‘|</li>
<li>|    <code>-._</code>-._        <em>.-‘</em>.-‘    |           <a href="http://redis.io" target="_blank" rel="noopener">http://redis.io</a>        </li>
<li><code>-._</code>-.<em>`-.__.-‘</em>.-‘    _.-‘</li>
<li>|<code>-._</code>-._    `-.__.-‘    <em>.-‘</em>.-‘|</li>
<li>|    <code>-._</code>-._        <em>.-‘</em>.-‘    |</li>
<li><code>-._</code>-.<em>`-.__.-‘</em>.-‘    _.-‘</li>
<li><code>-._</code>-.__.-‘    _.-‘</li>
<li>`-._        _.-‘</li>
<li><p>`-.__.-‘</p>
</li>
<li><p>8921:M 24 Nov 13:44:17.998 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</p>
</li>
<li>8921:M 24 Nov 13:44:17.999 # Server started, Redis version 3.0.5</li>
<li>8921:M 24 Nov 13:44:17.999 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add ‘vm.overcommit_memory = 1’ to /etc/sysctl.conf and then reboot or run the command ‘sysctl vm.overcommit_memory=1’ for this to take effect.</li>
<li>8921:M 24 Nov 13:44:17.999 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command ‘echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled’ as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</li>
<li>8921:M 24 Nov 13:44:17.999 * DB loaded from disk: 0.000 seconds</li>
<li><p>8921:M 24 Nov 13:44:17.999 * The server is now ready to accept connections on port 6379</p>
<p>此时可以通过redis-cli命令连接该redis服务器，并且可以通过SHUTDOWN命令关闭服务器：</p>
</li>
<li><p>[linus@localhost src]$ ./redis-cli</p>
</li>
<li>127.0.0.1:6379&gt; INFO</li>
<li><h1 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h1></li>
<li>redis_version:3.0.5</li>
<li>redis_git_sha1:00000000</li>
<li>redis_git_dirty:0</li>
<li>redis_build_id:cdf25f7608cc4cbe</li>
<li>redis_mode:standalone</li>
<li>os:Linux 3.10.0-229.20.1.el7.x86_64 x86_64</li>
<li>arch_bits:64</li>
<li>multiplexing_api:epoll</li>
<li>gcc_version:4.8.3</li>
<li>process_id:8921</li>
<li>run_id:c4bf78bec7e54a517634bb62430406946c91733d</li>
<li>tcp_port:6379</li>
<li>uptime_in_seconds:104</li>
<li>uptime_in_days:0</li>
<li>hz:10</li>
<li>lru_clock:5503385</li>
<li><p>config_file:</p>
</li>
<li><h1 id="Clients"><a href="#Clients" class="headerlink" title="Clients"></a>Clients</h1></li>
<li>connected_clients:1</li>
<li>client_longest_output_list:0</li>
<li>client_biggest_input_buf:0</li>
<li><p>blocked_clients:0</p>
</li>
<li><h1 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h1></li>
<li>used_memory:508712</li>
<li>used_memory_human:496.79K</li>
<li>used_memory_rss:8024064</li>
<li>used_memory_peak:508712</li>
<li>used_memory_peak_human:496.79K</li>
<li>used_memory_lua:36864</li>
<li>mem_fragmentation_ratio:15.77</li>
<li><p>mem_allocator:jemalloc-3.6.0</p>
</li>
<li><h1 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h1></li>
<li>loading:0</li>
<li>rdb_changes_since_last_save:0</li>
<li>rdb_bgsave_in_progress:0</li>
<li>rdb_last_save_time:1448343857</li>
<li>rdb_last_bgsave_status:ok</li>
<li>rdb_last_bgsave_time_sec:-1</li>
<li>rdb_current_bgsave_time_sec:-1</li>
<li>aof_enabled:0</li>
<li>aof_rewrite_in_progress:0</li>
<li>aof_rewrite_scheduled:0</li>
<li>aof_last_rewrite_time_sec:-1</li>
<li>aof_current_rewrite_time_sec:-1</li>
<li>aof_last_bgrewrite_status:ok</li>
<li><p>aof_last_write_status:ok</p>
</li>
<li><h1 id="Stats"><a href="#Stats" class="headerlink" title="Stats"></a>Stats</h1></li>
<li>total_connections_received:1</li>
<li>total_commands_processed:0</li>
<li>instantaneous_ops_per_sec:0</li>
<li>total_net_input_bytes:14</li>
<li>total_net_output_bytes:0</li>
<li>instantaneous_input_kbps:0.00</li>
<li>instantaneous_output_kbps:0.00</li>
<li>rejected_connections:0</li>
<li>sync_full:0</li>
<li>sync_partial_ok:0</li>
<li>sync_partial_err:0</li>
<li>expired_keys:0</li>
<li>evicted_keys:0</li>
<li>keyspace_hits:0</li>
<li>keyspace_misses:0</li>
<li>pubsub_channels:0</li>
<li>pubsub_patterns:0</li>
<li>latest_fork_usec:0</li>
<li><p>migrate_cached_sockets:0</p>
</li>
<li><h1 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h1></li>
<li>role:master</li>
<li>connected_slaves:0</li>
<li>master_repl_offset:0</li>
<li>repl_backlog_active:0</li>
<li>repl_backlog_size:1048576</li>
<li>repl_backlog_first_byte_offset:0</li>
<li><p>repl_backlog_histlen:0</p>
</li>
<li><h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1></li>
<li>used_cpu_sys:0.10</li>
<li>used_cpu_user:0.04</li>
<li>used_cpu_sys_children:0.00</li>
<li><p>used_cpu_user_children:0.00</p>
</li>
<li><h1 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h1></li>
<li><p>cluster_enabled:0</p>
</li>
<li><h1 id="Keyspace"><a href="#Keyspace" class="headerlink" title="Keyspace"></a>Keyspace</h1></li>
<li>127.0.0.1:6379&gt;</li>
<li>127.0.0.1:6379&gt; SHUTDOWN</li>
<li><p>not connected&gt;</p>
</li>
<li><p>服务器端会打印：</p>
</li>
<li>8921:M 24 Nov 13:46:52.838 # User requested shutdown…</li>
<li>8921:M 24 Nov 13:46:52.838 * Saving the final RDB snapshot before exiting.</li>
<li>8921:M 24 Nov 13:46:52.844 * DB saved on disk</li>
<li>8921:M 24 Nov 13:46:52.844 # Redis is now ready to exit, bye bye…</li>
</ol>
<p>服务器端配置：   最关键的配置以下选项：</p>
<ol>
<li><h1 id="By-default-Redis-does-not-run-as-a-daemon-Use-‘yes’-if-you-need-it"><a href="#By-default-Redis-does-not-run-as-a-daemon-Use-‘yes’-if-you-need-it" class="headerlink" title="By default Redis does not run as a daemon. Use ‘yes’ if you need it."></a>By default Redis does not run as a daemon. Use ‘yes’ if you need it.</h1></li>
<li><h1 id="Note-that-Redis-will-write-a-pid-file-in-var-run-redis-pid-when-daemonized"><a href="#Note-that-Redis-will-write-a-pid-file-in-var-run-redis-pid-when-daemonized" class="headerlink" title="Note that Redis will write a pid file in /var/run/redis.pid when daemonized."></a>Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</h1></li>
<li>daemonize yes</li>
<li><h1 id="Specify-the-server-verbosity-level"><a href="#Specify-the-server-verbosity-level" class="headerlink" title="Specify the server verbosity level."></a>Specify the server verbosity level.</h1></li>
<li><h1 id="This-can-be-one-of"><a href="#This-can-be-one-of" class="headerlink" title="This can be one of:"></a>This can be one of:</h1></li>
<li><h1 id="debug-a-lot-of-information-useful-for-development-testing"><a href="#debug-a-lot-of-information-useful-for-development-testing" class="headerlink" title="debug (a lot of information, useful for development/testing)"></a>debug (a lot of information, useful for development/testing)</h1></li>
<li><h1 id="verbose-many-rarely-useful-info-but-not-a-mess-like-the-debug-level"><a href="#verbose-many-rarely-useful-info-but-not-a-mess-like-the-debug-level" class="headerlink" title="verbose (many rarely useful info, but not a mess like the debug level)"></a>verbose (many rarely useful info, but not a mess like the debug level)</h1></li>
<li><h1 id="notice-moderately-verbose-what-you-want-in-production-probably"><a href="#notice-moderately-verbose-what-you-want-in-production-probably" class="headerlink" title="notice (moderately verbose, what you want in production probably)"></a>notice (moderately verbose, what you want in production probably)</h1></li>
<li><h1 id="warning-only-very-important-critical-messages-are-logged"><a href="#warning-only-very-important-critical-messages-are-logged" class="headerlink" title="warning (only very important / critical messages are logged)"></a>warning (only very important / critical messages are logged)</h1></li>
<li>loglevel notice</li>
<li><h1 id="Specify-the-log-file-name-Also-the-empty-string-can-be-used-to-force"><a href="#Specify-the-log-file-name-Also-the-empty-string-can-be-used-to-force" class="headerlink" title="Specify the log file name. Also the empty string can be used to force"></a>Specify the log file name. Also the empty string can be used to force</h1></li>
<li><h1 id="Redis-to-log-on-the-standard-output-Note-that-if-you-use-standard"><a href="#Redis-to-log-on-the-standard-output-Note-that-if-you-use-standard" class="headerlink" title="Redis to log on the standard output. Note that if you use standard"></a>Redis to log on the standard output. Note that if you use standard</h1></li>
<li><h1 id="output-for-logging-but-daemonize-logs-will-be-sent-to-dev-null"><a href="#output-for-logging-but-daemonize-logs-will-be-sent-to-dev-null" class="headerlink" title="output for logging but daemonize, logs will be sent to /dev/null"></a>output for logging but daemonize, logs will be sent to /dev/null</h1></li>
<li>logfile /var/log/redis.log</li>
<li><h1 id="The-working-directory"><a href="#The-working-directory" class="headerlink" title="The working directory."></a>The working directory.</h1></li>
<li>#</li>
<li><h1 id="The-DB-will-be-written-inside-this-directory-with-the-filename-specified"><a href="#The-DB-will-be-written-inside-this-directory-with-the-filename-specified" class="headerlink" title="The DB will be written inside this directory, with the filename specified"></a>The DB will be written inside this directory, with the filename specified</h1></li>
<li><h1 id="above-using-the-‘dbfilename’-configuration-directive"><a href="#above-using-the-‘dbfilename’-configuration-directive" class="headerlink" title="above using the ‘dbfilename’ configuration directive."></a>above using the ‘dbfilename’ configuration directive.</h1></li>
<li>#</li>
<li><h1 id="The-Append-Only-File-will-also-be-created-inside-this-directory"><a href="#The-Append-Only-File-will-also-be-created-inside-this-directory" class="headerlink" title="The Append Only File will also be created inside this directory."></a>The Append Only File will also be created inside this directory.</h1></li>
<li>#</li>
<li><h1 id="Note-that-you-must-specify-a-directory-here-not-a-file-name"><a href="#Note-that-you-must-specify-a-directory-here-not-a-file-name" class="headerlink" title="Note that you must specify a directory here, not a file name."></a>Note that you must specify a directory here, not a file name.</h1></li>
<li><p>dir ./</p>
<p>添加启动脚本/etc/init.d/redis：</p>
</li>
<li><p>#!/bin/sh</p>
</li>
<li>#</li>
<li><h1 id="redis-Startup-script-for-Redis-Server"><a href="#redis-Startup-script-for-Redis-Server" class="headerlink" title="redis        Startup script for Redis Server"></a>redis        Startup script for Redis Server</h1></li>
<li>#</li>
<li><h1 id="chkconfig-90-10"><a href="#chkconfig-90-10" class="headerlink" title="chkconfig: - 90 10"></a>chkconfig: - 90 10</h1></li>
<li><h1 id="description-Redis-is-an-open-source-advanced-key-value-store"><a href="#description-Redis-is-an-open-source-advanced-key-value-store" class="headerlink" title="description: Redis is an open source, advanced key-value store."></a>description: Redis is an open source, advanced key-value store.</h1></li>
<li>#</li>
<li><h1 id="processname-redis-server"><a href="#processname-redis-server" class="headerlink" title="processname: redis-server"></a>processname: redis-server</h1></li>
<li><h1 id="config-etc-redis-conf"><a href="#config-etc-redis-conf" class="headerlink" title="config: /etc/redis.conf"></a>config: /etc/redis.conf</h1></li>
<li><h1 id="pidfile-var-run-redis-pid"><a href="#pidfile-var-run-redis-pid" class="headerlink" title="pidfile: /var/run/redis.pid"></a>pidfile: /var/run/redis.pid</h1></li>
<li><p>REDISPORT=6379</p>
</li>
<li><h1 id="下面的目录要看编译的目录，这两个文件会在编译目录的src目录下。"><a href="#下面的目录要看编译的目录，这两个文件会在编译目录的src目录下。" class="headerlink" title="下面的目录要看编译的目录，这两个文件会在编译目录的src目录下。"></a>下面的目录要看编译的目录，这两个文件会在编译目录的src目录下。</h1></li>
<li>EXEC=/usr/local/bin/redis-server</li>
<li><p>REDIS_CLI=/usr/local/bin/redis-cli</p>
</li>
<li><p>PIDFILE=/var/run/redis.pid</p>
</li>
<li><h1 id="下面的目录要看编译的目录，这个文件会在编译目录下。"><a href="#下面的目录要看编译的目录，这个文件会在编译目录下。" class="headerlink" title="下面的目录要看编译的目录，这个文件会在编译目录下。"></a>下面的目录要看编译的目录，这个文件会在编译目录下。</h1></li>
<li><p>CONF=”/usr/src/redis-2.8.13/redis.conf”</p>
</li>
<li><p>case “$1” in</p>
</li>
<li>start)</li>
<li>if [ -f $PIDFILE ]</li>
<li>then</li>
<li>echo “$PIDFILE exists, process is already running or crashed”</li>
<li>else</li>
<li>echo “Starting Redis server…”</li>
<li>$EXEC $CONF</li>
<li>fi</li>
<li>if [ “$?”=”0” ]</li>
<li>then</li>
<li>echo “Redis is running…”</li>
<li>fi</li>
<li>;;</li>
<li>stop)</li>
<li>if [ ! -f $PIDFILE ]</li>
<li>then</li>
<li>echo “$PIDFILE does not exist, process is not running”</li>
<li>else</li>
<li>PID=$(cat $PIDFILE)</li>
<li>echo “Stopping …”</li>
<li>$REDIS_CLI -p $REDISPORT SHUTDOWN</li>
<li>while [ -x ${PIDFILE} ]</li>
<li>do</li>
<li>echo “Waiting for Redis to shutdown …”</li>
<li>sleep 1</li>
<li>done</li>
<li>echo “Redis stopped”</li>
<li>fi</li>
<li>;;</li>
<li>restart|force-reload)</li>
<li>${0} stop</li>
<li>${0} start</li>
<li>;;</li>
<li>*)</li>
<li>echo “Usage: /etc/init.d/redis {start|stop|restart|force-reload}” &gt;&amp;2</li>
<li>exit 1</li>
<li><p>esac</p>
<p>添加redis为系统的服务：</p>
</li>
<li><p>[root@localhost redis]# ll /etc/init.d/redis</p>
</li>
<li>-rw-r–r–. 1 root root 1394 Nov 24 14:06 /etc/init.d/redis</li>
<li>[root@localhost redis]# chmod +x /etc/init.d/redis</li>
<li>[root@localhost redis]# ll /etc/init.d/redis</li>
<li>-rwxr-xr-x. 1 root root 1394 Nov 24 14:06 /etc/init.d/redis</li>
<li>[root@localhost redis]#</li>
<li>[root@localhost redis]# chkconfig –add redis</li>
<li>[root@localhost redis]# chkconfig redis on</li>
<li><p>[root@localhost redis]# chkconfig</p>
</li>
<li><p>Note: This output shows SysV services only and does not include native</p>
</li>
<li>systemd services. SysV configuration data might be overridden by native</li>
<li><p>systemd configuration.</p>
</li>
<li><p>If you want to list systemd services use ‘systemctl list-unit-files’.</p>
</li>
<li>To see services enabled on particular target use</li>
<li><p>‘systemctl list-dependencies [target]‘.</p>
</li>
<li><p>netconsole      0:off   1:off   2:off   3:off   4:off   5:off   6:off</p>
</li>
<li>network         0:off   1:off   2:on    3:on    4:on    5:on    6:off</li>
<li>redis           0:off   1:off   2:on    3:on    4:on    5:on    6:off</li>
<li>[root@localhost redis]#</li>
</ol>
<p>ok，现在就安装好了。启动redis使用<code>service redis start</code> 或者<code>/etc/init.d/redis start</code> ，停止redis的命令<code>service redis stop</code> 或者<code>/etc/init.d/redis stop。</code></p>

            
            <p class="more">
                <a href="/2015/11/24/2019030500006/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/11/24/2019030500006/" title="CentOS7安装redis">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/4.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/11/24/2019030500153/">
    		redis数据类型
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-11-24T06:23:53.000Z">2015-11-24</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/redis/" title="redis">redis</a> / 
    
        <a href="/tags/数据类型/" title="数据类型">数据类型</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <h1 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis - 数据类型"></a>Redis - 数据类型</h1><p>Redis支持5种类型的数据类型，它描述如下的：</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Redis字符串是字节序列。Redis字符串是二进制安全的，这意味着他们有一个已知的长度没有任何特殊字符终止，所以你可以存储任何东西，512兆为上限。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>redis 127.0.0.1:6379&gt; SET name “yiibai”<br>OK<br>redis 127.0.0.1:6379&gt; GET name<br>“yiibai”</p>
<p>上面是Redis的set和get命令的例子，Redis名称为yiibai使用的key存储在Redis的字符串值。</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>Redis的哈希是键值对的集合。 Redis的哈希值是字符串字段和字符串值之间的映射，因此它们被用来表示对象</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>redis 127.0.0.1:6379&gt; HMSET user:1 username yiibai password yiibai points 200<br>OK<br>redis 127.0.0.1:6379&gt; HGETALL user:1<br> 1) “username”<br>2) “yiibai”<br>3) “password”<br>4) “yiibai”<br>5) “points”<br>6) “200” </p>
<p>在上面的例子中的哈希数据类型，用于存储其中包含的用户的基本信息用户的对象。这里HMSET，HEGTALL用户命令user:1是键。</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Redis的列表是简单的字符串列表，排序插入顺序。您可以添加元素到Redis的列表的头部或尾部。</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>redis 127.0.0.1:6379&gt; lpush tutoriallist redis<br>(integer) 1<br>redis 127.0.0.1:6379&gt; lpush tutoriallist mongodb<br>(integer) 2<br>redis 127.0.0.1:6379&gt; lpush tutoriallist rabitmq<br>(integer) 3<br>redis 127.0.0.1:6379&gt; lrange tutoriallist 0 10<br> 1) “rabitmq”<br>2) “mongodb”<br>3) “redis” </p>
<p>列表的最大长度为 232 - 1 元素（4294967295，每个列表中可容纳超过4十亿的元素）。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Redis的集合是字符串的无序集合。在Redis您可以添加，删除和测试文件是否存在，在成员O（1）的时间复杂度。</p>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>redis 127.0.0.1:6379&gt; sadd tutoriallist redis<br>(integer) 1<br>redis 127.0.0.1:6379&gt; sadd tutoriallist mongodb<br>(integer) 1<br>redis 127.0.0.1:6379&gt; sadd tutoriallist rabitmq<br>(integer) 1<br>redis 127.0.0.1:6379&gt; sadd tutoriallist rabitmq<br>(integer) 0<br>redis 127.0.0.1:6379&gt; smembers tutoriallist<br> 1) “rabitmq”<br>2) “mongodb”<br>3) “redis” </p>
<p><strong>注意：</strong>在上面的例子中rabitmq集合添加加两次，但由于集合元素具有唯一属性。 集合中的元素最大数量为 232 - 1 （4294967295，可容纳超过4十亿元素）。</p>
<h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><p>Redis的有序集合类似于Redis的集合，字符串不重复的集合。不同的是，一个有序集合的每个成员用分数，以便采取有序set命令，从最小的到最大的成员分数有关。虽然成员具有唯一性，但分数可能会重复。</p>
<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h3><p>redis 127.0.0.1:6379&gt; zadd tutoriallist 0 redis<br>(integer) 1<br>redis 127.0.0.1:6379&gt; zadd tutoriallist 0 mongodb<br>(integer) 1<br>redis 127.0.0.1:6379&gt; zadd tutoriallist 0 rabitmq<br>(integer) 1<br>redis 127.0.0.1:6379&gt; zadd tutoriallist 0 rabitmq<br>(integer) 0<br>redis 127.0.0.1:6379&gt; ZRANGEBYSCORE tutoriallist 0 1000<br> 1) “redis”<br>2) “mongodb”<br>3) “rabitmq” </p>
<h1 id="Redis-keys"><a href="#Redis-keys" class="headerlink" title="Redis - keys"></a>Redis - keys</h1><p>Redis keys命令用于在Redis的管理键。Redis keys命令使用语法如下所示：</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>redis 127.0.0.1:6379&gt; COMMAND KEY_NAME</p>
<h3 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h3><p>redis 127.0.0.1:6379&gt; SET yiibai redis<br>OK<br>redis 127.0.0.1:6379&gt; DEL yiibai<br>(integer) 1</p>
<p>在上面的例子中DEL是命令，而yiibai是key。如果key被删除，那么输出该命令将是（整数）1，否则它会是（整数）0</p>
<h1 id="Redis-Strings"><a href="#Redis-Strings" class="headerlink" title="Redis - Strings"></a>Redis - Strings</h1><p>Redis strings命令用于在Redis的管理字符串值。Redis strings命令的使用语法，如下所示：</p>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>redis 127.0.0.1:6379&gt; COMMAND KEY_NAME</p>
<h2 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h2><p>redis 127.0.0.1:6379&gt; SET yiibai redis<br>OK<br>redis 127.0.0.1:6379&gt; GET yiibai<br>“redis”</p>
<p>在上面的例子SET和GET是命令，而yiibai是key。</p>
<h1 id="Redis-哈希"><a href="#Redis-哈希" class="headerlink" title="Redis - 哈希"></a>Redis - 哈希</h1><p>Redis的哈希值是字符串字段和字符串值之间的映射，所以他们是代表对象的完美数据类型 在Redis的哈希值，最多可存储超过400十亿字段 - 值对。</p>
<h2 id="例子-7"><a href="#例子-7" class="headerlink" title="例子"></a>例子</h2><p>redis 127.0.0.1:6379&gt; HMSET yiibai name “redis tutorial” description “redis basic commands for caching” likes 20 visitors 23000<br>OK<br>redis 127.0.0.1:6379&gt; HGETALL yiibai<br> 1) “name”<br>2) “redis tutorial”<br>3) “description”<br>4) “redis basic commands for caching”<br>5) “likes”<br>6) “20”<br>7) “visitors”<br>8) “23000” </p>
<p>在上面的例子中，已经在哈希命名yiibai的Redis集合名为tutorials（name, description, likes, visitors）</p>
<h1 id="Redis-列表"><a href="#Redis-列表" class="headerlink" title="Redis - 列表"></a>Redis - 列表</h1><p>Redis的列表是简单的字符串列表，排序插入顺序。您可以添加Redis元素在列表头部或列表的尾部。 列表的最大长度为 232 - 1 个元素（每个列表元素个数超过4294967295）。</p>
<h2 id="例子-8"><a href="#例子-8" class="headerlink" title="例子"></a>例子</h2><p>redis 127.0.0.1:6379&gt; LPUSH tutorials redis<br>(integer) 1<br>redis 127.0.0.1:6379&gt; LPUSH tutorials mongodb<br>(integer) 2<br>redis 127.0.0.1:6379&gt; LPUSH tutorials mysql<br>(integer) 3<br>redis 127.0.0.1:6379&gt; LRANGE tutorials 0 10<br> 1) “mysql”<br>2) “mongodb”<br>3) “redis” </p>
<p>在上述例子中的三个值被插入在redis列表名为LPUSH的命令教程。</p>
<h1 id="Redis-集合"><a href="#Redis-集合" class="headerlink" title="Redis - 集合"></a>Redis - 集合</h1><p>Redis的集合是唯一的字符串的无序集合。集合的唯一性不允许数据的重复的键。 在Redis的集合添加，删除和测试文件是否存在成员在O（1）（常数时间不管里面包含的元素集合的数量）。集合的最大长度为 232 - 1 个元素（每集合超过4294967295元素）。</p>
<h2 id="例子-9"><a href="#例子-9" class="headerlink" title="例子"></a>例子</h2><p>redis 127.0.0.1:6379&gt; SADD tutorials redis<br>(integer) 1<br>redis 127.0.0.1:6379&gt; SADD tutorials mongodb<br>(integer) 1<br>redis 127.0.0.1:6379&gt; SADD tutorials mysql<br>(integer) 1<br>redis 127.0.0.1:6379&gt; SADD tutorials mysql<br>(integer) 0<br>redis 127.0.0.1:6379&gt; SMEMBERS tutorials<br> 1) “mysql”<br>2) “mongodb”<br>3) “redis” </p>
<p>在上述例子中的三个值被命令SADD插入redis的集合名称tutorials。</p>
<h1 id="Redis有序集"><a href="#Redis有序集" class="headerlink" title="Redis有序集"></a>Redis有序集</h1><p>Redis的有序集合类似Redis的集合存储在设定值具有唯一性。不同的是，一个有序集合的每个成员用分数，以便采取有序set命令，从最小的到最大的分数有关。 在Redis的有序set添加，删除和测试存在成员O（1）（固定时间，无论里面包含集合元素的数量）。列表的最大长度为 232 - 1 个元素（每集合超过4294967295元素）。</p>
<h2 id="例子-10"><a href="#例子-10" class="headerlink" title="例子"></a>例子</h2><p>redis 127.0.0.1:6379&gt; ZADD tutorials 1 redis<br>(integer) 1<br>redis 127.0.0.1:6379&gt; ZADD tutorials 2 mongodb<br>(integer) 1<br>redis 127.0.0.1:6379&gt; ZADD tutorials 3 mysql<br>(integer) 1<br>redis 127.0.0.1:6379&gt; ZADD tutorials 3 mysql<br>(integer) 0<br>redis 127.0.0.1:6379&gt; ZADD tutorials 4 mysql<br>(integer) 0<br>redis 127.0.0.1:6379&gt; ZRANGE tutorials 0 10 WITHSCORES<br> 1) “redis”<br>2) “1”<br>3) “mongodb”<br>4) “2”<br>5) “mysql”<br>6) “4” </p>
<p>在上述例子中的三个值被命令ZADD插入其得分在redis的有序集命名为tutorials。</p>
<h1 id="Redis-HyperLogLog"><a href="#Redis-HyperLogLog" class="headerlink" title="Redis - HyperLogLog"></a>Redis - HyperLogLog</h1><p>Redis的HyperLogLog使用随机化，以提供唯一的元素数目近似的集合只使用一个常数，并且体积小，少量内存的算法。 HyperLogLog提供，即使每个使用了非常少量的内存（12千字节），标准误差为集合的基数非常近似，没有限制的条目数，可以指定，除非接近 264个条目。</p>
<h3 id="例子-11"><a href="#例子-11" class="headerlink" title="例子"></a>例子</h3><p>下面的示例说明Redis的HyperLogLog工作原理：</p>
<p>redis 127.0.0.1:6379&gt; PFADD tutorials “redis”<br> 1) (integer) 1<br>redis 127.0.0.1:6379&gt; PFADD tutorials “mongodb”<br> 1) (integer) 1<br>redis 127.0.0.1:6379&gt; PFADD tutorials “mysql”<br> 1) (integer) 1<br>redis 127.0.0.1:6379&gt; PFCOUNT tutorials<br> (integer) 3 </p>
<h1 id="Redis-订阅"><a href="#Redis-订阅" class="headerlink" title="Redis - 订阅"></a>Redis - 订阅</h1><p>Redis的订阅实现了邮件系统，发送者（在Redis的术语中被称为发布者）发送的邮件，而接收器（用户）接收它们。由该消息传送的链路被称为通道。 在Redis客户端可以订阅任何数目的通道。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下举例说明如何发布用户的概念工作。在下面的例子给出一个客户端订阅一个通道名为redisChat</p>
<p>redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat<br> Reading messages… (press Ctrl-C to quit)<br>1) “subscribe”<br>2) “redisChat”<br>3) (integer) 1 </p>
<p>现在，两个客户端都发布在同一个命名通道redisChat消息，并且以上订阅客户端接收消息。</p>
<p>redis 127.0.0.1:6379&gt; PUBLISH redisChat “Redis is a great caching technique”<br> (integer) 1<br>redis 127.0.0.1:6379&gt; PUBLISH redisChat “Learn redis by tutorials point”<br> (integer) 1<br> 1) “message”<br>2) “redisChat”<br>3) “Redis is a great caching technique”<br>1) “message”<br>2) “redisChat”<br>3) “Learn redis by tutorials point” </p>
<h1 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis - 事务"></a>Redis - 事务</h1><p>Redis事务让一组命令在单个步骤执行。事务中有两个属性，说明如下：</p>
<ul>
<li>在一个事务中的所有命令按顺序执行作为单个隔离操作。通过另一个客户端发出的请求在Redis的事务的过程中执行，这是不可能的。</li>
<li>Redis的事务具有原子性。原子意味着要么所有的命令都执行或都不执行。</li>
</ul>
<h2 id="例子-12"><a href="#例子-12" class="headerlink" title="例子"></a>例子</h2><p>Redis的事务由指令多重发起，然后需要传递在事务，而且整个事务是通过执行命令EXEC执行命令列表。</p>
<p>redis 127.0.0.1:6379&gt; MULTI<br>OK<br>List of commands here<br>redis 127.0.0.1:6379&gt; EXEC</p>
<h3 id="例子-13"><a href="#例子-13" class="headerlink" title="例子"></a>例子</h3><p>以下举例说明Redis事务如何启动并执行。</p>
<p>redis 127.0.0.1:6379&gt; MULTI<br>OK<br>redis 127.0.0.1:6379&gt; SET tutorial redis<br>QUEUED<br>redis 127.0.0.1:6379&gt; GET tutorial<br>QUEUED<br>redis 127.0.0.1:6379&gt; INCR visitors<br>QUEUED<br>redis 127.0.0.1:6379&gt; EXEC<br> 1) OK<br>2) “redis”<br>3) (integer) 1 </p>
<h1 id="Redis-脚本"><a href="#Redis-脚本" class="headerlink" title="Redis - 脚本"></a>Redis - 脚本</h1><p>Redis脚本使用Lua解释脚本用于评估计算。它内置的Redis，从2.6.0版本开始使用脚本命令 eval。</p>
<h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><p>eval命令的基本语法如下：</p>
<p>redis 127.0.0.1:6379&gt; EVAL script numkeys key [key …] arg [arg …]</p>
<h3 id="例子-14"><a href="#例子-14" class="headerlink" title="例子"></a>例子</h3><p>以下举例说明Redis脚本的工作原理：</p>
<p>redis 127.0.0.1:6379&gt; EVAL “return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}” 2 key1 key2 first second<br> 1) “key1”<br>2) “key2”<br>3) “first”<br>4) “second” </p>
<h1 id="Redis-连接"><a href="#Redis-连接" class="headerlink" title="Redis - 连接"></a>Redis - 连接</h1><p>Redis的连接命令基本上都是用于管理与Redis的服务器客户端连接。</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>下面的例子说明了一个客户如何通过Redis服务器验证自己，并检查服务器是否正在运行。</p>
<p>redis 127.0.0.1:6379&gt; AUTH “password”<br>OK<br>redis 127.0.0.1:6379&gt; PING<br>PONG</p>
<h1 id="Redis-备份"><a href="#Redis-备份" class="headerlink" title="Redis - 备份"></a>Redis - 备份</h1><p>Redis SAVE命令用来创建当前的 Redis 数据库备份。</p>
<h2 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h2><p>对Redis SAVE命令的基本语法如下所示：</p>
<p>127.0.0.1:6379&gt; SAVE</p>
<h3 id="例子-15"><a href="#例子-15" class="headerlink" title="例子"></a>例子</h3><p>下面的示例显示了 Redis 当前数据库如何创建备份。</p>
<p>127.0.0.1:6379&gt; SAVE<br> OK </p>
<p>这个命令将创建dump.rdb文件在Redis目录中。</p>
<h2 id="还原Redis数据"><a href="#还原Redis数据" class="headerlink" title="还原Redis数据"></a>还原Redis数据</h2><p>要恢复Redis的数据只需移动 Redis 的备份文件（dump.rdb）到 Redis 目录，然后启动服务器。为了得到你的 Redis 目录，使用配置命令如下所示：</p>
<p>127.0.0.1:6379&gt; CONFIG get dir<br> 1) “dir”<br>2) “/user/yiibai/redis-2.8.13/src” </p>
<p>在上述命令的输出在 /user/yiibai/redis-2.8.13/src 目录，在安装redis的服务器安装位置。</p>
<h2 id="Bgsave"><a href="#Bgsave" class="headerlink" title="Bgsave"></a>Bgsave</h2><p>要创建Redis的备份备用命令BGSAVE也可以。这个命令将开始执行备份过程，并在后台运行。</p>
<h3 id="例子-16"><a href="#例子-16" class="headerlink" title="例子"></a>例子</h3><p>127.0.0.1:6379&gt; BGSAVE<br> Background saving started </p>
<h1 id="Redis-安全"><a href="#Redis-安全" class="headerlink" title="Redis - 安全"></a>Redis - 安全</h1><p>可以Redis的数据库更安全，所以相关的任何客户端都需要在执行命令之前进行身份验证。客户端输入密码匹配需要使用Redis设置在配置文件中的密码。</p>
<h3 id="例子-17"><a href="#例子-17" class="headerlink" title="例子"></a>例子</h3><p>下面给出的例子显示的步骤，以确保您的Redis实例安全。</p>
<p>127.0.0.1:6379&gt; CONFIG get requirepass<br>1) “requirepass”<br>2) “”</p>
<p>默认情况下，此属性为空，表示没有设置密码，此实例。您可以通过执行以下命令来更改这个属性</p>
<p>127.0.0.1:6379&gt; CONFIG set requirepass “yiibai”<br>OK<br>127.0.0.1:6379&gt; CONFIG get requirepass<br>1) “requirepass”<br>2) “yiibai”</p>
<p>设置密码，如果客户端运行命令没有验证，会提示（错误）NOAUTH，需要通过验证。错误将返回客户端。因此，客户端需要使用AUTHcommand进行认证。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><p>AUTH命令的基本语法如下所示：</p>
<p>127.0.0.1:6379&gt; AUTH password</p>
<h1 id="Redis-基准"><a href="#Redis-基准" class="headerlink" title="Redis - 基准"></a>Redis - 基准</h1><p>Redis基准是公用工具同时运行Ñ命令检查Redis的性能。</p>
<h2 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h2><p>redis的基准的基本语法如下所示：</p>
<p>redis-benchmark [option] [option value]</p>
<h3 id="例子-18"><a href="#例子-18" class="headerlink" title="例子"></a>例子</h3><p>下面给出的例子检查redis调用100000命令。</p>
<p>redis-benchmark -n 100000<br> PING_INLINE: 141043.72 requests per second<br>PING_BULK: 142857.14 requests per second<br>SET: 141442.72 requests per second<br>GET: 145348.83 requests per second<br>INCR: 137362.64 requests per second<br>LPUSH: 145348.83 requests per second<br>LPOP: 146198.83 requests per second<br>SADD: 146198.83 requests per second<br>SPOP: 149253.73 requests per second<br>LPUSH (needed to benchmark LRANGE): 148588.42 requests per second<br>LRANGE_100 (first 100 elements): 58411.21 requests per second<br>LRANGE_300 (first 300 elements): 21195.42 requests per second<br>LRANGE_500 (first 450 elements): 14539.11 requests per second<br>LRANGE_600 (first 600 elements): 10504.20 requests per second<br>MSET (10 keys): 93283.58 requests per second </p>
<h1 id="Redis-客户端连接"><a href="#Redis-客户端连接" class="headerlink" title="Redis - 客户端连接"></a>Redis - 客户端连接</h1><p>Redis接受配置监听TCP端口和Unix套接字客户端的连接，如果启用。当一个新的客户端连接被接受以下操作进行：</p>
<ul>
<li>客户端套接字置于非阻塞状态，因为Redis使用复用和非阻塞I/O操作。</li>
<li>TCP_NODELAY选项设定是为了确保我们没有在连接时延迟。</li>
<li>创建一个可读的文件时，这样Redis能够尽快收集客户端的查询作为新的数据可供读取的套接字。</li>
</ul>
<h3 id="客户端的最大数量"><a href="#客户端的最大数量" class="headerlink" title="客户端的最大数量"></a>客户端的最大数量</h3><p>在Redis的配置（redis.conf）属性调用maxclients，它描述客户端可以连接到Redis的最大数量。命令的基本语法是：</p>
<p>config get maxclients<br> 1) “maxclients”<br>2) “10000” </p>
<p>默认情况下，此属性设置为10000（这取决于操作系统的文件描述符限制最大数量），但你可以改变这个属性。</p>
<h3 id="例子-19"><a href="#例子-19" class="headerlink" title="例子"></a>例子</h3><p>在下面给出的例子中，在启动服务器我们设置客户端的最大数量为10万。</p>
<p>redis-server –maxclients 100000</p>
<h1 id="Redis-管道传输"><a href="#Redis-管道传输" class="headerlink" title="Redis - 管道传输"></a>Redis - 管道传输</h1><p>Redis是一个TCP服务器，并支持请求/响应协议。在redis一个请求完成下面的步骤：</p>
<ul>
<li>客户端发送一个查询到服务器，并从套接字中读取，通常在阻塞的方式，对服务器的响应。</li>
<li>服务器处理命令并将响应返回给客户端。</li>
</ul>
<h3 id="管道传输的含义"><a href="#管道传输的含义" class="headerlink" title="管道传输的含义"></a>管道传输的含义</h3><p>管道的基本含义是，客户端可以发送多个请求给服务器，而无需等待答复所有，并最后读取在单个步骤中的答复。</p>
<h3 id="例子-20"><a href="#例子-20" class="headerlink" title="例子"></a>例子</h3><p>要检查redis的管道，只要启动Redis实例，然后在终端键入以下命令。</p>
<p>$(echo -en “PING\r\n SET tutorial redis\r\nGET tutorial\r\nINCR visitor\r\nINCR visitor\r\nINCR visitor\r\n”; sleep 10) | nc localhost 6379<br> +PONG<br>+OK<br>redis<br>:1<br>:2<br>:3 </p>
<p>在上述例子中，我们必须使用PING命令检查Redis的连接，之后，我们已经设定值的Redis字符串命名tutorial ，之后拿到key的值和增量访问量的三倍。在结果中，我们可以检查所有的命令都一次提交给Redis，Redis是在一个步骤给出所有命令的输出。</p>
<h3 id="管道的好处"><a href="#管道的好处" class="headerlink" title="管道的好处"></a>管道的好处</h3><p>这种技术的好处是极大地改善协议的性能。通过管道将慢互联网连接速度从5倍的连接速度提高到localhost至少达到百过倍。</p>
<h1 id="Redis-分区"><a href="#Redis-分区" class="headerlink" title="Redis - 分区"></a>Redis - 分区</h1><p>分区是一种将数据分成多个Redis的情况下，让每一个实例将只包含你的键字的子集的过程。</p>
<h3 id="分区的好处"><a href="#分区的好处" class="headerlink" title="分区的好处"></a>分区的好处</h3><ul>
<li>它允许更大的数据库，使用的多台计算机的存储器的总和。如果不分区，一台计算机的内存可支数量有限。</li>
<li>它允许以大规模的计算能力，以多个内核和多个计算机，以及网络带宽向多台计算机和网络适配器。</li>
</ul>
<h3 id="分区的缺点"><a href="#分区的缺点" class="headerlink" title="分区的缺点"></a>分区的缺点</h3><ul>
<li>通常不支持涉及多个键的操作。例如，不能两个集合之间执行交叉点，因为它们存储在被映射到不同Redis实例中的键。</li>
<li>涉及多个键的Redis事务不能被使用。</li>
<li>分区粒度是关键，所以它是不可能分片数据集用一个硕大的键是一个非常大的有序集合。</li>
<li>当分区时，数据处理比较复杂，比如要处理多个RDB/AOF文件，使数据备份需要从多个实例和主机聚集持久性文件。</li>
<li>添加和删除的能力可能很复杂。比如Redis的集群支持有添加，并在运行时删除节点不支持此功能的能力，但其他系统，如客户端的分区和代理的数据大多是透明的重新平衡。但是有一个叫Presharding技术有助于在这方面。</li>
</ul>
<h3 id="分区的类型"><a href="#分区的类型" class="headerlink" title="分区的类型"></a>分区的类型</h3><p>redis的提供有两种类型的分区。假设我们有四个Redis实例R0，R1，R2，R3和代表用户很多键如：user:1, user:2, … 等等</p>
<h3 id="范围分区"><a href="#范围分区" class="headerlink" title="范围分区"></a>范围分区</h3><p>范围分区被映射对象转化为具体的Redis实例的范围内实现。假定在本例中用户ID0〜ID10000将进入实例R0，而用户形成ID10001至20000号将进入实例R1等等。</p>
<h3 id="散列分区"><a href="#散列分区" class="headerlink" title="散列分区"></a>散列分区</h3><p>在这种类型的分区，一个散列函数（例如，模数函数）被用于转换键成数字，然后数据被存储在不同redis的实例。</p>

            
            <p class="more">
                <a href="/2015/11/24/2019030500153/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/11/24/2019030500153/" title="redis数据类型">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/4.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <span class="page-number current">1</span>
    </nav>
    


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/MySQL/">MySQL</a>
        <span class="badge">(92)</span>
    </li>
    
    <li>
        <a href="/categories/开发语言/">开发语言</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="/categories/Oracle/">Oracle</a>
        <span class="badge">(40)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/">NOSQL</a>
        <span class="badge">(17)</span>
    </li>
    
    <li>
        <a href="/categories/其他数据库/">其他数据库</a>
        <span class="badge">(4)</span>
    </li>
    
    <li>
        <a href="/categories/SQL-Server/">SQL Server</a>
        <span class="badge">(13)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/">Oracle</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/SQL-Server/">SQL Server</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/开发语言/">开发语言</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/MySQL/" title="MySQL">MySQL (71)</a>
  
    <a class="tag-item" href="/tags/位运算/" title="位运算">位运算 (0)</a>
  
    <a class="tag-item" href="/tags/allow/" title="allow">allow (1)</a>
  
    <a class="tag-item" href="/tags/Apache/" title="Apache">Apache (1)</a>
  
    <a class="tag-item" href="/tags/deny/" title="deny">deny (1)</a>
  
    <a class="tag-item" href="/tags/sqlplus/" title="sqlplus">sqlplus (1)</a>
  
    <a class="tag-item" href="/tags/CentOS/" title="CentOS">CentOS (2)</a>
  
    <a class="tag-item" href="/tags/redis/" title="redis">redis (6)</a>
  
    <a class="tag-item" href="/tags/druid/" title="druid">druid (1)</a>
  
    <a class="tag-item" href="/tags/心跳/" title="心跳">心跳 (1)</a>
  
    <a class="tag-item" href="/tags/事务/" title="事务">事务 (5)</a>
  
    <a class="tag-item" href="/tags/分布式/" title="分布式">分布式 (1)</a>
  
    <a class="tag-item" href="/tags/消息/" title="消息">消息 (1)</a>
  
    <a class="tag-item" href="/tags/Oracle/" title="Oracle">Oracle (30)</a>
  
    <a class="tag-item" href="/tags/schedule-job/" title="schedule job">schedule job (1)</a>
  
    <a class="tag-item" href="/tags/KeepAlived/" title="KeepAlived">KeepAlived (1)</a>
  
    <a class="tag-item" href="/tags/分库/" title="分库">分库 (1)</a>
  
    <a class="tag-item" href="/tags/分库分表/" title="分库分表">分库分表 (1)</a>
  
    <a class="tag-item" href="/tags/分表/" title="分表">分表 (1)</a>
  
    <a class="tag-item" href="/tags/数据库/" title="数据库">数据库 (7)</a>
  
    <a class="tag-item" href="/tags/结构同步/" title="结构同步">结构同步 (1)</a>
  
    <a class="tag-item" href="/tags/truncate/" title="truncate">truncate (1)</a>
  
    <a class="tag-item" href="/tags/SQL/" title="SQL">SQL (17)</a>
  
    <a class="tag-item" href="/tags/批量/" title="批量">批量 (1)</a>
  
    <a class="tag-item" href="/tags/Excel/" title="Excel">Excel (1)</a>
  
    <a class="tag-item" href="/tags/Sqlite/" title="Sqlite">Sqlite (1)</a>
  
    <a class="tag-item" href="/tags/FineReport/" title="FineReport">FineReport (1)</a>
  
    <a class="tag-item" href="/tags/报表/" title="报表">报表 (1)</a>
  
    <a class="tag-item" href="/tags/数据集/" title="数据集">数据集 (1)</a>
  
    <a class="tag-item" href="/tags/Hash索引/" title="Hash索引">Hash索引 (1)</a>
  
    <a class="tag-item" href="/tags/InnoDB/" title="InnoDB">InnoDB (3)</a>
  
    <a class="tag-item" href="/tags/MyISAM/" title="MyISAM">MyISAM (3)</a>
  
    <a class="tag-item" href="/tags/索引优化/" title="索引优化">索引优化 (1)</a>
  
    <a class="tag-item" href="/tags/Linux/" title="Linux">Linux (2)</a>
  
    <a class="tag-item" href="/tags/Character-set/" title="Character set">Character set (1)</a>
  
    <a class="tag-item" href="/tags/NLS-LANG/" title="NLS_LANG">NLS_LANG (1)</a>
  
    <a class="tag-item" href="/tags/rowid/" title="rowid">rowid (2)</a>
  
    <a class="tag-item" href="/tags/重复/" title="重复">重复 (1)</a>
  
    <a class="tag-item" href="/tags/mysqldump/" title="mysqldump">mysqldump (2)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="http://www.devba.com" target="_blank" title="软件开发吧">软件开发吧</a>
        </li>
    
        <li>
            <a href="https://www.sqlyun.cn" target="_blank" title="SQL云笔记">SQL云</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>