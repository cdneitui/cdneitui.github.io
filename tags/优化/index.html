<!doctype html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8">
    <meta name="baidu-site-verification" content="dIcXMeY8Ya">
    
    <title>`优化`标签下的文章 | 软件开发吧</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="keywords" content="SQL云,SQL云开发,SQL笔记,SQL开发,云开发,MySQL,Oralce,数据库,数据库云,数据库开发,数据库云开发,SQL教程,数据库教程,开发笔记,MySQL笔记,MySQL教程">
    <meta name="description" content="为满足广大程序猿兄弟对日常工作中学习数据库、使用使用数据库资料查询需求，SQL云开发免费将自己整理的各种数据库技术资料分享出来，并希望与广大猿兄一起讨论学习与进步,致力于一起更方便、快捷资料学习查询,实现更安全、高效的数据存储.">

    
    <link rel="alternative" href="/atom.xml" title="软件开发吧" type="application/atom+xml">
    
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
</html>
<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">软件开发吧</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/tags/优化/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/tags/优化/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/tags/优化/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/tags/优化/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/sxyyhj" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.coding.me" target="_blank">Hosted by Coding Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon">
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 按标签分类 -->

    <h3 class="widget-hd">
        <strong>
            
                `优化`标签下的文章
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/22/2019030500050/">
    		java插入mysql 300万-2200万数据，优化查询
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-22T06:31:31.000Z">2015-12-22</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/Java/" title="Java">Java</a> / 
    
        <a href="/tags/优化/" title="优化">优化</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>my.ini参数修改了下</p>
<ol>
<li>table_cache=512</li>
<li>bulk_insert_buffer_size = 100M</li>
<li>innodb_additional_mem_pool_size=30M</li>
<li>innodb_flush_log_at_trx_commit=0</li>
<li>innodb_buffer_pool_size=207M</li>
<li>innodb_log_file_size=128M</li>
</ol>
<p>innodb_flush_log_at_trx_commit默认值1的意思是每一次事务提交或事务外的指令都需要把日志写入（flush）硬盘，这是很费时的。特别是使用电 池供电缓存（Battery backed up cache）时。设成2对于很多运用，特别是从MyISAM表转过来的是可以的，它的意思是不写入硬盘而是写入系统缓存。日志仍然会每秒flush到硬 盘，所以你一般不会丢失超过1-2秒的更新。设成0会更快一点，但安全方面比较差，即使MySQL挂了也可能会丢失事务的数据。而值2只会在整个操作系统 挂了时才可能丢数据。对于事务要求很强，设置为0 是存在安全问题的 mysql创建表</p>
<p>Sql代码</p>
<ol>
<li>CREATE TABLE `news` (</li>
<li>`id` int(19) NOT NULL AUTO_INCREMENT,</li>
<li>`title` varchar(30) DEFAULT NULL,</li>
<li>`content` varchar(400) DEFAULT NULL,</li>
<li>`type` varchar(30) DEFAULT NULL,</li>
<li>PRIMARY KEY (`id`),</li>
<li>UNIQUE KEY `PK_NEWS_ID` (`id`),</li>
<li>KEY `INDEX_NEWS_ID_TYPE` (`id`,`type`),</li>
<li>KEY `INDEX_NEWS_TYPE` (`type`)</li>
<li><p>) ENGINE=InnoDB AUTO_INCREMENT=1072779 DEFAULT CHARSET=utf8</p>
<p>插入数据一定要用 addBatch 超过300万条数据在我的笔记本上只需要近10分钟</p>
</li>
</ol>
<p>Java代码</p>
<ol>
<li>public static void main(String[] args) {</li>
<li><p>Connection conn = null;</p>
</li>
<li><p>// MySQL的JDBC URL编写方式：jdbc:mysql://主机名称：连接端口/数据库的名称?参数=值</p>
</li>
<li>// 避免中文乱码要指定useUnicode和characterEncoding</li>
<li>// 执行数据库操作之前要在数据库管理系统上创建一个数据库，名字自己定，</li>
<li>// 下面语句之前就要先创建javademo数据库</li>
<li>String url = “jdbc:mysql://localhost:3306/javademo?”</li>
<li><ul>
<li>“user=root&amp;password=root&amp;useUnicode=true&amp;characterEncoding=UTF8”;</li>
</ul>
</li>
<li>try {</li>
<li>Class.forName(“com.mysql.jdbc.Driver”);// 动态加载mysql驱动</li>
<li><p>conn = DriverManager.getConnection(url);</p>
</li>
<li><p>String   sql = “insert into news(title,content,type) values(?,?,?)”;</p>
</li>
<li><p>PreparedStatement prep = conn.prepareStatement(sql);</p>
</li>
<li>// 将连接的自动提交关闭，数据在传送到数据库的过程中相当耗时</li>
<li>conn.setAutoCommit(false);</li>
<li>long start = System.currentTimeMillis();</li>
<li>String type = “java”;</li>
<li>String content = “SUN公司开发Java语言的时候，在数据库这里只是提供了一个标准的接口，或者说是规范，叫做JDBC，这个东西单独放在那里没有任何作用，根本无法连接任何的数据库，只有当你下载相应的数据库驱动程序之后，才可以用JDBC通过这个驱动程序和数据库通信。sqlsever就有它的专门的驱动程序，在微软网站上可以下载到。SUN公司自己也开发了数据库驱动程序，叫做JDBC-ODBC驱动程序，是通过建立ODBC桥来连接Windows数据库，但是因为效率低并且有限制，现在一般都不推荐使用”;</li>
<li>for (int i = 0; i &lt; 30; i++) {</li>
<li>long start2 = System.currentTimeMillis();</li>
<li>// 一次性执行插入10万条数据</li>
<li>if(i==2){type=”php”;}</li>
<li>else if(i==3){type=”erlang”;}</li>
<li>else if(i==4){type=”go”;}</li>
<li>else if(i==5){type=”javascript”;}</li>
<li>else if(i==6){type=”html”;}</li>
<li>else if(i==7){type=”html5”;}</li>
<li>else if(i==8){type=”css”;}</li>
<li>else if(i==9){type=”python”;}</li>
<li>else if(i==10){type=”ror”;}</li>
<li>else if(i==11){type=”nodejs”;}</li>
<li>else if(i==12){type=”spring”;}</li>
<li>else if(i==13){type=”hibernate”;}</li>
<li>else if(i==14){type=”ibatis”;}</li>
<li>else if(i==15){type=”mybatis”;}</li>
<li>else if(i==16){type=”mysql”;}</li>
<li>else if(i==17){type=”msserver”;}</li>
<li>else if(i==18){type=”oracle”;}</li>
<li>else if(i==19){type=”redis”;}</li>
<li>else if(i==20){type=”mangodb”;}</li>
<li>else if(i==21){type=”c”;}</li>
<li>else if(i==22){type=”c++”;}</li>
<li>else if(i==23){type=”springside”;}</li>
<li>else if(i==24){type=”springroo”;}</li>
<li>else if(i==25){type=”sprintboot”;}</li>
<li>else if(i==26){type=”sprintmvc”;}</li>
<li>else if(i==27){type=”websocket”;}</li>
<li>else if(i==28){type=”restful”;}</li>
<li>else if(i==29){type=”comet”;}</li>
<li>for (int j = 0; j &lt; 100000; j++) {</li>
<li>prep.setString(1, “文章”+j);</li>
<li>prep.setString(2, content);</li>
<li>prep.setString(3, type);</li>
<li>prep.addBatch();</li>
<li>}</li>
<li>// 预处理批量执行</li>
<li>prep.executeBatch();</li>
<li>prep.clearBatch();</li>
<li>conn.commit();</li>
<li>long end2 = System.currentTimeMillis();</li>
<li><p>// 批量执行一次批量打印执行依次的时间</p>
</li>
<li><p>System.out.println(end2 - start2);</p>
</li>
<li>}</li>
<li>long end = System.currentTimeMillis();</li>
<li>System.out.print(“total: “);</li>
<li>System.out.println(end - start);</li>
<li>} catch (Exception e) {</li>
<li>e.printStackTrace();</li>
<li>} finally {</li>
<li>try {</li>
<li>conn.close();</li>
<li>} catch (SQLException e) {</li>
<li>// TODO Auto-generated catch block</li>
<li>e.printStackTrace();</li>
<li>}</li>
<li>}</li>
<li>}</li>
</ol>
<p>测试结果300万插入只需要597秒</p>
<ol>
<li>15031</li>
<li>15248</li>
<li>18522</li>
<li>18419</li>
<li>19223</li>
<li>19613</li>
<li>20822</li>
<li>18701</li>
<li>19468</li>
<li>21290</li>
<li>19766</li>
<li>20956</li>
<li>19490</li>
<li>19089</li>
<li>20290</li>
<li>22568</li>
<li>20079</li>
<li>20556</li>
<li>20922</li>
<li>22659</li>
<li>21155</li>
<li>19782</li>
<li>20378</li>
<li>21053</li>
<li>19459</li>
<li>22388</li>
<li>20323</li>
<li>20011</li>
<li>18158</li>
<li>21199</li>
<li><p>total: 596625</p>
<p>机器上一共插入了300万的数据，测试下查询：</p>
</li>
<li><p>select COUNT(id) from news</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li>Time: 0.729ms</li>
</ol>
<p>查询下分页</p>
<ol>
<li><p>select id,title from news limit 1000000,20</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li><p>Time: 7.839ms</p>
<p>从第100万条查询20条记录，耗费了八秒时间，速度慢  </p>
</li>
<li><p>[SQL] select id from news limit 1000000,20</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li>Time: 0.242ms</li>
</ol>
<p>id 是索引，所以更快点  </p>
<ol>
<li>[SQL]</li>
<li><p>select id from news order by id limit 1000000,20</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li>Time: 7.841ms</li>
</ol>
<p>order 加上去慢的太多了  </p>
<ol>
<li><p>select id,title from news where id&gt;=(select id from news order by id limit 1000000,1) limit 20</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li>Time: 8.115ms</li>
</ol>
<p>只要有order by在效率是上不去  </p>
<ol>
<li>[SQL]</li>
<li>select id  from news where type = ‘ibatis’    limit 1,500000;</li>
<li>Affected rows: 0</li>
<li>Time: 0.076ms</li>
</ol>
<ol>
<li><p>select id,title from news where type = ‘ibatis’  limit 1000000,20</p>
</li>
<li><p>Affected rows: 0</p>
</li>
<li>Time: 0.163ms</li>
</ol>
<p>Java代码  <img src="/uploads/2015/12/icon_star.png" alt="收藏代码"></p>
<ol>
<li>[SQL]</li>
<li>select id,title,type from news where type = ‘ibatis’    limit 1,500000;</li>
<li>Affected rows: 0</li>
<li>Time: 0.209ms</li>
</ol>
<p>Java代码  <img src="/uploads/2015/12/icon_star.png" alt="收藏代码"></p>
<ol>
<li>[SQL]</li>
<li>select id,title,content,type from news where type = ‘ibatis’    limit 1,500000;</li>
<li>Affected rows: 0</li>
<li>Time: 0.471ms</li>
</ol>
<p>加上大字段会消耗一点性能 <img src="/uploads/2015/12/137ad894-49bd-31a6-9fa4-3e2f99930c72.png" alt title="点击查看原始大小图片"> 可见复合索引带来性能的优势 <img src="/uploads/2015/12/f54e794d-5d08-3f01-9aff-6f251ae141b1.png" alt title="点击查看原始大小图片"> in的速度是惊人的，300万条记录里面里用in仅仅 0.004ms，最主要也是因为加了索引。 这里面有2个惊人的查询，这也刚好是分页的功能的查询</p>
<ol>
<li>select id  from news where type = ‘ibatis’    limit 1,500000;</li>
<li><p>select *  from news where id in(xxx,xxx,xxx,xxx……………)</p>
<p>最后把in的代码贴出来，大家也试试in的威力</p>
</li>
<li><p>select *  from news where id in(</p>
</li>
<li>2999999,2999998,2999997,2999996,2999995,2999994,2999993,2999992,2999991,2999990,2999989,</li>
<li>2999988,2999987,2999986,2999985,2999984,2999983,2999982,2999981,2999980,2999979,2999978,</li>
<li>2999977,2999976,2999975,2999974,2999973,2999972,2999971,2999970,2999969,2999968,2999967,</li>
<li>2999966,2999965,2999964,2999963,2999962,2999961,2999960,2999959,2999958,2999957,2999956,</li>
<li>2999955,2999954,2999953,2999952,2999951,2999950,2999949,2999948,2999947,2999946,2999945,</li>
<li>2999944,2999943,2999942,2999941,2999940,2999939,2999938,2999937,2999936,2999935,2999934,</li>
<li>2999933,2999932,2999931,2999930,2999929,2999928,2999927,2999926,2999925,2999924,2999923,</li>
<li>2999922,2999921,2999920,2999919,2999918,2999917,2999916,2999915,2999914,2999913,2999912,</li>
<li>2999911,2999910,2999909,2999908,2999907,2999906,2999905,2999904,2999903,2999902,2999901,</li>
<li>2999900,2999899,2999898,2999897,2999896,2999895,2999894,2999893,2999892,2999891,2999890,</li>
<li>2999889,2999888,2999887,2999886,2999885,2999884,2999883,2999882,2999881,2999880,2999879,</li>
<li>2999878,2999877,2999876,2999875,2999874,2999873,2999872,2999871,2999870,2999869,2999868,</li>
<li>2999867,2999866,2999865,2999864,2999863,2999862,2999861,2999860,2999859,2999858,2999857,</li>
<li>2999856,2999855,2999854,2999853,2999852,2999851,2999850,2999849,2999848,2999847,2999846,</li>
<li>2999845,2999844,2999843,2999842,2999841,2999840,2999839,2999838,2999837,2999836,2999835,</li>
<li>2999834,2999833,2999832,2999831,2999830,2999829,2999828,2999827,2999826,2999825,2999824,</li>
<li>2999823,2999822,2999821,2999820,2999819,2999818,2999817,2999816,2999815,2999814,2999813,2999812</li>
<li><p>)</p>
<p><img src="/uploads/2015/12/b70cf91e-9fac-3792-bfed-5c6474d64ae0.png" alt title="点击查看原始大小图片"> 最快的是0.003ms   试试in里面放1188个参数   <img src="/uploads/2015/12/8830527f-e550-3795-b315-d15c7bf395a3.jpg" alt title="点击查看原始大小图片"> 速度依然很惊人   现在数据已经添加到了至少2200万条数据，看看in的效果 <img src="/uploads/2015/12/09409dd7-0647-382b-a090-0a17a785894b.png" alt title="点击查看原始大小图片"> 几千万数据中in语句只需0.001ms <img src="/uploads/2015/12/500dea44-6342-3b6e-bfa5-9b0f35408310.png" alt title="点击查看原始大小图片"> 数据大了，这个语句消耗的时间也增加了点 0.406ms 返回记录49.9999万条</p>
</li>
</ol>

            
            <p class="more">
                <a href="/2015/12/22/2019030500050/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/22/2019030500050/" title="java插入mysql 300万-2200万数据，优化查询">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/12/03/2019030500090/">
    		MySQL性能优化 - 修改配置文件my.cnf
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-12-03T06:45:30.000Z">2015-12-03</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/my-cnf/" title="my.cnf">my.cnf</a> / 
    
        <a href="/tags/优化/" title="优化">优化</a> / 
    
        <a href="/tags/性能/" title="性能">性能</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>在Apache, PHP, MySQL的体系架构中，MySQL对于性能的影响最大，也是关键的核心部分。对于Discuz!论坛程序也是如此，MySQL的设置是否合理优化，直接影响到论坛的速度和承载量！同时，MySQL也是优化难度最大的一个部分，不但需要理解一些MySQL专业知识，同时还需要长时间的观察统计并且根据经验进行判断，然后设置合理的参数。 下面我们了解一下MySQL优化的一些基础，MySQL的优化我分为两个部分，一是服务器物理硬件的优化，二是MySQL自身(my.cnf)的优化。 一、服务器硬件对MySQL性能的影响 ①磁盘寻道能力（磁盘I/O）,以目前高转速SCSI硬盘(7200转/秒)为例，这种硬盘理论上每秒寻道7200次，这是物理特性决定的，没有办法改变。MySQL每秒钟都在进行大量、复杂的查询操作，对磁盘的读写量可想而知。所以，通常认为磁盘I/O是制约MySQL性能的最大因素之一，对于日均访问量在100万PV以上的Discuz!论坛，由于磁盘I/O的制约，MySQL的性能会非常低下！解决这一制约因素可以考虑以下几种解决方案： 使用RAID-0+1磁盘阵列，注意不要尝试使用RAID-5，MySQL在RAID-5磁盘阵列上的效率不会像你期待的那样快。 ②CPU 对于MySQL应用，推荐使用S.M.P.架构的多路对称CPU，例如：可以使用两颗Intel Xeon 3.6GHz的CPU，现在我较推荐用4U的服务器来专门做数据库服务器，不仅仅是针对于mysql。 ③物理内存对于一台使用MySQL的Database Server来说，服务器内存建议不要小于2GB，推荐使用4GB以上的物理内存，不过内存对于现在的服务器而言可以说是一个可以忽略的问题，工作中遇到了高端服务器基本上内存都超过了16G。 二、MySQL自身因素当解决了上述服务器硬件制约因素后，让我们看看MySQL自身的优化是如何操作的。 对MySQL自身的优化主要是对其配置文件my.cnf中的各项参数进行优化调整。下面我们介绍一些对性能影响较大的参数。 由于my.cnf文件的优化设置是与服务器硬件配置息息相关的， 因而我们指定一个假想的服务器硬件环境：CPU: 2颗Intel Xeon 2.4GHz 内存: 4GB DDR 硬盘: SCSI 73GB(很常见的2U服务器 ) 。 下面，我们根据以上硬件配置结合一份已经优化好的my.cnf进行说明： [mysqld] port = 3306 serverid = 1 socket = /tmp/mysql.sock skip-locking #避免MySQL的外部锁定，减少出错几率增强稳定性。 skip-name-resolve #禁止MySQL对外部连接进行DNS解析，使用这一选项可以消除MySQL进行DNS解析的时间。但需要注意，如果开启该选项，则所有远程主机连接授权都要使用IP地址方式，否则MySQL将无法正常处理连接请求！ back_log = 384 #back_log参数的值指出在MySQL暂时停止响应新请求之前的短时间内多少个请求可以被存在堆栈中。 如果系统在一个短时间内有很多连接，则需要增大该参数的值，该参数值指定到来的TCP/IP连接的侦听队列的大小。不同的操作系统在这个队列大小上有它自己的限制。 试图设定back_log高于你的操作系统的限制将是无效的。默认值为50。对于Linux系统推荐设置为小于512的整数。 key_buffer_size = 256M #key_buffer_size指定用于索引的缓冲区大小，增加它可得到更好的索引处理性能。对于内存在4GB左右的服务器该参数可设置为256M或384M。注意：该参数值设置的过大反而会是服务器整体效率降低！ max_allowed_packet = 4M thread_stack = 256K table_cache = 128K sort_buffer_size = 6M #查询排序时所能使用的缓冲区大小。注意：该参数对应的分配内存是每连接独占，如果有100个连接，那么实际分配的总共排序缓冲区大小为100 × 6 ＝ 600MB。所以，对于内存在4GB左右的服务器推荐设置为6-8M。 read_buffer_size = 4M #读查询操作所能使用的缓冲区大小。和sort_buffer_size一样，该参数对应的分配内存也是每连接独享。 join_buffer_size = 8M #联合查询操作所能使用的缓冲区大小，和sort_buffer_size一样，该参数对应的分配内存也是每连接独享。 myisam_sort_buffer_size = 64M table_cache = 512 thread_cache_size = 64 query_cache_size = 64M #指定MySQL查询缓冲区的大小。可以通过在MySQL控制台观察，如果Qcache_lowmem_prunes的值非常大，则表明经常出现缓冲不够的情况；如果Qcache_hits的值非常大，则表明查询缓冲使用非常频繁，如果该值较小反而会影响效率，那么可以考虑不用查询缓冲；Qcache_free_blocks，如果该值非常大，则表明缓冲区中碎片很多。 tmp_table_size = 256M max_connections = 768 #指定MySQL允许的最大连接进程数。如果在访问论坛时经常出现Too Many Connections的错误提 示，则需要增大该参数值。 max_connect_errors = 10000000 wait_timeout = 10 #指定一个请求的最大连接时间，对于4GB左右内存的服务器可以设置为5-10。 thread_concurrency = 8 #该参数取值为服务器逻辑CPU数量*2，在本例中，服务器有2颗物理CPU，而每颗物理CPU又支持H.T超线程，所以实际取值为4*2=8 skip-networking #开启该选项可以彻底关闭MySQL的TCP/IP连接方式，如果WEB服务器是以远程连接的方式访问MySQL数据库服务器则不要开启该选项！否则将无法正常连接！ table_cache=1024 #物理内存越大,设置就越大.默认为2402,调到512-1024最佳 innodb_additional_mem_pool_size=4M #默认为2M innodb_flush_log_at_trx_commit=1 #设置为0就是等到innodb_log_buffer_size列队满后再统一储存,默认为1 innodb_log_buffer_size=2M #默认为1M innodb_thread_concurrency=8 #你的服务器CPU有几个就设置为几,建议用默认一般为8 key_buffer_size=256M #默认为218，调到128最佳 tmp_table_size=64M #默认为16M，调到64-256最挂 read_buffer_size=4M #默认为64K read_rnd_buffer_size=16M #默认为256K sort_buffer_size=32M #默认为256K thread_cache_size=120 #默认为60 query_cache_size=32M ※值得注意的是： 很多情况需要具体情况具体分析 一、如果Key_reads太大，则应该把my.cnf中Key_buffer_size变大，保持Key_reads/Key_read_requests至少1/100以上，越小越好。 二、如果Qcache_lowmem_prunes很大，就要增加Query_cache_size的值。</p>

            
            <p class="more">
                <a href="/2015/12/03/2019030500090/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/12/03/2019030500090/" title="MySQL性能优化 - 修改配置文件my.cnf">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/3.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/11/05/2019030500030/">
    		数据库对于开发应该知道的优化操作
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-11-05T12:01:04.000Z">2015-11-05</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/数据库/" title="数据库">数据库</a> / 
    
        <a href="/tags/优化/" title="优化">优化</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p><strong>对于数据库的一些优化操作</strong> 1：<em>访问少，查询小，</em> 应用程序中，保证在实现功能的基础上，尽量减少对数据库的访问次数；通过搜索参数，尽量减少对表的访问行数,最小化结果集，从而减轻网络负担；能够分开的操作尽量分开处理，提高每次的响应速度；在数据窗口使用SQL时，尽量把使用的索引放在选择的首列；算法的结构尽量简单；在查询时，不要过多地使用通配符如： SELECT <em> FROM T1语句， 要用到几列就选择几列如：SELECT COL1,COL2 FROM T1； 在可能的情况下尽量限制尽量结果集行数如：SELECT TOP 300 COL1,COL2,COL3 FROM T1,因为某些情况下用户是不需要那么多的数据的。 不要在应用中使用数据库游标，游标是非常有用的工具，但比使用常规的、面向集的SQL语句需要更大的开销；按照特定顺序提取数据的查找。 2：<em>类型不乱用</em> 避免使用不兼容的数据类型。 例如float和int、char和varchar、binary和varbinary是不兼容的。数据类型的不兼容可能使优化器无法执行一些本来可以进行的优化操作。例如: SELECT name FROM employee WHERE salary ＞ 60000 在这条语句中,如salary字段是money型的,则优化器很难对其进行优化,因为60000 是个整型数。我们应当在编程时将整型转化成为钱币型,而不要等到运行时转化。 3：<em>避免在WHERE子句中对字段进行函数或表达式操作</em>， 这将导致引擎放弃使用索引而进行全表扫描。如： SELECT </em> FROM T1 WHERE F1/2=100 应改为: SELECT <em> FROM T1 WHERE F1=100\</em>2 SELECT * FROM RECORD WHERE SUBSTRING(CARD_NO,1,4)=’5378’ 应改为: SELECT <em> FROM RECORD WHERE CARD_NO LIKE ‘5378%’ SELECT member_number, first_name, last_name FROM members WHERE DATEDIFF(yy,datofbirth,GETDATE()) &gt; 21 应改为: SELECT member_number, first_name, last_name FROM members WHERE dateofbirth &lt; DATEADD(yy,-21,GETDATE()) 即：任何对列的操作都将导致表扫描，它包括数据库函数、计算表达式等等，查询 时要尽可能将操作移至等号右边。 4、 <em>避免使用操作符</em> 如：!=或＜＞、IS NULL或IS NOT NULL、IN ，NOT IN等这样的操作符, 因为这会使系统无法使用索引,而只能直接搜索表中的数据。例如: SELECT id FROM employee WHERE id != ‘B%’ 优化器将无法通过索引来确定将要命中的行数,因此需要搜索该表的所有行。 5、 尽量使用数字型字段，一部分开发人员和数据库管理人员喜欢把包含数值信 息的字段 设计为字符型，这会降低查询和连接的性能，并会增加存储开销。这是因为引擎在 处理查询和连接回逐个比较字符串中每一个字符，而对于数字型而言只需要比较一 次就够了。 6、 <em>合理使用EXISTS,NOT EXISTS子句</em> 如下所示： a.SELECT SUM(T1.C1)FROM T1 WHERE( (SELECT COUNT(</em>)FROM T2 WHERE T2.C2=T1.C2&gt;0) b.SELECT SUM(T1.C1) FROM T1WHERE EXISTS( SELECT <em> FROM T2 WHERE T2.C2=T1.C2) 两者产生相同的结果，但是后者的效率显然要高于前者。因为后者不会产生大量锁 定的表扫描或是索引扫描。 如果你想校验表里是否存在某条纪录，不要用count(</em>)那样效率很低，而且浪费服 务器资源。可以用EXISTS代替。如： IF (SELECT COUNT(<em>) FROM table_name WHERE column_name = ‘xxx’) 可以写成： IF EXISTS (SELECT </em> FROM table_name WHERE column_name = ‘xxx’) 经常需要写一个T_SQL语句比较一个父结果集和子结果集，从而找到是否存在在父 结果集中有而在子结果集中没有的记录，如： a.SELECT a.hdr_key FROM hdr_tbl a WHERE NOT EXISTS (SELECT <em> FROM dtl_tbl b WHERE a.hdr_key = b.hdr_key) b.SELECT a.hdr_key FROM hdr_tbl a LEFT JOIN dtl_tbl b ON a.hdr_key = b.hdr_key WHERE b.hdr_key IS NULL c.SELECT hdr_key FROM hdr_tbl WHERE hdr_key NOT IN (SELECT hdr_key FROM dtl_tbl) 三种写法都可以得到同样正确的结果，但是效率依次降低。 7、 尽量避免在索引过的字符数据中，使用非打头字母搜索。这也使得引擎无法 利用索引。 见如下例子： SELECT </em> FROM T1 WHERE NAME LIKE ‘%L%’ SELECT <em> FROM T1 WHERE SUBSTING(NAME,2,1)=’L’ SELECT </em> FROM T1 WHERE NAME LIKE ‘L%’ 即使NAME字段建有索引，前两个查询依然无法利用索引完成加快操作，引擎不得不 对全表所有数据逐条操作来完成任务。而第三个查询能够使用索引来加快操作。 8、<em>利用多条件查询</em> 分利用连接条件，在某种情况下，两个表之间可能不只一个的连接条件，这 时在 WHERE 子句中将连接条件完整的写上，有可能大大提高查询速度。 例： SELECT SUM(A.AMOUNT) FROM ACCOUNT A,CARD B WHERE A.CARD_NO = B.CARD_NO SELECT SUM(A.AMOUNT) FROM ACCOUNT A,CARD B WHERE A.CARD_NO = B.CARD_NO AND A.ACCOUNT_NO=B.ACCOUNT_NO 第二句将比第一句执行快得多。 9、 <em>消除对大型表行数据的顺序存取</em> 尽管在所有的检查列上都有索引，但某些形式的WHERE子句强迫优化器使用 顺序存取。如： SELECT <em> FROM orders WHERE (customer_num=104 AND order_num&gt;1001) OR order_num=1008 解决办法可以使用并集来避免顺序存取： SELECT </em> FROM orders WHERE customer_num=104 AND order_num&gt;1001 UNION SELECT <em> FROM orders WHERE order_num=1008 这样就能利用索引路径处理查询。 10、 <em>避免困难的正规表达式</em> LIKE关键字支持通配符匹配，技术上叫正规表达式。但这种匹配特别耗费时 间。例如：SELECT </em> FROM customer WHERE zipcode LIKE “98_ _ _” 即使在zipcode字段上建立了索引，在这种情况下也还是采用顺序扫描的方式。如 果把语句改为SELECT <em> FROM customer WHERE zipcode &gt;“98000”，在执行查询 时就会利用索引来查询，显然会大大提高速度。 11、 <em>使用视图加速查询</em> 把表的一个子集进行排序并创建视图，有时能加速查询。它有助于避免多重排序操作，而且在其他方面还能简化优化器的工作。例如： SELECT cust.name，rcvbles.balance，……other columns FROM cust，rcvbles WHERE cust.customer_id = rcvlbes.customer_id AND rcvblls.balance&gt;0 AND cust.postcode&gt;“98000” ORDER BY cust.name 如果这个查询要被执行多次而不止一次，可以把所有未付款的客户找出来放在一个 视图中，并按客户的名字进行排序： CREATE VIEW DBO.V_CUST_RCVLBES AS SELECT cust.name，rcvbles.balance，……other columns FROM cust，rcvbles WHERE cust.customer_id = rcvlbes.customer_id AND rcvblls.balance&gt;0 ORDER BY cust.name 然后以下面的方式在视图中查询： SELECT </em> FROM V_CUST_RCVLBES WHERE postcode&gt;“98000” 视图中的行要比主表中的行少，而且物理顺序就是所要求的顺序，减少了磁盘 I/O，所以查询工作量可以得到大幅减少。 12、 <em>能够用BETWEEN的就不要用IN</em> SELECT <em> FROM T1 WHERE ID IN (10,11,12,13,14) 改成： SELECT </em> FROM T1 WHERE ID BETWEEN 10 AND 14 因为IN会使系统无法使用索引,而只能直接搜索表中的数据。 13、 <em>DISTINCT的就不用GROUP BY</em> SELECT OrderID FROM Details WHERE UnitPrice &gt; 10 GROUP BY OrderID 可改为： SELECT DISTINCT OrderID FROM Details WHERE UnitPrice &gt; 10 14、 部分利用索引 1.SELECT employeeID, firstname, lastname FROM names WHERE dept = ‘prod’ or city = ‘Orlando’ or division = ‘food’ 2.SELECT employeeID, firstname, lastname FROM names WHERE dept = ‘prod’ UNION ALL SELECT employeeID, firstname, lastname FROM names WHERE city = ‘Orlando’ UNION ALL SELECT employeeID, firstname, lastname FROM names WHERE division = ‘food’ 如果dept 列建有索引则查询2可以部分利用索引，查询1则不能。 15、 <em>能用UNION ALL就不要用UNION</em> UNION ALL不执行SELECT DISTINCT函数，这样就会减少很多不必要的资源 16、 <em>不要写一些不做任何事的查询</em> 如：SELECT COL1 FROM T1 WHERE 1=0 SELECT COL1 FROM T1 WHERE COL1=1 AND COL1=2 这类死码不会返回任何结果集，但是会消耗系统资源。 17、 <em>尽量不要用SELECT INTO语句。</em> SELECT INTO 语句会导致表锁定，阻止其他用户访问该表。 18、 <em>必要时强制查询优化器使用某个索引</em> SELECT <em> FROM T1 WHERE nextprocess = 1 AND processid IN (8,32,45) 改成： SELECT </em> FROM T1 (INDEX = IX_ProcessID) WHERE nextprocess = 1 AND processid IN (8,32,45) 则查询优化器将会强行利用索引IX_ProcessID 执行查询。 19、 虽然UPDATE、DELETE语句的写法基本固定，但是还是对UPDATE语句给点建 议： <em>a) 尽量不要修改主键字段。 b) 当修改VARCHAR型字段时，尽量使用相同长度内容的值代替。 c) 尽量最小化对于含有UPDATE触发器的表的UPDATE操作。 d) 避免UPDATE将要复制到其他数据库的列。 e) 避免UPDATE建有很多索引的列。 f) 避免UPDATE在WHERE子句条件中的列</em>。 上面我们提到的是一些基本的提高查询速度的注意事项,但是在更多的情况下,往往 需要反复试验比较不同的语句以得到最佳方案。最好的方法当然是测试，看实现相 同功能的SQL语句哪个执行时间最少，但是数据库中如果数据量很少，是比较不出 来的，这时可以用查看执行计划，即：把实现相同功能的多条SQL语句考到查询分 析器，按CTRL+L看查所利用的索引，表扫描次数（这两个对性能影响最大），总体 上看询成本百分比即可。 简单的存储过程可以用向导自动生成：在企业管理器工具栏点击运行向导图标，点 击”数据库”、”创建存储过程向导”。复杂存储过程的调试：在查询分析器左边 的对象浏览器（没有？按F8）选择要调试的存储过程,点右键，点调试，输入参数 执行，出现一个浮动工具条，上面有单步执行，断点设置等。</p>

            
            <p class="more">
                <a href="/2015/11/05/2019030500030/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/11/05/2019030500030/" title="数据库对于开发应该知道的优化操作">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/5.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <span class="page-number current">1</span>
    </nav>
    


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/MySQL/">MySQL</a>
        <span class="badge">(92)</span>
    </li>
    
    <li>
        <a href="/categories/开发语言/">开发语言</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="/categories/Oracle/">Oracle</a>
        <span class="badge">(40)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/">NOSQL</a>
        <span class="badge">(17)</span>
    </li>
    
    <li>
        <a href="/categories/SQL-Server/">SQL Server</a>
        <span class="badge">(13)</span>
    </li>
    
    <li>
        <a href="/categories/其他数据库/">其他数据库</a>
        <span class="badge">(4)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/">Oracle</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/SQL-Server/">SQL Server</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/开发语言/">开发语言</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/MySQL/" title="MySQL">MySQL (71)</a>
  
    <a class="tag-item" href="/tags/位运算/" title="位运算">位运算 (0)</a>
  
    <a class="tag-item" href="/tags/allow/" title="allow">allow (1)</a>
  
    <a class="tag-item" href="/tags/Apache/" title="Apache">Apache (1)</a>
  
    <a class="tag-item" href="/tags/deny/" title="deny">deny (1)</a>
  
    <a class="tag-item" href="/tags/sqlplus/" title="sqlplus">sqlplus (1)</a>
  
    <a class="tag-item" href="/tags/CentOS/" title="CentOS">CentOS (2)</a>
  
    <a class="tag-item" href="/tags/druid/" title="druid">druid (1)</a>
  
    <a class="tag-item" href="/tags/心跳/" title="心跳">心跳 (1)</a>
  
    <a class="tag-item" href="/tags/redis/" title="redis">redis (6)</a>
  
    <a class="tag-item" href="/tags/分库/" title="分库">分库 (1)</a>
  
    <a class="tag-item" href="/tags/分库分表/" title="分库分表">分库分表 (1)</a>
  
    <a class="tag-item" href="/tags/分表/" title="分表">分表 (1)</a>
  
    <a class="tag-item" href="/tags/Oracle/" title="Oracle">Oracle (30)</a>
  
    <a class="tag-item" href="/tags/schedule-job/" title="schedule job">schedule job (1)</a>
  
    <a class="tag-item" href="/tags/事务/" title="事务">事务 (5)</a>
  
    <a class="tag-item" href="/tags/分布式/" title="分布式">分布式 (1)</a>
  
    <a class="tag-item" href="/tags/消息/" title="消息">消息 (1)</a>
  
    <a class="tag-item" href="/tags/KeepAlived/" title="KeepAlived">KeepAlived (1)</a>
  
    <a class="tag-item" href="/tags/数据库/" title="数据库">数据库 (7)</a>
  
    <a class="tag-item" href="/tags/结构同步/" title="结构同步">结构同步 (1)</a>
  
    <a class="tag-item" href="/tags/truncate/" title="truncate">truncate (1)</a>
  
    <a class="tag-item" href="/tags/FineReport/" title="FineReport">FineReport (1)</a>
  
    <a class="tag-item" href="/tags/SQL/" title="SQL">SQL (17)</a>
  
    <a class="tag-item" href="/tags/报表/" title="报表">报表 (1)</a>
  
    <a class="tag-item" href="/tags/数据集/" title="数据集">数据集 (1)</a>
  
    <a class="tag-item" href="/tags/Excel/" title="Excel">Excel (1)</a>
  
    <a class="tag-item" href="/tags/Sqlite/" title="Sqlite">Sqlite (1)</a>
  
    <a class="tag-item" href="/tags/批量/" title="批量">批量 (1)</a>
  
    <a class="tag-item" href="/tags/Linux/" title="Linux">Linux (2)</a>
  
    <a class="tag-item" href="/tags/Character-set/" title="Character set">Character set (1)</a>
  
    <a class="tag-item" href="/tags/NLS-LANG/" title="NLS_LANG">NLS_LANG (1)</a>
  
    <a class="tag-item" href="/tags/rowid/" title="rowid">rowid (2)</a>
  
    <a class="tag-item" href="/tags/重复/" title="重复">重复 (1)</a>
  
    <a class="tag-item" href="/tags/Hash索引/" title="Hash索引">Hash索引 (1)</a>
  
    <a class="tag-item" href="/tags/InnoDB/" title="InnoDB">InnoDB (3)</a>
  
    <a class="tag-item" href="/tags/MyISAM/" title="MyISAM">MyISAM (3)</a>
  
    <a class="tag-item" href="/tags/索引优化/" title="索引优化">索引优化 (1)</a>
  
    <a class="tag-item" href="/tags/mysqldump/" title="mysqldump">mysqldump (2)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="http://www.devba.com" target="_blank" title="软件开发吧">软件开发吧</a>
        </li>
    
        <li>
            <a href="https://www.sqlyun.cn" target="_blank" title="SQL云笔记">SQL云</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>