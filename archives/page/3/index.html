<!doctype html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8">
    <meta name="baidu-site-verification" content="dIcXMeY8Ya">
    
    <title>文章归档 | 软件开发吧</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="keywords" content="Jelon, 前端, Web, 张德龙, 前端开发">
    <meta name="description" content="Jelon个人前端小站">

    
    <link rel="alternative" href="/atom.xml" title="软件开发吧" type="application/atom+xml">
    
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
</html>
<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">软件开发吧</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/archives/page/3/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/archives/page/3/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/archives/page/3/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/archives/page/3/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/jangdelong" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.coding.me" target="_blank">Hosted by Coding Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                        <a href="http://weibo.com/jangdelong" class="sinaweibo" target="_blank"><b>■</b> 新浪微博</a>
                    
                        <a href="https://www.facebook.com/profile.php?id=100011855760219&amp;ref=bookmarks" class="qqweibo" target="_blank"><b>■</b> Facebook</a>
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon">
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 文章归档 -->

    <h3 class="widget-hd">
        <strong>
            
                文章归档
                <!-- 文章归档，可以根据日期分类 -->
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/02/16/2019030500058/">
    		mongodb最新java驱动CRUD使用演示
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-02-16T06:08:35.000Z">2016-02-16</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MongoDB/" title="MongoDB">MongoDB</a> / 
    
        <a href="/tags/Java/" title="Java">Java</a> / 
    
        <a href="/tags/CRUD/" title="CRUD">CRUD</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>今天使用java代码调用mongodb数据库，用maven引入了最新版的mongodb驱动，在网上找了demo结果发现将demo贴到eclipse上之后好多过期方法。所以猜想mongodb驱动版本肯定有很大的更新。 果不其然，mongodb的确有了最新版3.x。而网上几乎所有的demo都基于2.x版本。下面是在github上找的一些资料，再结合官方文档总结的3.x版本的CRUD操作。   以下演示源码地址：<a href="https://github.com/smallbug-vip/repo" target="_blank" rel="noopener">https://github.com/smallbug-vip/repo</a>   首先在pom.xml中配置引入jar包：</p>
<p>Xml代码</p>
<ol>
<li><dependency></dependency></li>
<li><groupid>org.mongodb</groupid></li>
<li><artifactid>mongo-java-driver</artifactid></li>
<li><version>3.2.1</version></li>
<li></li>
</ol>
<p>下面演示会使用到一些静态方法，eclipse中使用快捷键不能自动导包，可以手动添加：</p>
<p>Java代码</p>
<ol>
<li>import static com.mongodb.client.model.Filters.and;</li>
<li>import static com.mongodb.client.model.Filters.eq;</li>
<li>import static com.mongodb.client.model.Filters.exists;</li>
<li>import static com.mongodb.client.model.Filters.gt;</li>
<li>import static com.mongodb.client.model.Filters.gte;</li>
<li>import static com.mongodb.client.model.Filters.lt;</li>
<li>import static com.mongodb.client.model.Filters.lte;</li>
<li>import static com.mongodb.client.model.Projections.excludeId;</li>
<li>import static com.mongodb.client.model.Projections.include;</li>
<li>import static com.mongodb.client.model.Sorts.descending;</li>
</ol>
<p>准备工作：</p>
<p>Java代码</p>
<ol>
<li>MongoDatabase db = null;</li>
<li><p>MongoClient client = null;</p>
</li>
<li><p>@Before</p>
</li>
<li>public void before() {</li>
<li>client = new MongoClient(“192.168.88.132”, 27017);</li>
<li>db = client.getDatabase(“its”);</li>
<li><p>}</p>
</li>
<li><p>@After</p>
</li>
<li>public void after() {</li>
<li>if (client != null) {</li>
<li>client.close();</li>
<li>}</li>
<li>}</li>
</ol>
<p>获取连接：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li><p>public void testCollections() {</p>
</li>
<li><p>MongoIterable<string> collections = db.listCollectionNames();</string></p>
</li>
<li>MongoCursor<string> cu = collections.iterator();</string></li>
<li>for (; cu.hasNext();) {</li>
<li>System.out.println(cu.next());</li>
<li>}</li>
<li>}</li>
</ol>
<p>测试增加一个Document：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testAdd() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>Document doc = new Document(“name”, “MongoDB”)//</li>
<li>.append(“type”, “database”)//</li>
<li>.append(“count”, 1)//</li>
<li>.append(“info”, new Document(“x”, 203).append(“y”, 102));</li>
<li>col.insertOne(doc);</li>
<li>}</li>
</ol>
<p>测试增加多个Document：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testAddALL() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>List<document> dos = new ArrayList<document>();</document></document></li>
<li>for (int i = 0; i &lt; 100; i++) {</li>
<li>dos.add(new Document(“i”, i));</li>
<li>}</li>
<li>col.insertMany(dos);</li>
<li>}</li>
</ol>
<p>查看当前有多少记录：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testCount() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>System.out.println(col.count());</li>
<li>}</li>
</ol>
<p>获取第一条记录：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testFirst() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>Document myDoc = col.find().first();</li>
<li>System.out.println(myDoc.toJson());</li>
<li>}</li>
</ol>
<p>获取第所有记录：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testFindAll() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>/<strong><strong><strong><em>**</em></strong></strong></strong> 第一种方法 <strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>/</li>
<li>// MongoCursor<document> cursor = col.find().iterator();</document></li>
<li>// while (cursor.hasNext()) {</li>
<li>// System.out.println(cursor.next().toJson());</li>
<li>// }</li>
<li>/<strong><strong><strong><em>**</em></strong></strong></strong> 第二种方法 <strong><strong><strong><strong><strong>*</strong></strong></strong></strong></strong>/</li>
<li>for (Document cur : col.find()) {</li>
<li>System.out.println(cur.toJson());</li>
<li>}</li>
<li>}</li>
</ol>
<p>分页：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testLimit() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>for (Document cur : col.find().skip(20).limit(10)) {</li>
<li>System.out.println(cur.toJson());</li>
<li>}</li>
<li>}</li>
</ol>
<p>条件查询：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testFilter() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>// eq为静态导入</li>
<li>Document myDoc = col.find(eq(“i”, 71)).first();</li>
<li>System.out.println(myDoc.toJson());</li>
<li>}</li>
</ol>
<p>获得子集：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testBlock() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>Block<document> printBlock = new Block<document>() {</document></document></li>
<li>@Override</li>
<li>public void apply(final Document document) {</li>
<li>System.out.println(document.toJson());</li>
<li>}</li>
<li>};</li>
<li>col.find(and(gt(“i”, 50), lte(“i”, 80))).forEach(printBlock);</li>
<li>}</li>
</ol>
<p>排序：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testSort() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>// 升序 ascending</li>
<li>FindIterable<document> it = col.find(exists(“i”)).sort(descending(“i”));</document></li>
<li>for (Document d : it) {</li>
<li>System.out.println(d.toJson());</li>
<li>}</li>
<li>}</li>
</ol>
<p>筛选字段：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testProjection() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>FindIterable<document> it = col.find()//</document></li>
<li>.projection(and(include(“name”), excludeId()));</li>
<li>for (Document d : it) {</li>
<li>System.out.println(d.toJson());</li>
<li>}</li>
<li>}</li>
</ol>
<p>更新一条Document：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testUpdateOne() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>col.updateOne(//</li>
<li>eq(“i”, 10), new Document(“$set”, new Document(“i”, 110)));</li>
<li>}</li>
</ol>
<p>更新多条记录：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testUpdateMany() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>// $inc 自增</li>
<li>UpdateResult updateResult = col.updateMany(lt(“i”, 10), new Document(“$inc”, new Document(“i”, 234)));</li>
<li>System.out.println(updateResult.getModifiedCount());</li>
<li>}</li>
</ol>
<p>测试删除一条Document：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testDeleteOne() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>DeleteResult re = col.deleteOne(eq(“i”, 234));</li>
<li>System.out.println(re.getDeletedCount());</li>
<li>}</li>
</ol>
<p>测试删除多条Document：</p>
<p>Java代码</p>
<ol>
<li>@Test</li>
<li>public void testDeleteMany() {</li>
<li>MongoCollection<document> col = db.getCollection(“s1”);</document></li>
<li>DeleteResult deleteResult = col.deleteMany(gte(“i”, 100));</li>
<li>System.out.println(deleteResult.getDeletedCount());</li>
<li>}</li>
</ol>

            
            <p class="more">
                <a href="/2016/02/16/2019030500058/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/02/16/2019030500058/" title="mongodb最新java驱动CRUD使用演示">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/6.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/02/16/2019030500136/">
    		Oracle查询杀死死锁
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-02-16T05:45:21.000Z">2016-02-16</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a> / 
    
        <a href="/tags/死锁/" title="死锁">死锁</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>oracle死锁问题查询及处理</p>
<p>一、数据库死锁的现象       首先确认登录的界面  sys/dba 程序在执行的过程中，点击确定或保存按钮，程序没有响应，也没有出现报错。</p>
<p>二、死锁的原理</p>
<p>当对于数据库某个表的某一列做更新或删除等操作，执行完毕后该条语句不提</p>
<p>交，另一条对于这一列数据做更新操作的语句在执行的时候就会处于等待状态，</p>
<p>此时的现象是这条语句一直在执行，但一直没有执行成功，也没有报错。</p>
<p>三、死锁的定位方法</p>
<p>通过检查数据库表，能够检查出是哪一条语句被死锁，产生死锁的机器是哪一台。</p>
<p>1）用dba用户执行以下语句</p>
<p>select username,lockwait,status,machine,program from v$session where sid in</p>
<p>(select session_id from v$locked_object)</p>
<p>如果有输出的结果，则说明有死锁，且能看到死锁的机器是哪一台。字段说明：</p>
<p>Username：死锁语句所用的数据库用户；</p>
<p>Lockwait：死锁的状态，如果有内容表示被死锁。</p>
<p>Status： 状态，active表示被死锁</p>
<p>Machine： 死锁语句所在的机器。</p>
<p>Program： 产生死锁的语句主要来自哪个应用程序。</p>
<p>2）用dba用户执行以下语句，可以查看到被死锁的语句。</p>
<p>select sql_text from v$sql where hash_value in</p>
<p>(select sql_hash_value from v$session where sid in</p>
<p>(select session_id from v$locked_object))</p>
<p>四、死锁的解决方法</p>
<pre><code>一般情况下，只要将产生死锁的语句提交就可以了，但是在实际的执行过程中。用户可
</code></pre><p>能不知道产生死锁的语句是哪一句。可以将程序关闭并重新启动就可以了。</p>
<p>　经常在Oracle的使用过程中碰到这个问题，所以也总结了一点解决方法。</p>
<p>1）查找死锁的进程：</p>
<p>sqlplus “/as sysdba” (sys/change_on_install)</p>
<p>SELECT s.username,l.OBJECT_ID,l.SESSION_ID,s.SERIAL#,</p>
<p>l.ORACLE_USERNAME,l.OS_USER_NAME,l.PROCESS</p>
<p>FROM V$LOCKED_OBJECT l,V$SESSION S WHERE l.SESSION_ID=S.SID;</p>
<p>2）kill掉这个死锁的进程：</p>
<p>　　alter system kill session ‘sid,serial#’; （其中sid=l.session_id）</p>
<p>3）如果还不能解决：</p>
<p>select pro.spid from v$session ses,v$process pro where ses.sid=XX and ses.paddr=pro.addr;</p>
<p>　　其中sid用死锁的sid替换: exit</p>
<p>ps -ef|grep spid</p>
<p>　　其中spid是这个进程的进程号，kill掉这个Oracle进程</p>
<pre><code>KILL -9  “刚才查出的SPID”

在WINDOWS平台，可以是偶那个orakill。
</code></pre><p>4）查询死锁语句</p>
<p>select A.SQL_TEXT, B.USERNAME, C.OBJECT_ID, C.SESSION_ID,</p>
<pre><code>B.SERIAL#, C.ORACLE\_USERNAME,C.OS\_USER_NAME,C.Process,

&apos;&apos;&apos;&apos;||C.Session_ID||&apos;,&apos;||B.SERIAL#||&apos;&apos;&apos;&apos;
</code></pre><p>from v$sql A, v$session B, v$locked_object C</p>
<p>where A.HASH_VALUE = B.SQL_HASH_VALUE and</p>
<p>B.SID = C.Session_ID</p>
<p>精简处理步骤</p>
<p>–1、查找被锁表的object_id</p>
<p>select object_id from all_objects where object_name = upper(‘table_name’) and object_type = ‘TABLE’</p>
<p>–2、根据第1步查到的object_id查找被锁对象的会话ID</p>
<p>select session_id from v$locked_object where object_id = 1779474</p>
<p>–3、根据第2步查到的session_id查找serial#</p>
<p>select sid,serial# from v$session  where sid = 284</p>
<p>–4、根据session_id和serial#杀掉进程</p>
<p>alter system kill session ‘sid,serial#’</p>
<p>–查找在被锁对象上的操作语句</p>
<p>select sql_text from v$sqlarea where address = ‘00’  –address为v$session中的sql_address字段</p>

            
            <p class="more">
                <a href="/2016/02/16/2019030500136/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/02/16/2019030500136/" title="Oracle查询杀死死锁">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/6.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/01/28/2019030500091/">
    		MySQL性能优化的最佳经验
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-01-28T05:34:54.000Z">2016-01-28</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>1、为查询优化你的查询 大多数的MySQL服务器都开启了查询缓存。这是提高性最有效的方法之一，而且这是被MySQL的数据库引擎处理的。当有很多相同的查询被执行了多次的时候，这些查询结果会被放到一个缓存中，这样，后续的相同的查询就不用操作表而直接访问缓存结果了。 这里最主要的问题是，对于程序员来说，这个事情是很容易被忽略的。因为，我们某些查询语句会让MySQL不使用缓存。请看下面的示例： // 查询缓存不开启 $r = mysql_query(“SELECT username FROM user WHERE     signup_date &gt;= CURDATE()”); // 开启查询缓存 $today = date(“Y-m-d”); $r = mysql_query(“SELECT username FROM user WHERE signup_date &gt;= ‘$today’”); 上面两条SQL语句的差别就是 CURDATE() ，MySQL的查询缓存对这个函数不起作用。所以，像 NOW() 和 RAND() 或是其它的诸如此类的SQL函数都不会开启查询缓存，因为这些函数的返回是会不定的易变的。所以，你所需要的就是用一个变量来代替MySQL的函数，从而开启缓存。 2、EXPLAIN 你的SELECT查询 使用EXPLAIN关键字可以让你知道MySQL是如何处理你的SQL语句的。 有表关联的查询，如下列： select username, group_name from users u joins groups g on (u.group_id = g.id) 发现查询缓慢，然后在group_id字段上增加索引，则会加快查询 3、当只要一行数据时使用LIMIT 1 当你查询表的有些时候，你已经知道结果只会有一条结果，单因为你可能需要去fetch游标，或是你也许会去检查返回的记录数。 在这种情况下，加上LIMIT 1 可以增加性能。这样一样， MySQL数据库引擎会在找到一条数据后停止搜索，而不是继续往后查找下一条符合记录的数据。 下面的示例，只是为了找一下是否有“中国”的用户，很明显，后面的会比前面的更有效率。（请注意，第一条中是Select <em>，第二条是Select 1） // 没有效率的： $r = mysql_query(“SELECT </em> FROM user WHERE country = ‘China’”); if (mysql_num_rows($r) &gt; 0) { // … } // 有效率的： $r = mysql_query(“SELECT 1 FROM user WHERE country = ‘China’ LIMIT 1”); if (mysql_num_rows($r) &gt; 0) { // … } 宣传语 历经两个半月的准备，三次大改版，十七次小改版。le1024终于要和大家见面了。 le1024每天推荐1~3段，有趣、有爱、有故事的视频。 为您工作、学习、生活之余增加一点快乐的感觉。程序员必看的快乐视频网站 4、为搜索字段建索引 索引并不一定就是给主键或是唯一的字段。如果在你的表中，有某个字段你总要会经常用来做搜索，那么，请为其建立索引吧。 5、在Join表的时候使用相当类型的列，并将其索引 如果你的应用程序有很多JOIN查询，你应该确认两个表中Join的字段是被建过索引的。这样，MySQL内部会启动为你优化Join的SQL语句的机制。 而且，这些被用来Join的字段，应该是相同的类型的。例如：如果你要把DECIMAL字段和一个INT字段JOIN在一起，MYSQL就无法使用他们的索引。对于那些STRING类型，还需要有相同的字符集才行（两个表的字符集有可能不一样） 6、千万不要ORDER BY RAND() 7、避免SELECT <em> 从数据库里读出越多的数据，那么查询就会变得越慢。并且，如果你的数据库服务器和WEB服务器是两台独立的服务器的话，这还会增加网络传输的负载。 所以，你应该养成一个需要什么就取什么的好的习惯。 // 不推荐 $r = mysql_query(“SELECT </em> FROM user WHERE user_id = 1”); $d = mysql_fetch_assoc($r); echo “Welcome {$d[‘username’]}”; // 推荐 $r = mysql_query(“SELECT username FROM user WHERE user_id = 1”); $d = mysql_fetch_assoc($r); echo “Welcome {$d[‘username’]}”; 8、永远为两张表设置一个ID 我们应该为数据库里的每张表都设置一个ID作为其主键，而最好的是一个INT型（推荐使用UNSIGNED），并设置上自动增长的AUTO INCREMENT标志。 就算是你 users 表有一个主键叫 “email”的字段，你也别让它成为主键。使用 VARCHAR 类型来当主键会使用得性能下降。另外，在你的程序中，你应该使用表的ID来构造你的数据结构。 而且，在MySQL数据引擎下，还有一些操作需要使用主键，在这些情况下，主键的性能和设置变得非常重要，比如，集群，分区…… 9、使用 ENUM 而不是 VARCHAR ？ ENUM 类型是非常快和紧凑的。在实际上，其保存的是 TINYINT，但其外表上显示为字符串。这样一来，用这个字段来做一些选项列表变得相当的完美。 如果你有一个字段，比如“性别”，“国家”，“民族”，“状态”或“部门”，你知道这些字段的取值是有限而且固定的，那么，你应该使用 ENUM 而不是 VARCHAR。 10、从 PROCEDURE ANALYSE() 取得建议 ？ PROCEDURE ANALYSE() 会让 MySQL 帮你去分析你的字段和其实际的数据，并会给你一些有用的建议。只有表中有实际的数据，这些建议才会变得有用，因为要做一些大的决定是需要有数据作为基础的。 例如，如果你创建了一个 INT 字段作为你的主键，然而并没有太多的数据，那么，PROCEDURE ANALYSE()会建议你把这个字段的类型改成 MEDIUMINT 。或是你使用了一个 VARCHAR 字段，因为数据不多，你可能会得到一个让你把它改成 ENUM 的建议。这些建议，都是可能因为数据不够多，所以决策做得就不够准。 11、尽可能的使用 NOT NULL 除非你有一个很特别的原因去使用 NULL 值，你应该总是让你的字段保持 NOT NULL。这看起来好像有点争议，请往下看。 首先，问问你自己“Empty”和“NULL”有多大的区别（如果是INT，那就是0和NULL）？如果你觉得它们之间没有什么区别，那么你就不要使用NULL。（你知道吗？在 Oracle 里，NULL 和 Empty 的字符串是一样的！) 不要以为 NULL 不需要空间，其需要额外的空间，并且，在你进行比较的时候，你的程序会更复杂。 当然，这里并不是说你就不能使用NULL了，现实情况是很复杂的，依然会有些情况下，你需要使用NULL值。 下面摘自MySQL自己的文档 “NULL columns require additional space in the row to record whether their values are NULL. For MyISAM tables, each NULL column takes one bit extra, rounded up to the nearest byte.” 12、把IP地址存成 UNSIGNED INT 很多程序员都会创建一个 VARCHAR(15) 字段来存放字符串形式的IP而不是整形的IP。如果你用整形来存放，只需要4个字节，并且你可以有定长的字段。而且，这会为你带来查询上的优势，尤其是当你需要使用这样的WHERE条件：IP between ip1 and ip2。 我们必需要使用UNSIGNED INT，因为 IP地址会使用整个32位的无符号整形 13、固定长度的表会更快 如果表中的所有字段都是“固定长度”的，整个表会被认为是 “static” 或 “fixed-length”。 例如，表中没有如下类型的字段： VARCHAR，TEXT，BLOB。只要你包括了其中一个这些字段，那么这个表就不是“固定长度静态表”了，这样，MySQL 引擎会用另一种方法来处理。 固定长度的表会提高性能，因为MySQL搜寻得会更快一些，因为这些固定的长度是很容易计算下一个数据的偏移量的，所以读取的自然也会很快。而如果字段不是定长的，那么，每一次要找下一条的话，需要程序找到主键。 并且，固定长度的表也更容易被缓存和重建。不过，唯一的副作用是，固定长度的字段会浪费一些空间，因为定长的字段无论你用不用，他都是要分配那么多的空间。 14、垂直分割 “垂直分割”是一种把数据库中的表按列变成几张表的方法，这样可以降低表的复杂度和字段的数目，从而达到优化的目的。（以前，在银行做过项目，见过一张表有100多个字段，很恐怖） 示例一：在Users表中有一个字段是家庭地址，这个字段是可选字段，相比起，而且你在数据库操作的时候除了个人信息外，你并不需要经常读取或是改写这个字段。那么，为什么不把他放到另外一张表中呢？ 这样会让你的表有更好的性能，大家想想是不是，大量的时候，我对于用户表来说，只有用户ID，用户名，口令，用户角色等会被经常使用。小一点的表总是会有好的性能。 示例二： 你有一个叫 “last_login” 的字段，它会在每次用户登录时被更新。但是，每次更新时会导致该表的查询缓存被清空。所以，你可以把这个字段放到另一个表中，这样就不会影响你对用户ID，用户名，用户角色的不停地读取了，因为查询缓存会帮你增加很多性能。 另外，你需要注意的是，这些被分出去的字段所形成的表，你不会经常性地去Join他们，不然的话，这样的性能会比不分割时还要差，而且，会是极数级的下降。 15、拆分大的 DELETE 或 INSERT 语句 如果你需要在一个在线的网站上去执行一个大的 DELETE 或 INSERT 查询，你需要非常小心，要避免你的操作让你的整个网站停止相应。因为这两个操作是会锁表的，表一锁住了，别的操作都进不来了。 Apache 会有很多的子进程或线程。所以，其工作起来相当有效率，而我们的服务器也不希望有太多的子进程，线程和数据库链接，这是极大的占服务器资源的事情，尤其是内存。 如果你把你的表锁上一段时间，比如30秒钟，那么对于一个有很高访问量的站点来说，这30秒所积累的访问进程/线程，数据库链接，打开的文件数，可能不仅仅会让你泊WEB服务Crash，还可能会让你的整台服务器马上掛了。 所以，如果你有一个大的处理，你定你一定把其拆分，使用 LIMIT 条件是一个好的方法。下面是一个示例： while (1) { //每次只做1000条 mysql_query(“DELETE FROM logs WHERE log_date &lt;= ‘2009-11-01’ LIMIT 1000”); if (mysql_affected_rows() == 0) { // 没得可删了，退出！ break; } // 每次都要休息一会儿 usleep(50000); } 16、 越小的列会越快 对于大多数的数据库引擎来说，硬盘操作可能是最重大的瓶颈。所以，把你的数据变得紧凑会对这种情况非常有帮助，因为这减少了对硬盘的访问。 参看 MySQL 的文档 Storage Requirements 查看所有的数据类型。 如果一个表只会有几列罢了（比如说字典表，配置表），那么，我们就没有理由使用 INT 来做主键，使用 MEDIUMINT, SMALLINT 或是更小的 TINYINT 会更经济一些。如果你不需要记录时间，使用 DATE 要比 DATETIME 好得多。 当然，你也需要留够足够的扩展空间，不然，你日后来干这个事，你会死的很难看，参看Slashdot的例子（2009年11月06日），一个简单的ALTER TABLE语句花了3个多小时，因为里面有一千六百万条数据。 17、选择一个正确的存储引擎 在 MySQL 中有两个存储引擎 MyISAM 和 InnoDB，每个引擎都有利有弊。酷壳以前文章《MySQL: InnoDB 还是 MyISAM?》讨论和这个事情。 MyISAM 适合于一些需要大量查询的应用，但其对于有大量写操作并不是很好。甚至你只是需要update一个字段，整个表都会被锁起来，而别的进程，就算是读进程都无法操作直到读操作完成。另外，MyISAM 对于 SELECT COUNT(<em>) 这类的计算是超快无比的。 InnoDB 的趋势会是一个非常复杂的存储引擎，对于一些小的应用，它会比 MyISAM 还慢。他是它支持“行锁” ，于是在写操作比较多的时候，会更优秀。并且，他还支持更多的高级应用，比如：事务。 18、小心“永久链接” “永久链接”的目的是用来减少重新创建MySQL链接的次数。当一个链接被创建了，它会永远处在连接的状态，就算是数据库操作已经结束了。而且，自从我们的Apache开始重用它的子进程后——也就是说，下一次的HTTP请求会重用Apache的子进程，并重用相同的 MySQL 链接。 PHP手册：mysql_pconnect() 在理论上来说，这听起来非常的不错。但是从个人经验（也是大多数人的）上来说，这个功能制造出来的麻烦事更多。因为，你只有有限的链接数，内存问题，文件句柄数，等等。 而且，Apache 运行在极端并行的环境中，会创建很多很多的了进程。这就是为什么这种“永久链接”的机制工作地不好的原因。在你决定要使用“永久链接”之前，你需要好好地考虑一下你的整个系统的架构。 参考 19、当查询较慢的时候，可用Join来改写一下该查询来进行优化 mysql&gt; select sql_no_cache </em> from guang_deal_outs where deal_id in (select id from guang_deals where id = 100017151) ; Empty set (18.87 sec) mysql&gt; select sql_no_cache a.<em> from guang_deal_outs a inner join guang_deals b on a.deal_id = b.id where b.id = 100017151; Empty set (0.01 sec) 原因 mysql&gt; desc select sql_no_cache </em> from guang_deal_outs where deal_id in (select id from guang_deals where id = 100017151) ; +—-+——————–+—————–+——-+—————+———+———+——-+———-+————-+ | id | select_type        | table           | type  | possible_keys | key     | key_len | ref   | rows     | Extra       | +—-+——————–+—————–+——-+—————+———    +———+——-+———-+————-+ |  1 | PRIMARY            | guang_deal_outs | ALL   | NULL          | NULL    |     NULL    | NULL  | 18633779 | Using where | |  2 | DEPENDENT SUBQUERY | guang_deals     | const | PRIMARY       | PRIMARY |     4       | const |        1 | Using index | +—-+——————–+—————–+——-+—————+———    +———+——-+———-+————-+ 2 rows in set (0.04 sec) mysql&gt; desc select sql_no_cache a.<em> from guang_deal_outs a inner join guang_deals b on a.deal_id = b.id where b.id = 100017151; +—-+————-+——-+——-+———————-    +———————-+———+——-+——+————-+ | id | select_type | table | type  | possible_keys        | key                      | key_len | ref   | rows | Extra       | +—-+————-+——-+——-+———————-    +———————-+———+——-+——+————-+ |  1 | SIMPLE      | b     | const | PRIMARY              | PRIMARY                  | 4       | const |    1 | Using index | |  1 | SIMPLE      | a     | ref   | idx_guang_dlout_dlid |     idx_guang_dlout_dlid | 4       | const |    1 |             | +—-+————-+——-+——-+———————-    +———————-+———+——-+——+————-+ 2 rows in set (0.05 sec) 其实在  guang_deal_outs 在deal_id 上也是有索引的。 其实我想把子查询设置为 select </em> from guang_deal_outs where deal_id in (select id from guang_deals where id = 100017151); 变成下面的样子 select <em> from guang_deal_outs where deal_id in (100017151); 但不幸的是，实际情况正好相反。MySQL试图让它和外面的表产生联系来“帮助”优化查询，它认为下面的exists形式更有效率 select </em> from guang_deal_outs where exists (select * from guang_deals where id = 100017151 and id = guang_deal_outs.deal_id); 这种in子查询的形式，在外部表（比如上面的guang_deals）数据量比较大的时候效率是很差的（如果对于较小的表，不会造成显著地影响）</p>

            
            <p class="more">
                <a href="/2016/01/28/2019030500091/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/01/28/2019030500091/" title="MySQL性能优化的最佳经验">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/8.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/01/27/2019030500129/">
    		Oracle修改字符集
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-01-27T02:17:18.000Z">2016-01-27</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>方法一：sqlplus “用户/密码 as sysdba” sqlplus “sys/sys as sysdba” 方法二：sqlplus/nolog SQL&gt; conn /as sysdba SQL&gt; shutdown immediate; SQL&gt; startup mount SQL&gt; ALTER SYSTEM ENABLE RESTRICTED SESSION; SQL&gt; ALTER SYSTEM SET JOB_QUEUE_PROCESSES=0; SQL&gt; ALTER SYSTEM SET AQ_TM_PROCESSES=0; SQL&gt; alter database open; SQL&gt; ALTER DATABASE CHARACTER SET ZHS16GBK; ORA-12712: new character set must be a superset of old character set 提示我们的字符集：新字符集必须为旧字符集的超集，这时我们可以跳过超集的检查做更改： SQL&gt; ALTER DATABASE character set INTERNAL_USE ZHS16GBK; –我们看到这个过程和之前ALTER DATABASE CHARACTER SET操作的内部过程是完全相同的，也就是说INTERNAL_USE提供的帮助就是使Oracle数据库绕过了子集与超集的校验. SQL&gt; shutdown immediate; SQL&gt; startup <!--StartFragment--><!--EndFragment--> SQL&gt; select userenv(‘language’) from dual;  Oracle查看字符集</p>

            
            <p class="more">
                <a href="/2016/01/27/2019030500129/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/01/27/2019030500129/" title="Oracle修改字符集">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/7.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/01/26/2019030500085/">
    		mysql 安装后链接时报 1045 的错误
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-01-26T02:31:21.000Z">2016-01-26</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/access/" title="access">access</a> / 
    
        <a href="/tags/dos/" title="dos">dos</a> / 
    
        <a href="/tags/windows/" title="windows">windows</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>错误信息：Error 1045(280000): access denied for user root localhost windows 下（验证可行）： 1、先要关闭 mysql 服务。 不关闭 mysql 服务，在第三步会没有反应。 2、打开 dos,  cd 到你 mysql 的安装目录中的 bin 目录下。 3、执行&gt;mysqld  –defaults-file=”C:\Program Files\MySQL\MySQL Server 5.1\my.ini” –console –skip-grant-tables “C:\Program Files\MySQL\MySQL Server 5.1\my.ini”，这个 my.ini 在你的 mysql 安装目录下（bin 目录的上一级）。 输出信息： 160126  9:11:39 [Note] Plugin ‘FEDERATED’ is disabled. 160126  9:11:39  InnoDB: Initializing buffer pool, size = 107.0M 160126  9:11:39  InnoDB: Completed initialization of buffer pool 160126  9:11:40  InnoDB: Started; log sequence number 0 44233 160126  9:11:40 [Note] mysqld: ready for connections. Version: ‘5.1.69-community’  socket: ‘’  port: 3306  MySQL Community S erver (GPL) 4、别打开一个 dos 窗口，cd 到你 mysql 的安装目录中的 bin 目录下。 执行&gt;mysql -uroot mysql 执行&gt;mysql&gt; UPDATE user SET Password=PASSWORD(’newpassword’) where USER=’root’; mysql&gt; FLUSH PRIVILEGES; mysql&gt; quit 5、关闭 dos 窗口。 6、重启 mysql 服务（如果重启有错误，重启下机器）。 现在你可以用你的新密码登录了。</p>

            
            <p class="more">
                <a href="/2016/01/26/2019030500085/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/01/26/2019030500085/" title="mysql 安装后链接时报 1045 的错误">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/6.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/01/25/2019030500042/">
    		线上业务Redis数据迁移至SSDB
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-01-25T07:56:38.000Z">2016-01-25</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/redis/" title="redis">redis</a> / 
    
        <a href="/tags/SSDB/" title="SSDB">SSDB</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>1，背景 Redis的持久化只是用于备份数据，而如果作为持久化存储会有一些问题（具体？），因此将Redis数据迁移至SSDB，命令列表见<a href="http://ssdb.io/docs/zh_cn/redis-to-ssdb.html" target="_blank" rel="noopener">http://ssdb.io/docs/zh_cn/redis-to-ssdb.html</a> 2，策略 由于Redis存储的数据很重要，因此为了保证数据迁移的可靠性同时不对线上业务造成影响，采取分步过渡并验证的方式： <img src="/uploads/2016/01/863331b3-221a-3204-9fac-8e0817141cb8.jpg" alt title="点击查看原始大小图片"> 3，关键点 a，修改代码，加入开关切换redis和ssdb的读写使上述几种情况都可以通过配置开关来控制。 b，加入读取SSDB数据的lua接口，并发访问量很大，采取nginx+lua解决。 c，测试并验证。写测试脚本对所有对外接口进行测试，查看数据的返回值并校验数据是否一致。 d，数据同步 <img src="/uploads/2016/01/d541fcfe-aea0-3e88-b0ff-f25ffcade3fc.jpg" alt> 4，问题 a) 当redis和ssdb数据同步时，执行测试脚本显示错误：errno=2001    errmsg=server error: closed。经查是Redis主从同步断开，进而导致从从同步也断开。</p>

            
            <p class="more">
                <a href="/2016/01/25/2019030500042/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/01/25/2019030500042/" title="线上业务Redis数据迁移至SSDB">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/5.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/01/25/2019030500033/">
    		数据库连接driverClass和jdbcUrl整理
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-01-25T07:50:37.000Z">2016-01-25</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/driverClass/" title="driverClass">driverClass</a> / 
    
        <a href="/tags/jdbcUrl/" title="jdbcUrl">jdbcUrl</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>一、MySQL： driverClass：com.mysql.jdbc.Driver org.gjt.mm.mysql.Driver jdbcUrl：jdbc:mysql://192.168.0.1:3306/yourDBName 硬编码（不建议）： Class.forName(“com.mysql.jdbc.Driver”, true, Thread.currentThread().getContextClassLoader()); conn=DriverManager.getConnection(“jdbc:mysql://192.168.0.1:3306/yourDBName?user=userName&amp;password=123&amp;useUnicode=true&amp;characterEncoding=gb2312”); 二、Oracle： （thin模式） driverClass：oracle.jdbc.driver.OracleDriver jdbcUrl：jdbc:oracle:thin:@192.168.0.1:1521:yourDBName 三、SQL Server： driverClass：com.microsoft.sqlserver.jdbc.SQLServerDriver（2005版本及以后） com.microsoft.jdbc.sqlserver.SQLServerDriver（2000版本） jdbcUrl：jdbc:sqlserver://192.168.0.1:1433;databasename=yourDBName 四、Sybase： driverClass：com.sybase.jdbc3.jdbc.SybDriver com.sysbase.jdbc.SybDriver jdbcUrl：jdbc:sybase:Tds:127.0.0.1:5007/myDB 五、DB2： 1、db2java.zip driverClass：COM.ibm.db2.jdbc.net.DB2Driver jdbcUrl：jdbc:db2://127.0.0.1:5000/DBNAME 2、db2jcc.jar driverClass：com.ibm.db2.jcc.DB2Driver jdbcUrl：jdbc:db2://127.0.0.1:5000/DBNAME 3、 driverClass：com.ibm.db2.jdbc.app.DB2DriverjdbcUrl：jdbc:db2://127.0.0.1:5000/yourDBName 六、Informix： driverClass：com.informix.jdbc.IfxDriver jdbcUrl：jdbc:informix-sqli://127.0.0.1:1533/yourDBName:informixserver=myserver;user=test;password=test123 七、PostgreSQL： driverClass：org.postgresql.Driver jdbcUrl：jdbc:postgresql://127.0.0.1:5432/yourDBName 八、Access： driverClass：sun.jdbc.odbc.JdbcOdbcDriver jdbcUrl：jdbc:odbc:dataSourceName 九、Memcached： driverClass： jdbcUrl： 十、MongoDB： driverClass： jdbcUrl： 十一、Redis： driverClass： jdbcUrl： 十二、SQLite： driverClass： jdbcUrl： driverClass： jdbcUrl：</p>

            
            <p class="more">
                <a href="/2016/01/25/2019030500033/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/01/25/2019030500033/" title="数据库连接driverClass和jdbcUrl整理">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/5.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/01/19/2019030500008/">
    		优化Redis内存的9个要点
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-01-19T06:58:27.000Z">2016-01-19</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/redis/" title="redis">redis</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>优化Redis内存的9个要点</p>
<p>1.注意在redis.conf中的小聚合数据类型的特殊编码设置：</p>
<p>hash-max-zipmap-entries 64 (hash-max-ziplist-entries for Redis &gt;= 2.6)</p>
<p>hash-max-zipmap-value 512  (hash-max-ziplist-value for Redis &gt;= 2.6)</p>
<p>list-max-ziplist-entries 512</p>
<p>list-max-ziplist-value 64</p>
<p>zset-max-ziplist-entries 128</p>
<p>zset-max-ziplist-value 64</p>
<p>set-max-intset-entries 512</p>
<p>2.使用32位实例将内存受限在4G内，不过他们的RDB和AOF文件是兼容在32位和64位下去切换使用的。</p>
<p>3。使用bit位级别操作和byte字节级别操作来减少不必要的内存使用</p>
<p>bit位级别操作：GETRANGE, SETRANGE, GETBIT and SETBIT</p>
<p>byte字节级别操作：GETRANGE and SETRANGE</p>
<p>4.尽可能地使用hashes哈希，因为小Hashes会被编码成一个非常小的空间。</p>
<p>5.使用哈希来在Redis的顶部在普通key-value存储上来抽象内存使用效率</p>
<p>6.关于内存分配：</p>
<p>如果maxmemory没有设置的Redis会继续分配内存，因为它认为合适的，因此它可以（逐渐）吃了你的全部可用内存。因此，通常建议配置一些限制。您可能还需要设置maxmemory策略，以noeviction（这不是在一些旧版本的Redis的默认值）。</p>
<p>这使得Redis的返回内存不足的错误写命令，如果当它到达了极限 - 这反过来可能会导致应用程序错误，但不会导致因为内存饥饿而整机死亡。</p>
<p>另外redis 的6种过期策略redis 中的默认的过期策略是volatile-lru 。设置方式</p>
<p>　　config set maxmemory-policy volatile-lru</p>
<p>　　maxmemory-policy 六种方式</p>
<p>　　volatile-lru：只对设置了过期时间的key进行LRU（默认值）</p>
<p>　　allkeys-lru ： 是从所有key里 删除 不经常使用的key</p>
<p>　　volatile-random：随机删除即将过期key</p>
<p>　　allkeys-random：随机删除</p>
<p>　　volatile-ttl ： 删除即将过期的</p>
<p>　　noeviction ： 永不过期，返回错误</p>
<p>　　maxmemory-samples 3 是说每次进行淘汰的时候 会随机抽取3个key 从里面淘汰最不经常使用的（默认选项）</p>
<p>7. 在存到Redis之前先把你的数据压缩下</p>
<p>8.尽量使用短的键（Keys）</p>
<p>9.使用Hashes值存储而不带额外的数据元</p>

            
            <p class="more">
                <a href="/2016/01/19/2019030500008/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/01/19/2019030500008/" title="优化Redis内存的9个要点">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/9.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/01/19/2019030500051/">
    		Linux下安装Redis精要
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-01-19T06:48:40.000Z">2016-01-19</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/redis/" title="redis">redis</a> / 
    
        <a href="/tags/Linux/" title="Linux">Linux</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p><strong>Linux下安装Redis</strong>   <strong>安装chkconfig：</strong> rpm -aq |grep chkconfig chkconfig-1.3.30.1-2 # export PATH=/sbin:$PATH # chkconfig   或是 vi /etc/profile 加入 export PATH=/sbin:$PATH 执行 source /etc/profile 执行 chkconfig   <strong>安装redis:</strong> tar -xvf redis-3.0.6.tar.gz cd redis-3.0.6 make PREFIX=/usr/local/redis install   <strong>配置redis服务:</strong> cp utils/redis_init_script /etc/rc.d/init.d/redis   <strong>添加注册服务：</strong> vi /etc/rc.d/init.d/redis   <strong>第2行添加</strong> # chkconfig:   2345 90 10 # description:  Redis is a persistent key-value database   redis服务必须在运行级2，3，4，5下被启动或关闭，启动的优先级是90，关闭的优先级是10。   <strong>修改EXEC和CLIEXEC路径（安装文件目录）：</strong> EXEC=/app/re/redis-3.0.6/src/redis-server CLIEXEC=/app/re/redis-3.0.6/src/redis-cli   <strong>redis开启的命令，以后台运行的方式执行。</strong> $EXEC $CONF &amp;   <strong>改完了保存！</strong>   mkdir /etc/redis cp redis.conf /etc/redis/6379.conf   <strong>/etc/profile 加入</strong> export REDIS_HOME=/usr/local/redis export PATH=${PATH}:${REDIS_HOME}/bin   <strong>执行 source /etc/profile</strong>   <strong>注册redis服务：</strong> chkconfig –add redis   #设置为开机自启动服务器 chkconfig redis on #打开服务 service redis start #关闭服务 service redis stop     WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add ‘vm.overcommit_memory = 1’ to /etc/sysctl.conf and then reboot or run the command ‘sysctl vm.overcommit_memory=1’ for this to take effect.   sysctl vm.overcommit_memory=1     $ redis-cli 127.0.0.1:6379&gt; ping PONG 127.0.0.1:6379&gt; set aa bb OK 127.0.0.1:6379&gt; get aa “bb” 127.0.0.1:6379&gt;</p>

            
            <p class="more">
                <a href="/2016/01/19/2019030500051/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/01/19/2019030500051/" title="Linux下安装Redis精要">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/9.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2016/01/18/2019030500147/">
    		oracle SQL竖表转横表
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2016-01-18T10:14:25.000Z">2016-01-18</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/SQL/" title="SQL">SQL</a> / 
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>oracle SQL竖表转横表 T_T_STUDENT表查询记录如下，要转成横表 姓名 课程 成绩 1 张飞 语文 80 2 张飞 数学 87 3 关羽 语文 97 4 张飞 英语 68 5 关羽 数学 53 6 刘备 语文 90 方法一： –用decode实现, SELECT T.NAME, SUM(DECODE(T.Course, ‘语文’, T.Score)) 语文, SUM(DECODE(T.Course, ‘数学’, T.Score)) 数学, SUM(DECODE(T.Course, ‘英语’, T.Score)) 英语 FROM T_T_STUDENT T GROUP BY T.NAME 方法二： –用case when 实现 SELECT T.NAME, SUM(CASE T.Course WHEN ‘语文’ THEN T.Score ELSE 0 END) 语文, SUM(CASE T.Course WHEN ‘数学’ THEN T.Score ELSE 0 END) 数学, SUM(CASE T.Course WHEN ‘英语’ THEN T.Score ELSE 0 END) 英语 FROM T_T_STUDENT T GROUP BY T.NAME 输出结果如下： 姓名 语文 数学 英语 1 刘备 90 94 92 2 关羽 97 53 95 3 张飞 80 87 68 区别如果条件是单一值时，用decode比较简便，如果判断条件比较复杂是用case when实现</p>

            
            <p class="more">
                <a href="/2016/01/18/2019030500147/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2016/01/18/2019030500147/" title="oracle SQL竖表转横表">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/8.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <a class="extend prev" rel="prev" href="/archives/page/2/">前一页</a><a class="page-number" href="/archives/">1</a><a class="page-number" href="/archives/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/archives/page/4/">4</a><a class="page-number" href="/archives/page/5/">5</a><span class="space">&hellip;</span><a class="page-number" href="/archives/page/18/">18</a><a class="extend next" rel="next" href="/archives/page/4/">后一页</a>
    </nav>
    


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/MySQL/">MySQL</a>
        <span class="badge">(92)</span>
    </li>
    
    <li>
        <a href="/categories/Oracle/">Oracle</a>
        <span class="badge">(40)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/">NOSQL</a>
        <span class="badge">(17)</span>
    </li>
    
    <li>
        <a href="/categories/开发语言/">开发语言</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="/categories/SQL-Server/">SQL Server</a>
        <span class="badge">(13)</span>
    </li>
    
    <li>
        <a href="/categories/其他数据库/">其他数据库</a>
        <span class="badge">(4)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/">Oracle</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/SQL-Server/">SQL Server</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/开发语言/">开发语言</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/MySQL/" title="MySQL">MySQL (71)</a>
  
    <a class="tag-item" href="/tags/位运算/" title="位运算">位运算 (0)</a>
  
    <a class="tag-item" href="/tags/sqlplus/" title="sqlplus">sqlplus (1)</a>
  
    <a class="tag-item" href="/tags/PL-SQL/" title="PL/SQL">PL/SQL (5)</a>
  
    <a class="tag-item" href="/tags/数据库/" title="数据库">数据库 (7)</a>
  
    <a class="tag-item" href="/tags/视图/" title="视图">视图 (1)</a>
  
    <a class="tag-item" href="/tags/B-Tree/" title="B+Tree">B+Tree (1)</a>
  
    <a class="tag-item" href="/tags/索引/" title="索引">索引 (1)</a>
  
    <a class="tag-item" href="/tags/redis/" title="redis">redis (6)</a>
  
    <a class="tag-item" href="/tags/SSDB/" title="SSDB">SSDB (1)</a>
  
    <a class="tag-item" href="/tags/SQL/" title="SQL">SQL (17)</a>
  
    <a class="tag-item" href="/tags/ORA-00600/" title="ORA-00600">ORA-00600 (1)</a>
  
    <a class="tag-item" href="/tags/存储过程/" title="存储过程">存储过程 (3)</a>
  
    <a class="tag-item" href="/tags/CentOS/" title="CentOS">CentOS (2)</a>
  
    <a class="tag-item" href="/tags/allow/" title="allow">allow (1)</a>
  
    <a class="tag-item" href="/tags/Apache/" title="Apache">Apache (1)</a>
  
    <a class="tag-item" href="/tags/deny/" title="deny">deny (1)</a>
  
    <a class="tag-item" href="/tags/druid/" title="druid">druid (1)</a>
  
    <a class="tag-item" href="/tags/心跳/" title="心跳">心跳 (1)</a>
  
    <a class="tag-item" href="/tags/事务/" title="事务">事务 (5)</a>
  
    <a class="tag-item" href="/tags/分布式/" title="分布式">分布式 (1)</a>
  
    <a class="tag-item" href="/tags/消息/" title="消息">消息 (1)</a>
  
    <a class="tag-item" href="/tags/KeepAlived/" title="KeepAlived">KeepAlived (1)</a>
  
    <a class="tag-item" href="/tags/Oracle/" title="Oracle">Oracle (30)</a>
  
    <a class="tag-item" href="/tags/schedule-job/" title="schedule job">schedule job (1)</a>
  
    <a class="tag-item" href="/tags/分库/" title="分库">分库 (1)</a>
  
    <a class="tag-item" href="/tags/分库分表/" title="分库分表">分库分表 (1)</a>
  
    <a class="tag-item" href="/tags/分表/" title="分表">分表 (1)</a>
  
    <a class="tag-item" href="/tags/结构同步/" title="结构同步">结构同步 (1)</a>
  
    <a class="tag-item" href="/tags/批量/" title="批量">批量 (1)</a>
  
    <a class="tag-item" href="/tags/truncate/" title="truncate">truncate (1)</a>
  
    <a class="tag-item" href="/tags/Hash索引/" title="Hash索引">Hash索引 (1)</a>
  
    <a class="tag-item" href="/tags/InnoDB/" title="InnoDB">InnoDB (3)</a>
  
    <a class="tag-item" href="/tags/MyISAM/" title="MyISAM">MyISAM (3)</a>
  
    <a class="tag-item" href="/tags/索引优化/" title="索引优化">索引优化 (1)</a>
  
    <a class="tag-item" href="/tags/FineReport/" title="FineReport">FineReport (1)</a>
  
    <a class="tag-item" href="/tags/报表/" title="报表">报表 (1)</a>
  
    <a class="tag-item" href="/tags/数据集/" title="数据集">数据集 (1)</a>
  
    <a class="tag-item" href="/tags/Excel/" title="Excel">Excel (1)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="https://jelon.top" target="_blank" title="Jelon个人前端小站">前端博客小站</a>
        </li>
    
        <li>
            <a href="https://www.baidu.com" target="_blank" title="百度搜索">百度</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>