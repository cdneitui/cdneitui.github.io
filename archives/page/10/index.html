<!doctype html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8">
    <meta name="baidu-site-verification" content="dIcXMeY8Ya">
    
    <title>文章归档 | 软件开发吧</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="keywords" content="SQL云,SQL云开发,SQL笔记,SQL开发,云开发,MySQL,Oralce,数据库,数据库云,数据库开发,数据库云开发,SQL教程,数据库教程,开发笔记,MySQL笔记,MySQL教程">
    <meta name="description" content="为满足广大程序猿兄弟对日常工作中学习数据库、使用使用数据库资料查询需求，SQL云开发免费将自己整理的各种数据库技术资料分享出来，并希望与广大猿兄一起讨论学习与进步,致力于一起更方便、快捷资料学习查询,实现更安全、高效的数据存储.">

    
    <link rel="alternative" href="/atom.xml" title="软件开发吧" type="application/atom+xml">
    
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
</html>
<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">软件开发吧</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/archives/page/10/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/archives/page/10/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/archives/page/10/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/archives/page/10/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/cdneitui" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.github.com/" target="_blank">Hosted by GitHub Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon">
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 文章归档 -->

    <h3 class="widget-hd">
        <strong>
            
                文章归档
                <!-- 文章归档，可以根据日期分类 -->
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/SQL-Server/">SQL Server</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/16/2019030500032/">
    		数据库连接字符串的困惑
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-16T07:25:03.000Z">2015-09-16</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/CentOS6-5/" title="CentOS6.5">CentOS6.5</a> / 
    
        <a href="/tags/Hello-World/" title="Hello World">Hello World</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <h1 id="程序员方阵"><a href="#程序员方阵" class="headerlink" title="程序员方阵"></a>程序员方阵</h1><p>说起Hello World，不由得想起最近的抗战胜利70周年阅兵；网络中走来的程序员方阵。 现在向我们走来的是程序员方阵！ 他们穿着拖鞋，披着毛巾， 左手拿着键盘，右手举着鼠标， 腋下夹着USB转换器。 他们因睡眠不足而显得精神不振， 喊着微弱的口号走过主席台。 主席问候：程序员们辛苦了! 程序员方队异口同声地答道：Hello World！ 习大大的讲话很给力：让我们共同铭记历史所启示的伟大真理：正义必胜！和平必胜！人民必胜！</p>
<h1 id="数据库连接字符串的困惑"><a href="#数据库连接字符串的困惑" class="headerlink" title="数据库连接字符串的困惑"></a>数据库连接字符串的困惑</h1><p>通常来说，第一个Hello World程序是无压力的，个别开发环境安装、配置起来可能比较吃力，就像前段时间Visual Studio推出Linux版本，我基于CentOS6.5安装，结果需要升级GCC的版本，研究了半天也没搞定！ 我最初学习的是VB.NET，学习网页后台开发，照着书中的例子学习的也还算顺利；但到学习数据库的时候就卡住了，当时是连接的ACCESS数据库，具体遇到的错误已经不记得了，只大概的记得这问题搞了一两个月也没搞出来！当时是2003年左右，网络上能找到的东西也非常有限，不像现在一搜一大把的资料源码之类的；当时应该有一些知名的论坛了，不过那时候人比较傻，也不知道去找论坛发帖；当时访问Google还不用翻墙呢，不过英文也不好，也没想到去外面看看！ 实在研究不通了，就放下了，先去研究点别的；过了大概一个多月吧，又回过头来研究，结果很快搞通过了，连接数据库成功了，突然觉得豁然开朗！</p>
<h1 id="数据库连接字符串的组成"><a href="#数据库连接字符串的组成" class="headerlink" title="数据库连接字符串的组成"></a>数据库连接字符串的组成</h1><p>连接字符串的是一个以分号为界，划分键值参数对的列表。</p>
<h2 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h2><p>之所以可以通过一个字符串连接并操作数据库，是因为有驱动程序的支持。 <strong>常见的驱动程序如下：</strong></p>
<h3 id="ODBC"><a href="#ODBC" class="headerlink" title="ODBC"></a>ODBC</h3><p>ODBC(Open Database Connectivity，开放数据库互连)是微软公司开放服务结构(WOSA,Windows Open Services Architecture)中有关数据库的一个组成部分，它建立了一组规范，并提供了一组对数据库访问的标准API（应用程序编程接口）。这些API利用SQL来完成其大部分任务。ODBC本身也提供了对SQL语言的支持，用户可以直接将SQL语句送给ODBC。</p>
<h3 id="OLE-DB"><a href="#OLE-DB" class="headerlink" title="OLE DB"></a>OLE DB</h3><p>OLE DB 是 Microsoft 的一个战略性系统级编程接口，用于管理整个组织内的数据。OLE DB 是建立在 ODBC 功能之上的一个开放规范。ODBC 是为访问关系型数据库而专门开发的，OLE DB 则用于访问关系型和非关系型信息源，例如主机 ISAM/VSAM 和层次数据库，电子邮件和文件系统存储，文本、图形和地理数据以及自定义业务对象。OLE DB 定义了一组 COM 接口，对各种数据库管理系统服务进行封装，并允许创建软件组件，实现这些服务。OLE DB 组件包括数据提供程序（包含和表现数据）、数据使用者（使用数据）和服务组件（处理和传送数据，例如，查询处理器和游标引擎）。OLE DB 接口有助于平滑地集成组件，这样，OLE DB 组件厂商就可以快速地向市场提供高质量 OLE DB 组件。此外，OLE DB 包含了一个连接 ODBC 的“桥梁”，对现用的各种 ODBC 关系型数据库驱动程序提供一贯的支持。</p>
<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序，同时，JDBC也是个商标名。</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>目前，Microsoft 的 ODBC API 可能是使用最广的、用于访问关系数据库的编程接口。它能在几乎所有平台上连接几乎所有的数据库。为什么 Java 不使用 ODBC？对这个问题的回答是：Java 可以使用 ODBC，但最好是在 JDBC 的帮助下以JDBC-ODBC桥的形式使用，这一点我们稍后再说。现在的问题已变成：”为什么需要 JDBC”？答案是显然的：ODBC 不适合直接在 Java 中使用，因为它使用 C 语言接口。从Java 调用本地 C代码在安全性、实现、坚固性和程序的自动移植性方面都有许多缺点。从 ODBC C API 到 Java API 的字面翻译是不可取的。例如，Java 没有指针，而 ODBC 却对指针用得很广泛（包括很容易出错的指针”void *”）。您可以将 JDBC 想象成被转换为面向对象接口的 ODBC，而面向对象的接口对 Java程序员来说较易于接受。 ODBC 很难学。它把简单和高级功能混在一起，而且即使对于简单的查询，其选项也极为复杂。相反，JDBC 尽量保证简单功能的简便性，而同时在必要时允许使用高级功能。启用”纯 Java “机制需要象 JDBC 这样的 Java API。如果使用ODBC，就必须手动地将 ODBC 驱动程序管理器和驱动程序安装在每台客户机上。如果完全用 Java 编写 JDBC 驱动程序则 JDBC代码在所有 Java 平台上（从网络计算机到大型机）都可以自 动安装、移植并保证安全性。 总之，JDBC API 对于基本的 SQL 抽象和概念是一种自然的 Java 接口。它建立在 ODBC 上而不是从零开始。因此，熟悉 ODBC 的程序员将发现 JDBC 很容易使用。JDBC 保留了 ODBC 的基本设计特征；事实上，两种接口都基于 X/Open SQL CLI（调用级接口）。它们之间最大的区别在于：JDBC 以 Java 风格与优点为基础并进行优化，因此更加易于使用。 目前，Microsoft 又引进了 ODBC 之外的新 API： RDO、 ADO 和OLE DB。这些设计在许多方面与 JDBC 是相同的，即它们都是面向对象的数据库接口且基于可在 ODBC 上实现的类。但在这些接口中，我们未看见有特别的功能使我们要转而选择它们来替代 ODBC，尤其是在 ODBC 驱动程序已建立起较为完善的市场的情况下。它们最多也就是在 ODBC 上加了一种装饰而已。</p>
<h1 id="数据库链接字符串大全"><a href="#数据库链接字符串大全" class="headerlink" title="数据库链接字符串大全"></a>数据库链接字符串大全</h1><h2 id="SQL-Server-2005"><a href="#SQL-Server-2005" class="headerlink" title="SQL Server 2005"></a>SQL Server 2005</h2><h3 id="SQL-Native-Client-ODBC-Driver"><a href="#SQL-Native-Client-ODBC-Driver" class="headerlink" title="SQL Native Client ODBC Driver"></a>SQL Native Client ODBC Driver</h3><p>标准安全连接 Driver={SQL Native Client};Server=myServerAddress; Database=myDataBase;Uid=myUsername;Pwd=myPassword; 受信的连接 Driver={SQL Native Client}; Server=myServerAddress;Database=myDataBase;Trusted_Connection=yes; “Integrated Security=SSPI” 与 “Trusted_Connection=yes” 是相同的。 连接到一个SQL Server实例 指定服务器实例的表达式和其他SQL Server的连接字符串相同。 Driver={SQL Native Client};Server=myServerName/theInstanceName;Database=myDataBase; Trusted_Connection=yes; 指定用户名和密码 oConn.Properties(“Prompt”) = adPromptAlways Driver={SQL Native Client}; Server=myServerAddress;Database=myDataBase; 使用MARS (multiple active result sets) Driver={SQL Native Client};Server=myServerAddress;Database=myDataBase; Trusted_Connection=yes;MARS_Connection=yes; “MultipleActiveResultSets=true”与MARS_Connection=yes”是相同的。 使用ADO.NET 2.0作为MARS的模块。 MARS不支持ADO.NET 1.0和ADO.NET 1.1。 验证网络数据 Driver={SQL Native Client}; Server=myServerAddress;Database=myDataBase; Trusted_Connection=yes;Encrypt=yes; 使用附加本地数据库文件的方式连接到本地SQL Server Express实例 Driver={SQL Native Client};Server=./SQLExpress; AttachDbFilename=c:/asd/qwe/mydbfile.mdf; Database=dbname;Trusted_Connection=Yes; 为何要使用Database参数？如果同名的数据库已经被附加，那么SQL Server将不会重新附加。 使用附加本地数据文件夹中的数据库文件的方式连接到本地SQL Server Express实例 Driver={SQL Native Client};Server=./SQLExpress; AttachDbFilename=|DataDirectory|mydbfile.mdf; Database=dbname; Trusted_Connection=Yes; 为何要使用Database参数？如果同名的数据库已经被附加，那么SQL Server将不会重新附加。 数据库镜像 Data Source=myServerAddress; Failover Partner=myMirrorServer;Initial Catalog=myDataBase;Integrated Security=True;</p>
<h3 id="SQL-Native-Client-OLE-DB-Provider"><a href="#SQL-Native-Client-OLE-DB-Provider" class="headerlink" title="SQL Native Client OLE DB Provider"></a>SQL Native Client OLE DB Provider</h3><p>标准连接 Provider=SQLNCLI;Server=myServerAddress; Database=myDataBase;Uid=myUsername;Pwd=myPassword; 受信的连接 Provider=SQLNCLI;Server=myServerAddress; Database=myDataBase;Trusted_Connection=yes; 连接到SQL Server实例 指定服务器实例的表达式和其他SQL Server的连接字符串相同。 Provider=SQLNCLI;Server=myServerName/theInstanceName; Database=myDataBase;Trusted_Connection=yes; 使用帐号和密码 oConn.Properties(“Prompt”) = adPromptAlways oConn.Open “Provider=SQLNCLI;Server=myServerAddress;DataBase=myDataBase; 使用MARS (multiple active result sets) Provider=SQLNCLI;Server=myServerAddress;Database=myDataBase;Trusted_Connection=yes;MarsConn=yes; “MultipleActiveResultSets=true”和”MARS_Connection=yes”是相同的。 使用ADO.NET 2.0作为MARS的模块。 MARS不支持ADO.NET 1.0和ADO.NET 1.1。 验证网络数据 Provider=SQLNCLI;Server=myServerAddress; Database=myDataBase;Trusted_Connection=yes;Encrypt=yes; 使用附加本地数据库文件的方式连接到本地SQL Server Express实例 Provider=SQLNCLI;Server=./SQLExpress;AttachDbFilename=c:/asd/qwe/mydbfile.mdf; Database=dbname;Trusted_Connection=Yes; 使用附加本地数据文件夹中的数据库文件的方式连接到本地SQL Server Express实例 Provider=SQLNCLI;Server=./SQLExpress; AttachDbFilename=|DataDirectory|mydbfile.mdf; Database=dbname;Trusted_Connection=Yes; 数据库镜像 Data Source=myServerAddress;Failover Partner=myMirrorServer; Initial Catalog=myDataBase;Integrated Security=True;</p>
<h3 id="SqlConnection-NET"><a href="#SqlConnection-NET" class="headerlink" title="SqlConnection (.NET)"></a>SqlConnection (.NET)</h3><p>标准连接 Data Source=myServerAddress; Initial Catalog=myDataBase;User Id=myUsername;Password=myPassword; Standard Security alternative syntax Server=myServerAddress;Database=myDataBase;User ID=myUsername;Password=myPassword;Trusted_Connection=False; 受信任的连接 Data Source=myServerAddress;Initial Catalog=myDataBase;Integrated Security=SSPI; Trusted Connection alternative syntax Server=myServerAddress;Database=myDataBase;Trusted_Connection=True; 连接到一个SQL Server的实例 指定服务器实例的表达式和其他SQL Server的连接字符串相同。 Server=myServerName/theInstanceName;Database=myDataBase;Trusted_Connection=True; 来自WinCE设备的安全连接 Data Source=myServerAddress; Initial Catalog=myDataBase; Integrated Security=SSPI;User ID=myDomain/myUsername;Password=myPassword; 仅能用于CE设备。 带有IP地址的连接 Data Source=190.190.200.100,1433;Network Library=DBMSSOCN;Initial Catalog=myDataBase;User ID=myUsername;Password=myPassword; 使用MARS (multiple active result sets) Server=myServerAddress;Database=myDataBase;Trusted_Connection=True; MultipleActiveResultSets=true; 使用ADO.NET 2.0作为MARS的模块。 MARS不支持ADO.NET 1.0和ADO.NET 1.1。 使用附加本地数据库文件的方式连接到本地SQL Server Express实例 Server=./SQLExpress;AttachDbFilename=c:/asd/qwe/mydbfile.mdf; Database=dbname;Trusted_Connection=Yes; 使用附加本地数据文件夹中的数据库文件的方式连接到本地SQL Server Express实例 Server=./SQLExpress;AttachDbFilename=|DataDirectory|mydbfile.mdf; Database=dbname;Trusted_Connection=Yes; 使用在SQL Server Express实例上的用户实例 Data Source=./SQLExpress;Integrated Security=true;AttachDbFilename=|DataDirectory|/mydb.mdf;User Instance=true; 数据库镜像 Data Source=myServerAddress;Failover Partner=myMirrorServer;Initial Catalog=myDataBase;Integrated Security=True; Asynchronous processing Server=myServerAddress; Database=myDataBase; Integrated Security=True; Asynchronous Processing=True;</p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="MyODBC"><a href="#MyODBC" class="headerlink" title="MyODBC"></a>MyODBC</h3><p>MyODBC 2.50 本地数据库 Driver={mySQL};Server=localhost;Option=16834;Database=myDataBase; MyODBC 2.50 远程数据库 Driver={mySQL}; Server=myServerAddress;Port=3306; Option=131072;Stmt=; Database=myDataBase; Uid=myUsername; Pwd=myPassword; MyODBC 3.51 本地数据库 Driver={MySQL ODBC 3.51 Driver};Server=localhost;Database=myDataBase; User=myUsername;Password=myPassword;Option=3; MyODBC 3.51 远程数据库 Driver={MySQL ODBC 3.51 Driver};Server=data.domain.com;Port=3306; Database=myDataBase; User=myUsername; Password=myPassword;Option=3;</p>
<h3 id="OLE-DB-OleDbConnection-NET"><a href="#OLE-DB-OleDbConnection-NET" class="headerlink" title="OLE DB, OleDbConnection (.NET)"></a>OLE DB, OleDbConnection (.NET)</h3><p>标准 Provider=MySQLProv; Data Source=mydb; User Id=myUsername; Password=myPassword; Connector/Net 1.0 (.NET) 标准 Server=myServerAddress; Database=myDataBase; Uid=myUsername;Pwd=myPassword; 默认端口号是3306 指定端口号 Server=myServerAddress; Port=1234;Database=myDataBase; Uid=myUsername; Pwd=myPassword; 命名管道 Server=myServerAddress; Port=-1;Database=myDataBase; Uid=myUsername;Pwd=myPassword; 如果端口是-1，意思是告诉驱动程序使用命名管道网络协议来连接数据库。</p>
<h3 id="MySqlConnection-NET"><a href="#MySqlConnection-NET" class="headerlink" title="MySqlConnection (.NET)"></a>MySqlConnection (.NET)</h3><p>eInfoDesigns.dbProvider Data Source=myServerAddress; Database=myDataBase;User ID=myUsername; Password=myPassword; Command Logging=false; SevenObjects MySqlClient (.NET) 标准 Host=myServerAddress; UserName=myUsername; Password=myPassword; Database=myDataBase; Core Labs MySQLDirect (.NET) 标准 User ID=root;Password=myPassword;Host=localhost;Port=3306;Database=myDataBase; Direct=true;Protocol=TCP;Compress=false;Pooling=true;Min Pool Size=0;Max Pool Size=100;Connection Lifetime=0; MySQLDriverCS (.NET) 标准 Location=myServerAddress; Data Source=myDataBase; UserID=myUsername; Password=myPassword; Port=3306;Extended Properties=”“”“;</p>
<h2 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><h3 id="ODBC-1"><a href="#ODBC-1" class="headerlink" title="ODBC"></a>ODBC</h3><p>新版本 Driver={Microsoft ODBC for Oracle}; Server=myServerAddress; Uid=myUsername;Pwd=myPassword; 旧版本 Driver={Microsoft ODBC Driver for Oracle}; ConnectString=OracleServer.world; Uid=myUsername; Pwd=myPassword;</p>
<h3 id="OLE-DB-OleDbConnection-NET-1"><a href="#OLE-DB-OleDbConnection-NET-1" class="headerlink" title="OLE DB, OleDbConnection (.NET)"></a>OLE DB, OleDbConnection (.NET)</h3><p>标准连接 此连接字符串适用了微软的驱动。 Provider=msdaora;Data Source=MyOracleDB; User Id=myUsername; Password=myPassword; 受信连接 Provider=msdaora; Data Source=MyOracleDB; Persist Security Info=False; Integrated Security=Yes; 标准连接 由Oracle提供的驱动。 Provider=OraOLEDB. Oracle;Data Source=MyOracleDB; User Id=myUsername; Password=myPassword; 受信连接 Provider=OraOLEDB.Oracle;Data Source=MyOracleDB;OSAuthent=1; Oracle.DataAccess.Client.OracleConnection 标准 Data Source=TORCL;User Id=myUsername; Password=myPassword; 标准安全连接 Data Source=TORCL;Integrated Security=SSPI; 使用ODP.NET而不使用tnsnames.ora Data Source=(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=MyHost) (PORT=MyPort)))(CONNECT_DATA=(SERVER=DEDICATED)(SERVICE_NAME=MyOracleSID))); User Id=myUsername;Password=myPassword; OracleConnection, Oracle Data Provider, ODP.NET. System.Data.OracleClient.OracleConnection. 标准 用于8i RC3及以后的版本 Data Source=MyOracleDB;Integrated Security=yes; 指定用户名和密码 用于8i RC3及以后的版本 Data Source=MyOracleDB; User Id=myUsername; Password=myPassword; Integrated Security=no; 忽略tnsnames.ora 另一种不需要使用DSN的连接方式 SERVER=(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=MyHost) (PORT=MyPort))(CONNECT_DATA=(SERVICE_NAME=MyOracleSID))); uid=myUsername;pwd=myPassword; 使用上面的连接字符串可能会导致Visual Studio报告错误。 如果您在使用中出现了这些问题，请使用下面的这种连接方式。 Data Source=(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=MyHost)(PORT=MyPort)) (CONNECT_DATA=(SERVICE_NAME=MyOracleSID))); User Id=myUsername; Password=myPassword; 使用连接池 如果连接池服务程序找不到已经存在的连接池，它将根据连接字符串创建一个新的池。 否则将循环使用池中已存在的连接。 Data Source=myOracleDB; User Id=myUsername; Password=myPassword;Min Pool Size=10;Connection Lifetime=120; Connection Timeout=60;Incr Pool Size=5;Decr Pool Size=2; Windows身份验证 Data Source=myOracleDB;User Id=/; 特权连接 使用SYSDBA Data Source=myOracleDB;User Id=SYS;Password=SYS; DBA Privilege=SYSDBA; 特权连接 使用SYSOPER Data Source=myOracleDB;User Id=SYS;Password=SYS;DBA Privilege=SYSOPER; 密码过期处理过程 当使用一个连接字符串连接数据库后，出现”密码已过期”的错误时。 请执行OpenWithNewPassword命令来提供新密码。 Data Source=myOracleDB;User Id=myUsername;Password=myPassword; oConn.OpenWithNewPassword(sTheNewPassword); Proxy验证 Data Source=myOracleDB; User Id=myUsername; Password=myPassword;Proxy User Id=pUserId; Proxy Password=pPassword; Core Labs OraDirect (.NET) Standard User ID=myUsername; Password=myPassword; Host=ora;Pooling=true; Min Pool Size=0;Max Pool Size=100;Connection Lifetime=0; Data Shape MS Data Shape Provider=MSDataShape.1;Persist Security Info=False;Data Provider=MSDAORA; Data Source=orac;User Id=myUsername; Password=myPassword;</p>
<h2 id="AS-400-iSeries"><a href="#AS-400-iSeries" class="headerlink" title="AS/400 (iSeries)"></a>AS/400 (iSeries)</h2><p>IBM .Net Data Provider 您需要使用 IBM.Data.DB2.iSeries 命名空间 DataSource=myServerAddress;UserID=myUsername; Password=myPassword;DataCompression=True; OLE DB, OleDbConnection (.NET) IBM Client Access OLE DB 适配器 Provider=IBMDA400;Data Source=MY_SYSTEM_NAME;User Id=myUsername; Password=myPassword; MY_SYSTEM_NAME是在OperationsNavigator中的系统连接名称。 IBM Client Access OLE DB 适配器 Provider=IBMDA400;Data Source=MY_SYSTEM_NAME;User Id=myUsername; Password=myPassword;Default Collection=MY_LIBRARY; MY_SYSTEM_NAME是系统连接的名称，MY_LIBRARY是iSeries Navigator中library的名称。 ODBC IBM Client Access ODBC 驱动 Driver={Client Access ODBC Driver (32-bit)};System=my_system_name; Uid=myUsername; Pwd=myPassword; IBM iSeries Access ODBC 驱动 这个驱动需要比IBM Client Access ODBC的驱动更新。 Driver={iSeries Access ODBC Driver};System=my_system_name; Uid=myUsername; Pwd=myPassword;</p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Caché"></a>Caché</h2><p>ODBC 标准 DRIVER={InterSystems ODBC};SERVER=myServerAddress; DATABASE=myDataBase; UID=myUsername;PWD=myPassword; 特定端口 DRIVER={InterSystems ODBC};SERVER=myServerAddress;PORT=12345; DATABASE=myDataBase; UID=myUsername;PWD=myPassword; 特定协议 DRIVER={InterSystems ODBC};SERVER=myServerAddress;PORT=12345; DATABASE=myDataBase; PROTOCOL=TCP;STATIC CURSORS=1;UID=myUsername;PWD=myPassword;</p>
<h2 id="IBM-DB2"><a href="#IBM-DB2" class="headerlink" title="IBM DB2"></a>IBM DB2</h2><p>OLE DB, OleDbConnection (.NET) TCP/IP Provider=DB2OLEDB;Network Transport Library=TCPIP;Network Address=XXX.XXX.XXX.XXX; Initial Catalog=MyCtlg;Package Collection=MyPkgCol;Default Schema=Schema;User ID=myUsername; Password=myPassword; APPC Provider=DB2OLEDB;APPC Local LU Alias=MyAlias;APPC Remote LU Alias=MyRemote; Initial Catalog=MyCtlg;Package Collection=MyPkgCol; Default Schema=Schema;User ID=myUsername;Password=myPassword; IBM提供的OLE DB适配器 TCP/IP Provider=IBMDADB2;Database=myDataBase; Hostname=myServerAddress; Protocol=TCPIP;Port=50000; Uid=myUsername;Pwd=myPassword; ODBC 标准 Driver={IBM DB2 ODBC DRIVER}; Database=myDataBase;Hostname=myServerAddress; Port=1234;Protocol=TCPIP;Uid=myUsername;Pwd=myPassword;</p>
<h2 id="Firebird"><a href="#Firebird" class="headerlink" title="Firebird"></a>Firebird</h2><p>ODBC - IBPhoenix Open Source 标准 Driver=Firebird/InterBase(r) driver;Uid=SYSDBA; Pwd=masterkey; DbName=D:/FIREBIRD/examples/TEST.FDB; .NET - Firebird .Net Data Provider 标准 User=SYSDBA;Password=masterkey;Database=SampleDatabase.fdb; DataSource=localhost;Port=3050;Dialect=3; Charset=NONE;Role=; Connection lifetime=15;Pooling=true;MinPoolSize=0;MaxPoolSize=50;Packet Size=8192;ServerType=0;</p>
<h2 id="Informix"><a href="#Informix" class="headerlink" title="Informix"></a>Informix</h2><p>ODBC Informix 3.30 Dsn=;Driver={INFORMIX 3.30 32 BIT};Host=hostname;Server=myServerAddress; Service=service-name; Protocol=olsoctcp; Database=myDataBase;Uid=myUsername;Pwd=myPassword; Informix-CLI 2.5: Driver={Informix-CLI 2.5 (32 Bit)};Server=myServerAddress; Database=myDataBase; Uid=myUsername;Pwd=myPassword; OLE DB IBM Informix OLE DB Provider Provider=Ifxoledbc.2;Password=myPassword; User ID=myUsername; Data Source=dbName@serverName;Persist Security Info=true; IBM Informix .NET Provider IBM.Data.Informix.IfxConnection(命名空间) Database=myDataBase;Host=192.168.10.10; Server=db_engine_tcp; Service=1492; Protocol=onsoctcp;UID=myUsername;Password=myPassword; ##Ingres ODBC DSN-less Provider=MSDASQL.1;DRIVER=Ingres;SRVR=xxxxx;DB=xxxxx;Persist SecurityInfo=False;Uid=myUsername;Pwd=myPassword; SELECTLOOPS=N; ExtendedProperties=”SERVER=xxxxx;DATABASE=xxxxx;SERVERTYPE=INGRES”;</p>
<h2 id="Interbase"><a href="#Interbase" class="headerlink" title="Interbase"></a>Interbase</h2><p>ODBC, Easysoft 本地计算机 Driver={Easysoft IB6 ODBC}; Server=localhost ;Database=localhost:C:/mydatabase.gdb; Uid=myUsername; Pwd=myPassword; 远程计算机 Driver={Easysoft IB6 ODBC}; Server=myServerAddress; Database=ComputerName: C:/mydatabase.gdb; Uid=myUsername;Pwd=myPassword; ODBC, Intersolv 本地计算机 Driver={INTERSOLV InterBase ODBC Driver (<em>.gdb)}; Server=localhost; Database=localhost: C:/mydatabase.gdb; Uid=myUsername; Pwd=myPassword; 远程计算机 Driver={INTERSOLV InterBase ODBC Driver (</em>.gdb)}; Server=myServerAddress; Database=ComputerName: C:/mydatabase.gdb;Uid=myUsername; Pwd=myPassword; OLE DB, SIBPROvider 标准 provider=sibprovider;location=localhost:;data source=c:/databases/gdbs/mygdb.gdb; user id=SYSDBA; Password=masterkey; 版本 2.x Provider=SIBPROvider.2; Data Source=localhost:c:/databases/gdbs/mygdb.gdb; Persist Security Info=False; 指定字符集 provider=sibprovider;location=localhost:;data source=c:/databases/gdbs/mygdb.gdb; user id=SYSDBA; Password=masterkey; character set=ISO8859_1; 指定角色 provider=sibprovider;location=localhost:; data source=c:/databases/gdbs/mygdb.gdb;user id=SYSDBA; Password=masterkey; role=DIGITADORES; Lightbase 标准连接 标准 User=myUsername;Password=myPassword;UDB=USERBASE;Server=myServerAddress; Paradox ODBC 5.X Driver={Microsoft Paradox Driver (*.db )}; DriverID=538;Fil=Paradox 5.X; DefaultDir=c:/pathToDb/;Dbq=c:/pathToDb/;CollatingSequence=ASCII; 7.X Provider=MSDASQL.1;Persist Security Info=False; Mode=Read;Extended Properties=DSN=Paradox; DBQ=C:/myDb;DefaultDir=C:/myDb;DriverId=538; FIL=Paradox 7.X; MaxBufferSize=2048;PageTimeout=600;;Initial Catalog=C:/myDb; 请注意：以上的方法仅能从数据库获取数据。 Intersolv 3.11 ODBC Driver 7.X DSN=MyDSN;AUT=1;CT=7;DQ=0;FOC=0;IS=1; PW=myPassword;USF=1;ULQ=1; 并不是所有参数都是必填的。大多数参数都能够在DSN中进行设置。 Parameters definition AUT - ApplicationUsingThreads CT - CreateType DB - Database DSN - DataSourceName DQ - DeferQueryEvaluation FOC - FileOpenCache IS - IntlSort ND - NetDir PW - Passwords USF - UltraSafeCommit ULQ - UseLongQualifiers OleDbConnection (.NET) 标准 Provider=Microsoft.Jet.OLEDB.4.0;Data Source=c:/myDb;Extended Properties=Paradox 5.x; 注意：您仅需要指定数据库存放的地址而无需指定数据库的名称。</p>
<h2 id="SQLBase"><a href="#SQLBase" class="headerlink" title="SQLBase"></a>SQLBase</h2><p>OLE DB 标准 Provider=SQLBaseOLEDB;Data source=myServerAddress; Location=myDataBase; User Id=myUsername; Password=myPassword; SQLBase .NET Data Provider 标准SQLBase连接 DataSource=myServerAddress; UserId=myUsername; Password=myPassword;Poolsize=5;Connection Lifetime=60; “Poolsize” 表示多少SQLBase连接被打开，不论它们是否被立即使用。默认值是5。 “Connection Lifetime” 表示连接存在多长时间(单位：秒)。默认是60秒。</p>
<h2 id="SQL-Serve"><a href="#SQL-Serve" class="headerlink" title="SQL Serve"></a>SQL Serve</h2><p>ODBC 标准连接 Driver={SQL Server};Server=myServerAddress; Database=myDataBase;Uid=myUsername;Pwd=myPassword; 受信的连接 Driver={SQL Server};Server=myServerAddress; Database=myDataBase;Trusted_Connection=Yes; 指定帐号和密码 oConn.Properties(“Prompt”) = adPromptAlways Driver={SQL Server}; Server=myServerAddress;Database=myDataBase; OLE DB, OleDbConnection (.NET) 标准连接 Provider=sqloledb;Data Source=myServerAddress;Initial Catalog=myDataBase;User Id=myUsername;Password=myPassword; 受信的连接 Provider=sqloledb;Data Source=myServerAddress;Initial Catalog=myDataBase;Integrated Security=SSPI; 使用serverName/instanceName作为数据源可以指定SQL Server实例。 连接到一个SQL Server的实例 指定服务器实例的表达式和其他SQL Server的连接字符串相同。 Provider=sqloledb; Data Source=myServerName/theInstanceName; Initial Catalog=myDataBase;Integrated Security=SSPI; 指定帐户和密码 oConn.Provider = “sqloledb” oConn.Properties(“Prompt”) = adPromptAlways Data Source=myServerAddress;Initial Catalog=myDataBase; 使用IP地址的连接 Provider=sqloledb;Data Source=190.190.200.100,1433; Network Library=DBMSSOCN;Initial Catalog=myDataBase; User ID=myUsername; Password=myPassword; SqlConnection (.NET) 标准连接 Data Source=myServerAddress;Initial Catalog=myDataBase; User Id=myUsername;Password=myPassword; Standard Security alternative syntax Server=myServerAddress;Database=myDataBase;User ID=myUsername;Password=myPassword;Trusted_Connection=False; 受信任的连接 Data Source=myServerAddress;Initial Catalog=myDataBase;Integrated Security=SSPI; Trusted Connection alternative syntax Server=myServerAddress;Database=myDataBase;Trusted_Connection=True; 连接到SQL Server实例 指定服务器实例的表达式和其他SQL Server的连接字符串相同。 Server=myServerName/theInstanceName;Database=myDataBase; Trusted_Connection=True; 仅能用于CE设备。 Data Source=myServerAddress;Initial Catalog=myDataBase;Integrated Security=SSPI;User ID=myDomain/myUsername;Password=myPassword; 带有IP地址的连接 Data Source=190.190.200.100,1433;Network Library=DBMSSOCN;Initial Catalog=myDataBase; User ID=myUsername;Password=myPassword; 指定包的大小 Server=myServerAddress;Database=myDataBase;User ID=myUsername;Password=myPassword; Trusted_Connection=False;Packet Size=4096; 默认的包大小为8192字节。 Data Shape MS Data Shape Provider=MSDataShape;Data Provider=SQLOLEDB;Data Source=myServerAddress; Initial Catalog=myDataBase;User ID=myUsername;Password=myPassword;</p>

            
            <p class="more">
                <a href="/2015/09/16/2019030500032/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/16/2019030500032/" title="数据库连接字符串的困惑">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/6.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/11/2019030500067/">
    		MYSQL主备复制结构搭建与切换
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-11T05:01:22.000Z">2015-09-11</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p><strong>1 选择两个服务器，分别作为主备数据库</strong> <strong>2 登陆到服务器，安装相同版本mysql</strong></p>
<p><strong>[sql]</strong></p>
<ol>
<li>yum install mysql ;</li>
<li>yum install mysql-server;</li>
</ol>
<p><strong>3 启动mysql服务器 </strong> service  mysqld start <strong>4 分别root登陆mysql 执行如下命令</strong> 增加复制用户并授权（主备都在192.168.119.*网段，为了方便主备切换，两边都建立）</p>
<p><strong>[sql]</strong></p>
<ol>
<li>GRANT  REPLICATION SLAVE,REPLICATION CLIENT on <em>.</em> to repl@’192.168.119.%’ identified by ‘1234’;</li>
</ol>
<p><strong>5 配置/etc/my.cnf</strong> 第一服务器（主）</p>
<p><strong>[sql]</strong></p>
<ol>
<li>log_bin=mysql-bin</li>
<li>server_id=1</li>
</ol>
<p>第二个服务器（备）</p>
<p><strong>[sql]</strong></p>
<ol>
<li>log_bin=mysql-bin</li>
<li>server_id=2</li>
<li>read_only=1</li>
</ol>
<p><strong>6 重启两个mysql服务器**</strong>7 登陆主（root）执行**</p>
<p><strong>[sql]</strong></p>
<ol>
<li>show master status\G;</li>
</ol>
<p>显示 File: mysql-bin.000001 Position: 106 <strong>8 登陆备(root) 执行</strong> 测试 mysql -urepl -h192.168.119.128 -p1234 是否能连接到主库，不能需要检查防火墙或者/etc/my.cnf是否有访问限制，修改配置 mysql -uroot登陆本地库执行：</p>
<p><strong>[sql]</strong></p>
<ol>
<li>CHANGE MASTER TO</li>
<li>MASTER_HOST=’192.168.119.128’,</li>
<li>MASTER_USER=’repl’,</li>
<li>MASTER_PASSWORD=’1234’,</li>
<li>MASTER_LOG_FILE=’mysql-bin.000001’,</li>
<li>MASTER_LOG_POS=106;</li>
</ol>
<p><strong>[sql]</strong></p>
<ol>
<li>start slave;</li>
<li>show slave status\G;</li>
</ol>
<p><strong>9，验证</strong> 主库上创建表，备库上查看，可以看到 备库上repl创建表，显示The MySQL server is running with the –read-only option so it cannot execute this statement 因为配置了备库为read_only <strong>10，后续关注</strong> 以后重启主备库，不用再配置change master。每重启一次主库会发现logfile 变成一个新的文件mysql-bin.000004 <strong>11 ,主从切换</strong> 11.1 修改配置文件/etc/my.cnf</p>
<p><strong>[sql]</strong></p>
<ol>
<li>read-only=1（主库）</li>
<li>#read-only=1（备库）</li>
</ol>
<p>11.2 从库上执行</p>
<p><strong>[sql]</strong></p>
<ol>
<li>STOP SLAVE IO_THREAD;</li>
<li>SHOW PROCESSLIST;</li>
</ol>
<p>system user 线程确保状态为：has read all relay log 或者消失 再执行</p>
<p><strong>[sql]</strong></p>
<ol>
<li>STOP SLAVE;</li>
<li>RESET MASTER;</li>
<li>RESET SLAVE;</li>
<li>show master status \G；</li>
</ol>
<p>结果 File: mysql-bin.000001 Position: 106 11.3 主库上执行</p>
<p><strong>[sql]</strong></p>
<ol>
<li>RESET MASTER;</li>
<li>RESET SLAVE;</li>
</ol>
<p><strong>[sql]</strong></p>
<ol>
<li>CHANGE MASTER TO</li>
<li>MASTER_HOST=’192.168.119.129’,</li>
<li>MASTER_USER=’repl’,</li>
<li>MASTER_PASSWORD=’1234’,</li>
<li>MASTER_LOG_FILE=’mysql-bin.000001’,</li>
<li>MASTER_LOG_POS=106;</li>
</ol>
<p><strong>[sql]</strong></p>
<ol>
<li>start slave</li>
</ol>
<p>11.4 重启主备库，注意先重启新的主库，再启动新的备库</p>
<p><strong>[sql]</strong></p>
<ol>
<li>service mysqld restart</li>
</ol>
<p>11.5 验证 原来的主库已经变成从库，从库变成主库。</p>
</blockquote>

            
            <p class="more">
                <a href="/2015/09/11/2019030500067/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/11/2019030500067/" title="MYSQL主备复制结构搭建与切换">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/11/2019030500011/">
    		加快mydumper与myloader导出导入
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-11T04:58:23.000Z">2015-09-11</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/SQL/" title="SQL">SQL</a> / 
    
        <a href="/tags/数据库/" title="数据库">数据库</a> / 
    
        <a href="/tags/Database/" title="Database">Database</a> / 
    
        <a href="/tags/dba/" title="dba">dba</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>mydumper与myloader是一个优秀的第三方mysql数据库逻辑备份恢复工具，使用多线程的导出与导入。弥补了mysqldump单线程的不足。本文描述的是如何加快mydumper与myloader的导出与导入供大家参考。 1、基于MyIsam引擎导出导入 a、表不分块导出及导入 [root@GZAPP tmp]# mydumper -u inno -p xxx -B bsom -T tb_access_log -o /backup/tmp/ [root@GZAPP tmp]# ls -hltr   ###导出的数据文件为单个文件，大小在2.6GB total 2.6G -rw-r–r– 1 root root 1.6K Jul 24 08:51 bsom.tb_access_log-schema.sql -rw-r–r– 1 root root  214 Jul 24 08:52 metadata -rw-r–r– 1 root root 2.6G Jul 24 08:52 bsom.tb_access_log.sql ###基于缺省线程数导入，且设定每个事务查询数为10000，此参数此时其实作用不大，因为表为myisam引擎 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -d /backup/tmp -v 3 -q 10000 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -d /backup/tmp -v 3 -q 10000 <strong> Message: 4 threads created </strong> Message: Creating table `tempdb`.`tb_access_log` <strong> Message: Thread 4 shutting down </strong> Message: Thread 1 restoring `bsom`.`tb_access_log` part 0 <strong> Message: Thread 3 shutting down </strong> Message: Thread 2 shutting down root@localhost[tempdb]&gt; show processlist; +———+———+———-+——–+———+——–+———+————————————————+ | Id      | User    | Host     | db     | Command | Time   | State   | Info                                           | +———+———+———-+——–+———+——–+———+————————————————+ | 4452079 | root    | localhost| tempdb | Query   |      0 | init    | show processlist                               | | 4453793 | inno    | localhost| tempdb | Sleep   |    420 |         | NULL                                           | | 4453794 | inno    | localhost| tempdb | Query   |      4 | update  | INSERT INTO `tb_access_log` VALUES (506873,”325| +———+———+———-+——–+———+——–+———+————————————————+ ###从上面的线程数可以看出只有一个单线程在执行insert操作 b、表分块导出及导入 ###下面的示例中使用500MB进行分块 [root@GZAPP tmp]# mydumper -u inno -p xxx -B bsom -T tb_access_log -F 500 -o /backup/tmp/ [root@GZAPP tmp]# ls -hltr total 2.6G -rw-r–r– 1 root root 1.6K Jul 24 08:21 bsom.tb_access_log-schema.sql -rw-r–r– 1 root root 478M Jul 24 08:21 bsom.tb_access_log.00001.sql -rw-r–r– 1 root root 478M Jul 24 08:21 bsom.tb_access_log.00002.sql -rw-r–r– 1 root root 478M Jul 24 08:21 bsom.tb_access_log.00003.sql -rw-r–r– 1 root root 478M Jul 24 08:21 bsom.tb_access_log.00004.sql -rw-r–r– 1 root root 478M Jul 24 08:22 bsom.tb_access_log.00005.sql -rw-r–r– 1 root root  214 Jul 24 08:22 metadata -rw-r–r– 1 root root 241M Jul 24 08:22 bsom.tb_access_log.00006.sql ###由上可知，大表tb_access_log按接近500M被分割成了多个文件 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -t 6 -d /backup/tmp -v 3 <strong> Message: 6 threads created </strong> Message: Creating database `tempdb` <strong> Message: Creating table `tempdb`.`tb_access_log` </strong> Message: Thread 1 restoring `bsom`.`tb_access_log` part 3 <strong> Message: Thread 2 restoring `bsom`.`tb_access_log` part 5 </strong> Message: Thread 5 restoring `bsom`.`tb_access_log` part 4 <strong> Message: Thread 3 restoring `bsom`.`tb_access_log` part 6 </strong> Message: Thread 4 restoring `bsom`.`tb_access_log` part 1 <strong> Message: Thread 6 restoring `bsom`.`tb_access_log` part 2 #在下面的processlist可以看到，存在表级锁等待 +———+——-+———–+———+———+——–+—————————–+————————————————+ | Id      | User  | Host      | db      | Command | Time   | State                       | Info                                           | +———+——-+———–+———+———+——–+—————————–+————————————————+ | 4452079 | root  | localhost | bsom    | Query   |      0 | init                        | show processlist                               | | 4452167 | inno  | localhost | tempdb  | Sleep   |    769 |                             | NULL                                           | | 4452168 | inno  | localhost | tempdb  | Query   |     36 | update                      | INSERT INTO `tb_access_log` VALUES (6367402,”0,| | 4452169 | inno  | localhost | tempdb  | Query   |     21 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (12593865,” | | 4452170 | inno  | localhost | tempdb  | Query   |     26 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (15643029,””| | 4452171 | inno  | localhost | tempdb  | Query   |      6 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (173947,”70 | | 4452172 | inno  | localhost | tempdb  | Query   |     15 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (9490507,”7 | | 4452173 | inno  | localhost | tempdb  | Query   |     30 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (3271602,”4 | +———+———+———–+———+———+——–+—————————–+———————————————-+ c、调整myisam有关参数后导入 [root@GZ-APP-BAK01 tmp]# time myloader -u innobk -p InnoBK -B tempdb -t 6 -d /backup/tmp -v 3 </strong> Message: 6 threads created <strong> Message: Creating table `tempdb`.`tb_mobile_access_log` </strong> Message: Thread 1 restoring `blossom`.`tb_mobile_access_log` part 3 <strong> Message: Thread 6 restoring `blossom`.`tb_mobile_access_log` part 6 </strong> Message: Thread 2 restoring `blossom`.`tb_mobile_access_log` part 5 <strong> Message: Thread 3 restoring `blossom`.`tb_mobile_access_log` part 4 </strong> Message: Thread 4 restoring `blossom`.`tb_mobile_access_log` part 1 <strong> Message: Thread 5 restoring `blossom`.`tb_mobile_access_log` part 2 </strong> Message: Thread 6 shutting down <strong> Message: Thread 5 shutting down </strong> Message: Thread 1 shutting down <strong> Message: Thread 2 shutting down </strong> Message: Thread 4 shutting down <strong> Message: Thread 3 shutting down real    266m28.903s user    0m6.008s sys     0m1.681s ###调整以下相关参数，后尝试再次导入， concurrent_insert  AUTO 改成 ALWAYS bulk_insert_buffer_size 8388608 改成 256M myisam_sort_buffer_size 67108864 改成 128M [root@GZ-APP-BAK01 tmp]# time myloader -u innobk -p InnoBK -B tempdb -t 6 -o -d /backup/tmp -v 3 </strong> Message: 6 threads created <strong> Message: Dropping table (if exists) `tempdb`.`tb_mobile_access_log` </strong> Message: Creating table `tempdb`.`tb_mobile_access_log` <strong> Message: Thread 1 restoring `blossom`.`tb_mobile_access_log` part 3 </strong> Message: Thread 2 restoring `blossom`.`tb_mobile_access_log` part 6 <strong> Message: Thread 3 restoring `blossom`.`tb_mobile_access_log` part 5 </strong> Message: Thread 4 restoring `blossom`.`tb_mobile_access_log` part 4 <strong> Message: Thread 6 restoring `blossom`.`tb_mobile_access_log` part 1 </strong> Message: Thread 5 restoring `blossom`.`tb_mobile_access_log` part 2 <strong> Message: Thread 2 shutting down </strong> Message: Thread 1 shutting down <strong> Message: Thread 6 shutting down </strong> Message: Thread 5 shutting down <strong> Message: Thread 3 shutting down </strong> Message: Thread 4 shutting down real    253m42.460s   ###此时导入时间并无明显减少 user    0m5.924s sys     0m1.637s 2、基于innodb引擎的导出导入 a、表未分块导出，数据文件大小为3.9GB [root@GZAPP tmp]# ls -hltr total 3.9G -rw-r–r– 1 root root 1.8K Jul 24 00:09 bscom.tb_message-schema.sql -rw-r–r– 1 root root 3.9G Jul 24 00:25 bscom.tb_message.sql -rw-r–r– 1 root root  215 Jul 24 09:14 metadata ###下面使用6个线程导入，实际上可以看到，只有1个线程在工作，因为数据文件只有1个 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -t 6 -d /backup/tmp -v 3 <strong> Message: 6 threads created </strong> Message: Creating table `tempdb`.`tb_message` <strong> Message: Thread 1 restoring `bscom`.`tb_message` part 0 </strong> Message: Thread 5 shutting down <strong> Message: Thread 2 shutting down </strong> Message: Thread 6 shutting down <strong> Message: Thread 3 shutting down </strong> Message: Thread 4 shutting down b、表分块导出 [root@GZAPP tmp]# mydumper -u inno -p xxx -B bscom -T tb_message -F 500 -o /backup/tmp/ [root@GZAPP tmp]# ls -hltr total 3.9G -rw-r–r– 1 root root 1.8K Jul 24 09:55 bscom.tb_message-schema.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00001.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00002.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00003.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00004.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00005.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00006.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00007.sql -rw-r–r– 1 root root 481M Jul 24 09:55 bscom.tb_message.00008.sql -rw-r–r– 1 root root  135 Jul 24 09:55 metadata -rw-r–r– 1 root root  93M Jul 24 09:55 bscom.tb_message.00009.sql ###下面尝试使用6线程导入，可以看到有6个线程在并发导入 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -t 6 -d /backup/tmp/ -v 3 <strong> Message: 6 threads created </strong> Message: Creating database `tempdb` <strong> Message: Creating table `tempdb`.`tb_message` </strong> Message: Thread 2 restoring `bscom`.`tb_message` part 5 <strong> Message: Thread 1 restoring `bscom`.`tb_message` part 9 </strong> Message: Thread 3 restoring `bscom`.`tb_message` part 1 <strong> Message: Thread 4 restoring `bscom`.`tb_message` part 8 </strong> Message: Thread 5 restoring `bscom`.`tb_message` part 4 <strong> Message: Thread 6 restoring `bscom`.`tb_message` part 6 </strong> Message: Thread 1 restoring `bscom`.`tb_message` part 7 <strong> Message: Thread 6 restoring `bscom`.`tb_message` part 3 </strong> Message: Thread 2 restoring `bscom`.`tb_message` part 2 <strong> Message: Thread 3 shutting down </strong> Message: Thread 5 shutting down <strong> Message: Thread 4 shutting down </strong> Message: Thread 1 shutting down <strong> Message: Thread 2 shutting down </strong> Message: Thread 6 shutting down 3、小结 a、mydumper在导出的时候可以根据服务器可用资源来合理地设置线程数。 b、mydumper在导出的时候尽可能地指定chunk-filesize或者rows参数以分块导出。 c、myloader在针对myisam引擎时建议调整相关参数至合理值以提高无法提高性能，主要是表级锁的问题。 d、myloader在针对innodb引擎时建议调整参数至合理值以提高性能，如以下参数等： innodb_buffer_pool_size innodb_flush_log_at_trx_commit innodb_log_buffer_size e、通过使用分块导出与导入可以显著利用并发来加快inndbo表导入。 f、注意mydumper导出时不会导出存储过程，函数，触发器等。</p>

            
            <p class="more">
                <a href="/2015/09/11/2019030500011/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/11/2019030500011/" title="加快mydumper与myloader导出导入">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/07/2019030500076/">
    		Mysql复合主键中自增长字段
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-07T04:51:47.000Z">2015-09-07</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/复合主键/" title="复合主键">复合主键</a> / 
    
        <a href="/tags/自增长/" title="自增长">自增长</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>Google Analytics的ID一般形如：UA-18xxxxx-<strong>1</strong>，UA-18xxxxx-<strong>4</strong>, 我们可以将它分成两段来看：字段1：UA-18XXXXX是指帐户的ID；字段2：字段1后附加的1、4，刚分别是指该帐户名下的两个网站。有一段时间很 纠结这样的ID怎么去维护，直到最近查阅到Mysql手册才发现，原来Mysql原生就很好的支持了这种含自动增长字段的复合主键，所以字段2是存储引擎 自动计算出来的。计算方式：MAX(_auto_increment_column_) + 1 WHERE prefix=<em>given-prefix</em> <a href="https://xiaobin.net/200905/mysql-auto-increasement-and-multi-primary-key/#fn:mysql_manual" target="_blank" rel="noopener">[1]</a>。 不多说，直接看SQL：</p>
<p>mysql&gt; CREATE TABLE `_test` (<br>    -&gt; `c1` varchar(20) NOT NULL DEFAULT ‘’, – 主键一：varchar<br>    -&gt; `c2` int(11) NOT NULL AUTO_INCREMENT, – 主键二：自增序列<br>    -&gt; `c3` varchar(255) ,<br>    -&gt; PRIMARY KEY (`c1`,`c2`) – 注意这里的先后顺序<br>    -&gt; ) ENGINE=MyISAM DEFAULT CHARSET=latin1;<br>Query OK, 0 rows affected (0.04 sec)</p>
<p>mysql&gt;<br>mysql&gt; INSERT INTO `_test` (`c1`,`c3`) VALUES (‘AAA’,’Robin Home’),<br>    -&gt; (‘AAA’,’Robin Blog’),<br>    -&gt; (‘AAA’,’Robin Resume’),<br>    -&gt; (‘BBB’,’Lily Home’),<br>    -&gt; (‘BBB’,’Lily Blog’);<br>Query OK, 5 rows affected (0.00 sec)<br>Records: 5  Duplicates: 0  Warnings: 0</p>
<p>mysql&gt;<br>mysql&gt; SELECT * FROM `_test`;<br>+—–+—-+————–+<br>| c1  | c2 | c3           |<br>+—–+—-+————–+<br>| AAA |  1 | Robin Home   |<br>| AAA |  2 | Robin Blog   |<br>| AAA |  3 | Robin Resume |<br>| BBB |  1 | Lily Home    |<br>| BBB |  2 | Lily Blog    |<br>+—–+—-+————–+<br>5 rows in set (0.00 sec)</p>
<p>mysql&gt;</p>
<p>值得注意的是，MySQL的这种特性只适用于MyISAM和BDB引擎。</p>

            
            <p class="more">
                <a href="/2015/09/07/2019030500076/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/07/2019030500076/" title="Mysql复合主键中自增长字段">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/7.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/开发语言/">开发语言</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/07/2019030500061/">
    		mybatis入门小程序
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-07T04:50:45.000Z">2015-09-07</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Mybatis/" title="Mybatis">Mybatis</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>结构 <a href="https://static.oschina.net/uploads/img/201509/06204843_TTPR.png" target="_blank" rel="noopener"><img src="/uploads/2015/09/06204843_TTPR.png" alt="工程结构" title="在这里输入图片标题"></a> SqlMapConfig.xml代码</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;
&lt;!DOCTYPE configuration
PUBLIC &quot;-//mybatis.org//DTD Config 3.0//EN&quot;
&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;&gt;
&lt;configuration&gt;
    &lt;environments default=&quot;development&quot;&gt;
        &lt;environment id=&quot;development&quot;&gt;
            &lt;transactionManager type=&quot;JDBC&quot;/&gt;
            &lt;dataSource type=&quot;POOLED&quot;&gt;
                &lt;property name=&quot;driver&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;
                &lt;property name=&quot;url&quot; value=&quot;jdbc:mysql://localhost:3306/test?characterEncoding=UTF-8&quot;/&gt;
                &lt;property name=&quot;username&quot; value=&quot;root&quot;/&gt;
                &lt;property name=&quot;password&quot; value=&quot;&quot;/&gt;
            &lt;/dataSource&gt;
        &lt;/environment&gt;
    &lt;/environments&gt;

    &lt;mappers&gt;
        &lt;mapper resource=&quot;sqlmap/User.xml&quot;/&gt;
    &lt;/mappers&gt;
&lt;/configuration&gt;
</code></pre><p>User.xml代码</p>
<pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;!DOCTYPE mapper PUBLIC &quot;-//mybatis.org//DTD Mapper 3.0//EN&quot; 
    &quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;&gt;
&lt;mapper namespace=&quot;test&quot;&gt;
    &lt;!-- 根据主键查询用户 --&gt;
    &lt;select id=&quot;selectUser&quot; parameterType=&quot;int&quot; resultType=&quot;org.jay.pojo.User&quot;&gt;
        select *
        from t_user where id=#{id}
    &lt;/select&gt;

    &lt;!-- 根据用户名模糊查询用户列表 --&gt;
    &lt;select id=&quot;selectUserByName&quot; parameterType=&quot;java.lang.String&quot;
        resultType=&quot;org.jay.pojo.User&quot;&gt;
        select * from t_user where user_name like &apos;%${value}%&apos;
    &lt;/select&gt;

    &lt;!-- 新增用户并返回主键 --&gt;
    &lt;insert id=&quot;insertUser&quot; parameterType=&quot;org.jay.pojo.User&quot;&gt;
        &lt;!-- 只适用于自增主键 --&gt;
        &lt;selectKey keyProperty=&quot;id&quot; order=&quot;AFTER&quot; resultType=&quot;java.lang.Integer&quot;&gt;
            select last_insert_id()
        &lt;/selectKey&gt;
        insert into t_user(user_name,pass_word)
        values(#{user_name},#{pass_word})
    &lt;/insert&gt;

    &lt;!-- 根据主键删除用户 --&gt;
    &lt;delete id=&quot;deleteUser&quot; parameterType=&quot;int&quot;&gt;
        delete from t_user  where id=#{id}
    &lt;/delete&gt;


    &lt;!-- 根据主键更新用户 --&gt;
    &lt;update id=&quot;updateUser&quot; parameterType=&quot;org.jay.pojo.User&quot;&gt;
        update t_user set user_name=#{user_name},pass_word=#{pass_word} where id=#{id}
    &lt;/update&gt;
&lt;/mapper&gt;
</code></pre><p>User.java代码</p>
<pre><code>package org.jay.pojo;

public class User {
    private int id;
    private String user_name;
    private String pass_word;

    public int getId() {
        return id;
    }

    public void setId(int id) {
        this.id = id;
    }

    public String getUser_name() {
        return user_name;
    }

    public void setUser_name(String user_name) {
        this.user_name = user_name;
    }

    public String getPass_word() {
        return pass_word;
    }

    public void setPass_word(String pass_word) {
        this.pass_word = pass_word;
    }

    public String toString(){
        return this.id+&quot;  &quot;+this.user_name+&quot;  &quot;+this.pass_word;
    }
}
</code></pre><p>log4j.properties代码</p>
<pre><code>log4j.rootLogger=BEBUG, stdout
log4j.appender.stdout=org.apache.log4j.ConsoleAppender
log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
log4j.appender.stdout.layout.ConversionPattern=%n%-d{yyyy-MM-dd HH:mm:ss}%n[%p]-[Thread: %t]-[%C.%M()]: %m%n
</code></pre><p>test.java代码(测试一下)</p>
<pre><code>package org.jay.test;

import java.io.IOException;
import java.io.InputStream;
import java.util.List;

import org.apache.ibatis.io.Resources;
import org.apache.ibatis.session.SqlSession;
import org.apache.ibatis.session.SqlSessionFactory;
import org.apache.ibatis.session.SqlSessionFactoryBuilder;
import org.jay.pojo.User;
import org.junit.Before;
import org.junit.Test;

public class test {

    private SqlSessionFactory sessionFactory;

    @Before
    public void init() throws IOException {
        String resources = &quot;SqlMapConfig.xml&quot;;
        // 加载
        InputStream inputStream = Resources.getResourceAsStream(resources);

        // 获取工厂
        sessionFactory = new SqlSessionFactoryBuilder()
                .build(inputStream);
    }

    @Test
    public void testSelect() {
        try {
            SqlSession sqlSession = sessionFactory.openSession();

            User user = sqlSession.selectOne(&quot;test.selectUser&quot;, 1);
            System.out.println(user);

            List&lt;User&gt; userList = sqlSession.selectList(
                    &quot;test.selectUserByName&quot;, &quot;aa&quot;);
            System.out.println(userList);

            sqlSession.close();
        } catch (Exception e) {
            e.printStackTrace();
        }

    }

    @Test
    public void testInsert() {
        try {
            SqlSession sqlSession = sessionFactory.openSession();

            User intoUser = new User();
            intoUser.setUser_name(&quot;aabb&quot;);
            intoUser.setPass_word(&quot;123456&quot;);
            sqlSession.insert(&quot;test.insertUser&quot;, intoUser);

            sqlSession.commit();

            List&lt;User&gt; userList = sqlSession.selectList(
                    &quot;test.selectUserByName&quot;, &quot;aa&quot;);
            System.out.println(userList);

            sqlSession.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testDelete() {
        try {
            SqlSession sqlSession = sessionFactory.openSession();

            sqlSession.delete(&quot;test.deleteUser&quot;, 3);

            sqlSession.commit();

            List&lt;User&gt; userList = sqlSession.selectList(
                    &quot;test.selectUserByName&quot;, &quot;aa&quot;);
            System.out.println(userList);

            sqlSession.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }

    @Test
    public void testUpdate() {
        try {
            SqlSession sqlSession = sessionFactory.openSession();

            User user = new User();
            user.setId(3);
            user.setUser_name(&quot;aaayyy&quot;);
            user.setPass_word(&quot;123456&quot;);
            sqlSession.update(&quot;test.updateUser&quot;, user);

            sqlSession.commit();

            List&lt;User&gt; userList = sqlSession.selectList(
                    &quot;test.selectUserByName&quot;, &quot;aa&quot;);
            System.out.println(userList);

            sqlSession.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
</code></pre><p>建表语句</p>
<pre><code>create table t_user(  
id int(4) not null primary key auto_increment,
user_name char(20) not null, 
pass_word char(20) not null
);
</code></pre>
            
            <p class="more">
                <a href="/2015/09/07/2019030500061/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/07/2019030500061/" title="mybatis入门小程序">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/7.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/07/2019030500086/">
    		mysql 常见错误解决方式
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-07T04:48:47.000Z">2015-09-07</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/mysql-1449/" title="mysql 1449">mysql 1449</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>mysql 1449 ： The user specified as a definer (‘root‘@’%’) does not exist 分析: 一般是由于root用户对全局host无访问权限。因此只要给root用户添加一个访问权限即可。 解决方式: <strong>grant all privileges on <em>.</em> to root@”%” identified by “.”;</strong> <strong>flush privileges;</strong> 参考: <a href="http://bbs.csdn.net/topics/390339729" target="_blank" rel="noopener">http://bbs.csdn.net/topics/390339729</a> 扩展: 阿里云数据库访问存储/视图时出现”mysql 1449”错误,解决方式, 1.使用阿里云自带的图形化界面访问数据库. 2.编辑视图/存储过程 3.设置安全性为INVOKER 4.重新保存</p>

            
            <p class="more">
                <a href="/2015/09/07/2019030500086/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/07/2019030500086/" title="mysql 常见错误解决方式">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/7.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/SQL-Server/">SQL Server</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/07/2019030500021/">
    		报表性能优化方案之单数据集分页SQL实现层式报表
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-07T04:36:01.000Z">2015-09-07</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/SQL/" title="SQL">SQL</a> / 
    
        <a href="/tags/FineReport/" title="FineReport">FineReport</a> / 
    
        <a href="/tags/报表/" title="报表">报表</a> / 
    
        <a href="/tags/数据集/" title="数据集">数据集</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p><strong>1、概述</strong></p>
<p>我们知道，行式引擎按页取数只适用于Oracle,mysql,hsql和sqlserver2008及以上数据库，其他数据库，如access，sqlserver2005，sqlite等必须编写分页SQL。</p>
<p>下面以Access数据库为例介绍需要写分页SQL的数据库怎样利用行式的引擎实现层式报表。</p>
<p>解决方案提供工具：报表开发工具FineReport</p>
<p><strong>2、解决思路</strong></p>
<p>对于mysql这类可以直接使用行式的引擎实现层式报表的数据库来说，如果勾选了行式引擎，程序会自动生成分页sql，如，我新建了一个数据集ds1，来源于mysql数据库，基本sql语句为：</p>
<p><strong>SELECT * FROM 订单明细</strong></p>
<p>如果不定义分页sql，勾选行式引擎选项，预览报表时，程序会将上面的sql语句转化为下面的语句来取一页的数据：</p>
<p><strong>SELECT COUNT(<em>)AS totalRowCount FROM (SELECT </em> FROM 订单明细) t</strong></p>
<p>如果数据库是上面所说的access一类的无法直接生成分页sql的数据库，那么就需要编写分页SQL。</p>
<p><strong>3、操作步骤</strong></p>
<p>以FRDemo内置的sqlite为例，说明sqlite如何写分页查询。</p>
<p>注：sqlserver2005和sqlite操作步骤一样。</p>
<p><strong>3.1新建数据集</strong></p>
<p>新建数据集ds1：<strong>SELECT * FROM 订单明细</strong>。</p>
<p><strong>3.2添加分页查询SQL语句</strong></p>
<p>在数据查询面板中点击<strong>分页查询</strong>按钮，编辑分页SQL语句，如下图：</p>
<p><img src="http://img.blog.csdn.net/20150907100054679" alt></p>
<p>完整的sql语句如下：</p>
<p><strong>[sql]</strong></p>
<ol>
<li>SELECT *</li>
<li>FROM (</li>
<li>SELECT  *</li>
<li>FROM(</li>
<li>SELECT *</li>
<li>FROM 订单明细 ORDER BY 订单ID ASC limit ${fr_pagesize*fr_pagenumber}</li>
<li>) AS e1 ORDER BY 订单ID DESC limit ${</li>
<li>if(fr_pagenumber == int((((fr_rowcount-1)/fr_pagesize)+1)),fr_rowcount - (fr_pagesize*(fr_pagenumber-1)),fr_pagesize)</li>
<li>}</li>
<li>) AS e2 ORDER BY 订单ID ASC</li>
</ol>
<p>注：上述代码放置在分页sql面板中时，要删除后面的注释语句，并且语句中的三次ORDER BY 一定不能丢。</p>
<p>·        <strong>分页sql语句注释</strong></p>
<p><strong>${if(fr_pagenumber==int( (((fr_rowcount-1)/fr_pagesize)+1)),fr_rowcount -(fr_pagesize*(fr_pagenumber-1)),fr_pagesize)}</strong>意思是：</p>
<p>假如是最后一页的话，就取最后一页剩余的行数，假如不是最后一页就取每页需要显示的行数，示例中每页需要显示的行数为30行。</p>
<p><strong>fr_pagenumber</strong>：当前浏览的页数，如果预览第2页，则fr_pagenumber=2；</p>
<p><strong>fr_rowcount</strong>：当前数据集的总数据条数；</p>
<p><strong>fr_pagesize</strong>：表示设置行式引擎时，每页需显示的行数，该示例中fr_pagesize=30.</p>
<p>在预览时，设定的分页查询根据3个变量的值，会生成数据库查询，如fr_pagenumber=2，fr_pagesize=30时，即在web端预览报表，预览至第2页时，上面的sql语句会转化为：</p>
<p><strong>SELECT <em> FROM (SELECT </em> FROM ( SELECT * FROM 订单明细 ORDER BY 订单ID ASC limit 60 )AS e1 ORDER BY 订单ID DESClimit30 ) AS e2 ORDER BY 订单ID ASC</strong></p>
<p>预览至第3页时，fr_pagenumber=3，sql语句就转化为：</p>
<p><strong>SELECT <em> FROM (SELECT </em> FROM ( SELECT * FROM 订单明细 ORDER BY 订单ID ASC limit 90 )AS e1 ORDER BY 订单ID DESClimit30) AS e2 ORDER BY 订单ID ASC</strong></p>
<p>预览至最后一页时，所剩下的数据可能不足30行，那么sql语句又会转化成什么样呢？</p>
<p>如果fr_rowcount=100，fr_pagesize=30，即数据总行数为100行，每页显示30行，预览至最后一页，也就是第4页时，fr_pagenumber=4，sql语句将转换为：</p>
<p><strong>SELECT <em> FROM (SELECT </em> FROM ( SELECT * FROM 订单明细 ORDER BY 订单ID ASC limit 90)AS e1 ORDER BY 订单ID DESClimit10 ) AS e2 ORDER BY 订单ID ASC</strong></p>
<p><strong>3.3报表主体设计</strong></p>
<p>将数据集中的数据列拖曳至单元格中。</p>
<p><strong>3.4行式引擎设置</strong></p>
<p>同上一节的设置方法，这里不再赘述。</p>
<p><strong>3.5效果查看</strong></p>
<p>点击分页预览，效果图如下：</p>
<p>已完成模板请参照：<strong>%FR_HOME%\WebReport\WEB-INF\reportlets\doc\Advanced\PagingSql.cpt</strong></p>
<p><strong>3.6数据库的分页SQL语句</strong></p>
<p><strong>[sql]</strong></p>
<ol>
<li>SELECT *</li>
<li>FROM (</li>
<li>SELECT TOP ${</li>
<li>if(fr_pagenumber == int((((fr_rowcount-1)/fr_pagesize)+1)),fr_rowcount - (fr_pagesize*(fr_pagenumber-1)),fr_pagesize)</li>
<li>} *</li>
<li>FROM(</li>
<li>SELECT TOP ${fr_pagesize*fr_pagenumber} *</li>
<li>FROM 订单明细 ORDER BY 订单ID ASC</li>
<li>) AS e1 ORDER BY 订单ID DESC</li>
<li>) AS e2 ORDER BY 订单ID ASC</li>
</ol>

            
            <p class="more">
                <a href="/2015/09/07/2019030500021/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/07/2019030500021/" title="报表性能优化方案之单数据集分页SQL实现层式报表">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/7.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/06/2019030500025/">
    		打开pl/sql developer出现NLS_LANG和字符集(Character set)问题
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-06T09:29:48.000Z">2015-09-06</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Character-set/" title="Character set">Character set</a> / 
    
        <a href="/tags/NLS-LANG/" title="NLS_LANG">NLS_LANG</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<h1 id="打开pl-sql-developer出现NLS-LANG和字符集-Character-set-问题"><a href="#打开pl-sql-developer出现NLS-LANG和字符集-Character-set-问题" class="headerlink" title="打开pl/sql developer出现NLS_LANG和字符集(Character  set)问题"></a>打开pl/sql developer出现NLS_LANG和字符集(Character  set)问题</h1><pre><code>公司最近培训pl/sql，我安装完毕后打开，遇到如图问题。
</code></pre><p><img src="http://img.blog.csdn.net/20150904093840189?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p>
<pre><code>PS：我的操作系统是英文的。

这是因为系统没有设置NLS_LANG系统变量。有两种方式查看。
</code></pre><p>1. 查看电脑属性。</p>
<p><img src="http://img.blog.csdn.net/20150904094431591?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p>
<p>2. 命令行查看。</p>
<p><img src="http://img.blog.csdn.net/20150904094853527?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p>
<pre><code>PS：这里我已经设置过了，所以仅仅是作个示意。

如果遇到如下图中的问题，说明客户端字符集与Oracle数据库的字符集不同。
</code></pre><p><img src="http://img.blog.csdn.net/20150904104459368?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p>
<pre><code>查看数据库的字符集的方法：
</code></pre><p><img src="http://img.blog.csdn.net/20150904104606224?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt></p>
<pre><code>对方的pl/sql语句是：
</code></pre><p><strong>[sql]</strong></p>
<ol>
<li>Select * from V$NLS_PARAMETERS where PARAMETER=’NLS_CHARACTERSET’;</li>
<li>Select USERENV(‘LANGUAGE’) from DUAL;</li>
</ol>
<p>将NLS_LANG的值改为所查到的SIMPLIFIED CHINESE_CHINA.UTF8即可。</p>
<p>PS：我们简介一下字符集的含义。以SIMPLIFIED CHINESE_CHINA.UTF8为例。</p>
<ul>
<li>SIMPLIFIED CHINESE为语言（简体中文）；</li>
<li>CHINA为国家（中国）；</li>
<li>UTF8为字符编码；</li>
</ul>
</blockquote>

            
            <p class="more">
                <a href="/2015/09/06/2019030500025/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/06/2019030500025/" title="打开pl/sql developer出现NLS_LANG和字符集(Character set)问题">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/6.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/06/2019030500056/">
    		mongodb常用命令
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-06T09:26:01.000Z">2015-09-06</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MongoDB/" title="MongoDB">MongoDB</a> / 
    
        <a href="/tags/ubuntu/" title="ubuntu">ubuntu</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>mongodb由C＋＋写就，其名字来自hu<strong>mongo</strong>us这个单词的中间部分，从名字可见其野心所在就是海量数据的处理。关于它的一个最简洁描述为：scalable, high-performance, open source,  schema-free, document-oriented database。MongoDB的主要目标是在键/值存储方式（提供了高性能和高度伸缩性）以及传统的RDBMS系统（丰富的功能）架起一座桥梁，集两者的优势于一身。   <strong>安装及使用：</strong> 首先在Ubuntu上安装MongoDB。 <a href="http://www.mongodb.org/display/DOCS/Downloads" target="_blank" rel="noopener">下载MongoDB</a>, 现在最新的生产版本1.7.0</p>
<ol>
<li>解压文件.</li>
</ol>
<p>$ tar  -xvf mongodb-linux-i686-1.4.3.tgz</p>
<ol start="2">
<li>为MongoDB创建数据目录，默认情况下它将数据存储在/data/db</li>
</ol>
<p>$ sudo mkdir -p  /data/db/</p>
<p>$  sudo chown `id -u` /data/db</p>
<ol start="3">
<li>启动MongoDB服务.</li>
</ol>
<p>$ cd  mongodb-linux-i686-1.4.3/bin</p>
<p>$  ./mongod</p>
<ol start="4">
<li>打开另一个终端，并确保你在MongoDB的bin目录，输入如下命令.</li>
</ol>
<p>$  ./mongo</p>
<h3 id="一些概念"><a href="#一些概念" class="headerlink" title="一些概念"></a><strong>一些概念</strong></h3><p>一个mongod服务可以有建立多个数据库，每个数据库可以有多张表，这里的表名叫collection，每个collection可以存放多个文档（document），每个文档都以BSON（binary  json）的形式存放于硬盘中，因此可以存储比较复杂的数据类型。它是以单文档为单位存储的，你可以任意给一个或一批文档新增或删除字段，而不会对其它文档造成影响，这就是所谓的schema-free，这也是文档型数据库最主要的优点。跟一般的key-value数据库不一样的是，它的value中存储了结构信息，所以你又可以像关系型数据库那样对某些域进行读写、统计等操作。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引。Mongo还可以解决海量数据的查询效率，根据官方文档，当数据量达到50GB以上数据时，Mongo数据库访问速度是MySQL10  倍以上。</p>
<p><strong>BSON</strong> BSON是Binary JSON  的简称，是一个JSON文档对象的二进制编码格式。BSON同JSON一样支持往其它文档对象和数组中再插入文档对象和数组，同时扩展了JSON的数据类型。如：BSON有Date类型和BinDate类型。 BSON被比作二进制的交换格式，如同Protocol  Buffers，但BSON比它更“schema-less”，非常好的灵活性但空间占用稍微大一点。 BSON有以下三个特点： 1．   轻量级 2．   跨平台 3．   效率高 <strong>命名空间</strong> MongoDB存储BSON对象到collections,这一系列的数据库名和collection名被称为一个命名空间。如同：java.util.List;用来管理数据库中的数据。</p>
<h3 id="索引"><a href="#索引" class="headerlink" title="索引"></a><strong>索引</strong></h3><p>mongodb可以对某个字段建立索引，可以建立组合索引、唯一索引，也可以删除索引，建立索引就意味着增加空间开销。默认情况下每个表都会有一个唯一索引：_id，如果插入数据时没有指定_id，服务会自动生成一个_id，为了充分利用已有索引，减少空间开销，最好是自己指定一个unique的key为_id，通常用对象的ID比较合适，比如商品的ID。 <strong>shell操作数据库：</strong>   1.   超级用户相关： 1. #进入数据库admin use admin 2. #增加或修改用户密码 db.addUser(‘name’,’pwd’) 3. #查看用户列表 db.system.users.find() 4. #用户认证 db.auth(‘name’,’pwd’) 5. #删除用户 db.removeUser(‘name’) 6.  #查看所有用户 show users 7. #查看所有数据库 show dbs 8. #查看所有的collection show collections 9. #查看各collection的状态 db.printCollectionStats() 10. #查看主从复制状态 db.printReplicationInfo() 11. #修复数据库 db.repairDatabase() 12. #设置记录profiling，0=off 1=slow 2=all db.setProfilingLevel(1) 13. #查看profiling show profile 14. #拷贝数据库 db.copyDatabase(‘mail_addr’,’mail_addr_tmp’) 15. #删除collection db.mail_addr.drop() 16. #删除当前的数据库 db.dropDatabase()   2. 增删改 1.  #存储嵌套的对象 db.foo.save({‘name’:’ysz’,’address’:{‘city’:’beijing’,’post’:100096},’phone’:[138,139]})   2. #存储数组对象 db.user_addr.save({‘Uid’:<a href="mailto:&#39;yushunzhi@sohu.com">&#39;yushunzhi@sohu.com</a>‘,’Al’:[<a href="mailto:&#39;test-1@sohu.com">&#39;test-1@sohu.com</a>‘,<a href="mailto:&#39;test-2@sohu.com">&#39;test-2@sohu.com</a>‘]})   3. #根据query条件修改，如果不存在则插入，允许修改多条记录 db.foo.update({‘yy’:5},{‘$set’:{‘xx’:2}},upsert=true,multi=true) 4. #删除yy=5的记录 db.foo.remove({‘yy’:5}) 5. #删除所有的记录 db.foo.remove()   3. 索引 1. #增加索引：1(ascending),-1(descending) 2. db.foo.ensureIndex({firstname: 1, lastname:  1}, {unique: true}); 3. #索引子对象 4. db.user_addr.ensureIndex({‘Al.Em’:  1}) 5. #查看索引信息 6. db.foo.getIndexes() 7. db.foo.getIndexKeys() 8. #根据索引名删除索引 9. db.user_addr.dropIndex(‘Al.Em_1’)   4. 查询 1. #查找所有 2. db.foo.find() 3. #查找一条记录 4. db.foo.findOne() 5. #根据条件检索10条记录 6. db.foo.find({‘msg’:’Hello 1’}).limit(10) 7. #sort排序 8.  db.deliver_status.find({‘From’:<a href="mailto:&#39;ixigua@sina.com">&#39;ixigua@sina.com</a>‘}).sort({‘Dt’,-1}) 9.  db.deliver_status.find().sort({‘Ct’:-1}).limit(1) 10. #count操作 11. db.user_addr.count() 12. #distinct操作,查询指定列，去重复 13. db.foo.distinct(‘msg’) 14. #”&gt;=”操作 15. db.foo.find({“timestamp”: {“$gte” : 2}}) 16. #子对象的查找 17. db.foo.find({‘address.city’:’beijing’}) 5. 管理 1. #查看collection数据的大小 2. db.deliver_status.dataSize() 3. #查看colleciont状态 4. db.deliver_status.stats() 5. #查询所有索引的大小 6.  db.deliver_status.totalIndexSize()   5.  advanced queries:高级查询 条件操作符 $gt  : &gt; $lt : &lt; $gte: &gt;= $lte: &lt;= $ne :  !=、&lt;&gt; $in  : in $nin: not in $all: all $not: 反匹配(1.3.3及以上版本) 查询 name &lt;&gt; “bruce” and age &gt;= 18 的数据 db.users.find({name:  {$ne: “bruce”}, age: {$gte: 18}}); 查询 creation_date &gt; ‘2010-01-01’ and creation_date &lt;= ‘2010-12-31’  的数据 db.users.find({creation_date:{$gt:new  Date(2010,0,1), $lte:new Date(2010,11,31)}); 查询 age in (20,22,24,26) 的数据 db.users.find({age:  {$in: [20,22,24,26]}}); 查询 age取模10等于0  的数据 db.users.find(‘this.age  % 10 == 0’); 或者 db.users.find({age  : {$mod : [10, 0]}}); 匹配所有 db.users.find({favorite_number  : {$all : [6, 8]}}); 可以查询出{name:  ‘David’, age: 26, favorite_number: [ 6, 8, 9 ]  } 可以不查询出{name:  ‘David’, age: 26, favorite_number: [ 6, 7, 9 ]  } 查询不匹配name=B<em>带头的记录 db.users.find({name:  {$not: /^B.</em>/}}); 查询 age取模10不等于0  的数据 db.users.find({age  : {$not: {$mod : [10, 0]}}}); #返回部分字段 选择返回age和_id字段(_id字段总是会被返回) db.users.find({},  {age:1}); db.users.find({}, {age:3}); db.users.find({},  {age:true}); db.users.find({ name : “bruce” },  {age:1}); 0为false,  非0为true 选择返回age、address和_id字段 db.users.find({  name : “bruce” }, {age:1, address:1}); 排除返回age、address和_id字段 db.users.find({},  {age:0, address:false}); db.users.find({ name : “bruce” }, {age:0,  address:false}); 数组元素个数判断 对于{name:  ‘David’, age: 26, favorite_number: [ 6, 7, 9 ] }记录 匹配db.users.find({favorite_number:  {$size: 3}}); 不匹配db.users.find({favorite_number:  {$size: 2}}); $exists判断字段是否存在 查询所有存在name字段的记录 db.users.find({name:  {$exists: true}}); 查询所有不存在phone字段的记录 db.users.find({phone:  {$exists: false}}); $type判断字段类型 查询所有name字段是字符类型的 db.users.find({name:  {$type: 2}}); 查询所有age字段是整型的 db.users.find({age:  {$type: 16}}); 对于字符字段，可以使用正则表达式 查询以字母b或者B带头的所有记录 db.users.find({name:  /^b.<em>/i}); $elemMatch(1.3.1及以上版本) 为数组的字段中匹配其中某个元素 Javascript查询和$where查询 查询 age &gt; 18 的记录，以下查询都一样 db.users.find({age:  {$gt: 18}}); db.users.find({$where: “this.age &gt;  18”}); db.users.find(“this.age &gt; 18”); f = function() {return  this.age &gt; 18} db.users.find(f); 排序sort() 以年龄升序asc db.users.find().sort({age:  1}); 以年龄降序desc db.users.find().sort({age:  -1}); 限制返回记录数量limit() 返回5条记录 db.users.find().limit(5); 返回3条记录并打印信息 db.users.find().limit(3).forEach(function(user)  {print(‘my age is ‘ + user.age)}); 结果 my  age is 18 my age is 19 my age is  20 限制返回记录的开始点skip() 从第3条记录开始，返回5条记录(limit  3,  5) db.users.find().skip(3).limit(5); 查询记录条数count() db.users.find().count(); db.users.find({age:18}).count(); 以下返回的不是5，而是user表中所有的记录数量 db.users.find().skip(10).limit(5).count(); 如果要返回限制之后的记录数量，要使用count(true)或者count(非0) db.users.find().skip(10).limit(5).count(true); 分组group() 假设test表只有以下一条数据 {  domain: “<a href="http://www.mongodb.org&quot;" target="_blank" rel="noopener">www.mongodb.org&quot;</a> , invoked_at: {d:”2009-11-03”, t:”17:14:05”} ,  response_time: 0.05 , http_action: “GET  /display/DOCS/Aggregation” } 使用group统计test表11月份的数据count:count(</em>)、total_time:sum(response_time)、avg_time:total_time/count; db.test.group( {  cond: {“invoked_at.d”: {$gt: “2009-11”, $lt: “2009-12”}} , key:  {http_action: true} , initial: {count: 0, total_time:0} , reduce:  function(doc, out){ out.count++; out.total_time+=doc.response_time } ,  finalize: function(out){ out.avg_time = out.total_time / out.count } }  ); [ { “http_action” : “GET  /display/DOCS/Aggregation”, “count” : 1, “total_time” :  0.05, “avg_time” : 0.05 } ] </p>
<p><strong>Java  应用示例</strong></p>
<p>要使用Java操作MongoDB的话，要到官方网站下载一个驱动包，把包导入后，可以尝试来操作了（记得一定要开着服务器）</p>
<p>首先介绍一下比较常用的几个类</p>
<p><strong>Mongo</strong>：连接服务器，执行一些数据库操作的选项，如新建立一个数据库等</p>
<p><strong>DB</strong>：对应一个数据库，可以用来建立集合等操作</p>
<p><strong>DBCollection</strong>：对应一个集合（类似表），可能是我们用得最多的，可以添加删除记录等</p>
<p><strong>DBObjec</strong>：接口和BasicDBObject对象：表示一个具体的记录，BasicDBObject实现了DBObject，因为是key-value的数据结构，所以用起来其实和HashMap是基本一致的</p>
<p><strong>DBCursor</strong>：用来遍历取得的数据，实现了Iterable和Iterator</p>
<p>接下来实际的操作一下，代码如下：</p>
<ol>
<li><p>import java.net.UnknownHostException;</p>
</li>
<li><p>import java.util.List;</p>
</li>
<li><p>import java.util.Set;</p>
</li>
<li><p>import com.mongodb.BasicDBObject;</p>
</li>
<li><p>import com.mongodb.DB;</p>
</li>
<li><p>import com.mongodb.DBCollection;</p>
</li>
<li><p>import com.mongodb.DBCursor;</p>
</li>
<li><p>import com.mongodb.DBObject;</p>
</li>
<li><p>import com.mongodb.Mongo;</p>
</li>
<li><p>import com.mongodb.MongoException;</p>
</li>
<li><p>public class MongoDbTest {</p>
</li>
<li><p>public static void main(String[] args)  throws UnknownHostException, MongoException {</p>
</li>
<li><p>//Mongo m = new  Mongo(); </p>
</li>
<li><p>//Mongo m = new Mongo(“localhost”); </p>
</li>
<li><p>//获得数据库服务</p>
</li>
<li><p>Mongo m = new Mongo(“localhost”, 27017);</p>
</li>
<li><p>//得到数据库mytest</p>
</li>
<li><p>DB db = m.getDB(“mytest”);</p>
</li>
<li><p>//得到mytest数据库下所有表名</p>
</li>
<li><p>Set<string> colls =  db.getCollectionNames();</string></p>
</li>
<li><p>for (String s : colls) {</p>
</li>
<li><p>System.out.println(s);</p>
</li>
<li><p>}</p>
</li>
<li><p>//得到testCollection表</p>
</li>
<li><p>DBCollection coll = db.getCollection(“testCollection”);</p>
</li>
<li><p>//new 一个BasicDBObject对象doc</p>
</li>
<li><p>BasicDBObject doc = new BasicDBObject();</p>
</li>
<li><p>//赋值</p>
</li>
<li><p>doc.put(“name”, “MongoDB”);</p>
</li>
<li><p>doc.put(“type”, “database”);</p>
</li>
<li><p>doc.put(“count”, 1);</p>
</li>
<li><p>//又new  一个BasicDBObject对象info</p>
</li>
<li><p>BasicDBObject info = new BasicDBObject();</p>
</li>
<li><p>info.put(“x”, 203);</p>
</li>
<li><p>info.put(“y”, 102);</p>
</li>
<li><p>//把info放入doc</p>
</li>
<li><p>doc.put(“info”, info);</p>
</li>
<li><p>//向testCollection表中插入一条数据</p>
</li>
<li><p>coll.insert(doc);</p>
</li>
<li><p>//查询一条数据</p>
</li>
<li><p>DBObject myDoc = coll.findOne();</p>
</li>
<li><p>System.out.println(myDoc);</p>
</li>
<li><p>//循环插入100条数据到testCollection</p>
</li>
<li><p>for (int i=0; i &lt; 100; i++)  {</p>
</li>
<li><p>coll.insert(new BasicDBObject().append(“i”,  i));</p>
</li>
<li><p>}</p>
</li>
<li><p>//Counting Documents in  A Collection </p>
</li>
<li><p>System.out.println(coll.getCount());</p>
</li>
<li><p>//Using a Cursor to Get  All the Documents </p>
</li>
<li><p>DBCursor cur = coll.find();</p>
</li>
<li><p>while(cur.hasNext()) {</p>
</li>
<li>}</li>
</ol>

            
            <p class="more">
                <a href="/2015/09/06/2019030500056/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/06/2019030500056/" title="mongodb常用命令">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/6.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/SQL-Server/">SQL Server</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/01/2019030500162/">
    		SQL Server 2012 未将对象引用设置到对象的实例。
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-01T07:54:53.000Z">2015-09-01</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/SQL-Server/" title="SQL Server">SQL Server</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p>1、错误描述 <img src="http://img.blog.csdn.net/20150831214339516?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> <img src="http://img.blog.csdn.net/20150831214354172?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> 2、错误原因 创建了student数据库后，使用数据库时出现语法错误 use student; 3、解决办法 （1）重装SQL Server 2012</p>
</blockquote>

            
            <p class="more">
                <a href="/2015/09/01/2019030500162/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/01/2019030500162/" title="SQL Server 2012 未将对象引用设置到对象的实例。">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <a class="extend prev" rel="prev" href="/archives/page/9/">前一页</a><a class="page-number" href="/archives/">1</a><span class="space">&hellip;</span><a class="page-number" href="/archives/page/8/">8</a><a class="page-number" href="/archives/page/9/">9</a><span class="page-number current">10</span><a class="page-number" href="/archives/page/11/">11</a><a class="page-number" href="/archives/page/12/">12</a><span class="space">&hellip;</span><a class="page-number" href="/archives/page/18/">18</a><a class="extend next" rel="next" href="/archives/page/11/">后一页</a>
    </nav>
    


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/MySQL/">MySQL</a>
        <span class="badge">(92)</span>
    </li>
    
    <li>
        <a href="/categories/Oracle/">Oracle</a>
        <span class="badge">(40)</span>
    </li>
    
    <li>
        <a href="/categories/开发语言/">开发语言</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/">NOSQL</a>
        <span class="badge">(17)</span>
    </li>
    
    <li>
        <a href="/categories/其他数据库/">其他数据库</a>
        <span class="badge">(4)</span>
    </li>
    
    <li>
        <a href="/categories/SQL-Server/">SQL Server</a>
        <span class="badge">(13)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/">Oracle</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/SQL-Server/">SQL Server</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/开发语言/">开发语言</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/MySQL/" title="MySQL">MySQL (71)</a>
  
    <a class="tag-item" href="/tags/位运算/" title="位运算">位运算 (0)</a>
  
    <a class="tag-item" href="/tags/sqlplus/" title="sqlplus">sqlplus (1)</a>
  
    <a class="tag-item" href="/tags/allow/" title="allow">allow (1)</a>
  
    <a class="tag-item" href="/tags/Apache/" title="Apache">Apache (1)</a>
  
    <a class="tag-item" href="/tags/deny/" title="deny">deny (1)</a>
  
    <a class="tag-item" href="/tags/CentOS/" title="CentOS">CentOS (2)</a>
  
    <a class="tag-item" href="/tags/druid/" title="druid">druid (1)</a>
  
    <a class="tag-item" href="/tags/心跳/" title="心跳">心跳 (1)</a>
  
    <a class="tag-item" href="/tags/事务/" title="事务">事务 (5)</a>
  
    <a class="tag-item" href="/tags/分布式/" title="分布式">分布式 (1)</a>
  
    <a class="tag-item" href="/tags/消息/" title="消息">消息 (1)</a>
  
    <a class="tag-item" href="/tags/redis/" title="redis">redis (6)</a>
  
    <a class="tag-item" href="/tags/KeepAlived/" title="KeepAlived">KeepAlived (1)</a>
  
    <a class="tag-item" href="/tags/Oracle/" title="Oracle">Oracle (30)</a>
  
    <a class="tag-item" href="/tags/schedule-job/" title="schedule job">schedule job (1)</a>
  
    <a class="tag-item" href="/tags/分库/" title="分库">分库 (1)</a>
  
    <a class="tag-item" href="/tags/分库分表/" title="分库分表">分库分表 (1)</a>
  
    <a class="tag-item" href="/tags/分表/" title="分表">分表 (1)</a>
  
    <a class="tag-item" href="/tags/SQL/" title="SQL">SQL (17)</a>
  
    <a class="tag-item" href="/tags/批量/" title="批量">批量 (1)</a>
  
    <a class="tag-item" href="/tags/数据库/" title="数据库">数据库 (7)</a>
  
    <a class="tag-item" href="/tags/结构同步/" title="结构同步">结构同步 (1)</a>
  
    <a class="tag-item" href="/tags/truncate/" title="truncate">truncate (1)</a>
  
    <a class="tag-item" href="/tags/Excel/" title="Excel">Excel (1)</a>
  
    <a class="tag-item" href="/tags/Sqlite/" title="Sqlite">Sqlite (1)</a>
  
    <a class="tag-item" href="/tags/Hash索引/" title="Hash索引">Hash索引 (1)</a>
  
    <a class="tag-item" href="/tags/InnoDB/" title="InnoDB">InnoDB (3)</a>
  
    <a class="tag-item" href="/tags/MyISAM/" title="MyISAM">MyISAM (3)</a>
  
    <a class="tag-item" href="/tags/索引优化/" title="索引优化">索引优化 (1)</a>
  
    <a class="tag-item" href="/tags/Linux/" title="Linux">Linux (2)</a>
  
    <a class="tag-item" href="/tags/FineReport/" title="FineReport">FineReport (1)</a>
  
    <a class="tag-item" href="/tags/报表/" title="报表">报表 (1)</a>
  
    <a class="tag-item" href="/tags/数据集/" title="数据集">数据集 (1)</a>
  
    <a class="tag-item" href="/tags/rowid/" title="rowid">rowid (2)</a>
  
    <a class="tag-item" href="/tags/重复/" title="重复">重复 (1)</a>
  
    <a class="tag-item" href="/tags/Character-set/" title="Character set">Character set (1)</a>
  
    <a class="tag-item" href="/tags/NLS-LANG/" title="NLS_LANG">NLS_LANG (1)</a>
  
    <a class="tag-item" href="/tags/mysqldump/" title="mysqldump">mysqldump (2)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="http://www.devba.com" target="_blank" title="软件开发吧">软件开发吧</a>
        </li>
    
        <li>
            <a href="https://www.sqlyun.cn" target="_blank" title="SQL云笔记">SQL云</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>