<!doctype html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8">
    <meta name="baidu-site-verification" content="dIcXMeY8Ya">
    
    <title>文章归档: 2015/7 | 软件开发吧</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="keywords" content="SQL云,SQL云开发,SQL笔记,SQL开发,云开发,MySQL,Oralce,数据库,数据库云,数据库开发,数据库云开发,SQL教程,数据库教程,开发笔记,MySQL笔记,MySQL教程">
    <meta name="description" content="为满足广大程序猿兄弟对日常工作中学习数据库、使用使用数据库资料查询需求，SQL云开发免费将自己整理的各种数据库技术资料分享出来，并希望与广大猿兄一起讨论学习与进步,致力于一起更方便、快捷资料学习查询,实现更安全、高效的数据存储.">

    
    <link rel="alternative" href="/atom.xml" title="软件开发吧" type="application/atom+xml">
    
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
</html>
<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">软件开发吧</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/archives/2015/07/page/2/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/archives/2015/07/page/2/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/archives/2015/07/page/2/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/archives/2015/07/page/2/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/cdneitui" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.github.com/" target="_blank">Hosted by GitHub Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon">
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 文章归档 -->

    <h3 class="widget-hd">
        <strong>
            
                文章归档
                <!-- 文章归档，可以根据日期分类 -->
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/02/2019030500127/">
    		Oracle中Hint深入理解
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-02T09:05:01.000Z">2015-07-02</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a> / 
    
        <a href="/tags/Hint/" title="Hint">Hint</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p><strong>Hint概述</strong> 基于代价的优化器是很聪明的，在绝大多数情况下它会选择正确的优化器，减轻了DBA的负担。但有时它也聪明反被聪明误，选择了很差的执行计划，使某个语句的执行变得奇慢无比。 此时就需要DBA进行人为的干预，告诉优化器使用我们指定的存取路径或连接类型生成执行计划，从 而使语句高效的运行。例如，如果我们认为对于一个特定的语句，执行全表扫描要比执行索引扫描更有效，则我们就可以指示优化器使用全表扫描。在Oracle 中，是通过为语句添加 Hints(提示)来实现干预优化器优化的目的。 不建议在代码中使用hint，在代码使用hint使得CBO无法根据实际的数据状态选择正确的执行计划。毕竟 数据是不断变化的， 10g以后的CBO也越来越完善，大多数情况下我们该让Oracle自行决定采用什么执行计划。 Oracle Hints是一种机制，用来告诉优化器按照我们的告诉它的方式生成执行计划。我们可以用Oracle Hints来实现： 1) 使用的优化器的类型 2) 基于代价的优化器的优化目标，是all_rows还是first_rows。 3) 表的访问路径，是全表扫描，还是索引扫描，还是直接利用rowid。 4) 表之间的连接类型 5) 表之间的连接顺序 6) 语句的并行程度 除了”RULE”提示外，一旦使用的别的提示，语句就会自动的改为使用CBO优化器，此时如果你的数据字典中没有统计数据，就会使用缺省的统计数据。所以建议大家如果使用CBO或Hints提示，则最好对表和索引进行定期的分析。 如何使用Hints: Hints只应用在它们所在sql语句块(statement block，由select、update、delete关键字标识)上，对其它SQL语句或语句的其它部分没有影响。如：对于使用union操作的2个sql语句，如果只在一个sql语句上有Hints，则该Hints不会影响另一个sql语句。 我们可以使用注释(comment)来为一个语句添加Hints，一个语句块只能有一个注释，而且注释只能放在SELECT, UPDATE, or DELETE关键字的后面 使用Oracle Hints的语法： {DELETE|INSERT|SELECT|UPDATE} /<em>+ hint [text] [hint[text]]… </em>/ or {DELETE|INSERT|SELECT|UPDATE} –+ hint [text] [hint[text]]… 注解： 1) DELETE、INSERT、SELECT和UPDATE是标识一个语句块开始的关键字，包含提示的注释只能出现在这些关键字的后面，否则提示无效。 2) “+”号表示该注释是一个Hints，该加号必须立即跟在”/<em>”的后面，中间不能有空格。 3) hint是下面介绍的具体提示之一，如果包含多个提示，则每个提示之间需要用一个或多个空格隔开。 4) text 是其它说明hint的注释性文本 5)使用表别名。如果在查询中指定了表别名，那么提示必须也使用表别名。例如：select /</em>+ index(e,dept_idx) <em>/ </em> from emp e; 6)不要在提示中使用模式名称：如果在提示中指定了模式的所有者，那么提示将被忽略。例如： select /<em>+ index(scott.emp,dept_idx) </em>/ <em> from emp 注意：如果你没有正确的指定Hints，Oracle将忽略该Hints，并且不会给出任何错误。 <strong>hint被忽略</strong> 如果CBO认为使用hint会导致错误的结果时，hint将被忽略，详见下例 SQL&gt; select /</em>+ index(t t_ind) <em>/ count(</em>) from t; Execution Plan ———————————————————- Plan hash value: 2966233522 ——————————————————————- | Id  | Operation          | Name | Rows  | Cost (%CPU)| Time     | ——————————————————————- |   0 | SELECT STATEMENT   |      |     1 |    57   (2)| 00:00:01 | |   1 |  SORT AGGREGATE    |      |     1 |            |          | |   2 |   TABLE ACCESS FULL| T    | 50366 |    57   (2)| 00:00:01 | ——————————————————————- 因为我们是对记录求总数，且我们并没有在建立索引时指定不能为空，索引如果CBO选择在索引上进行count时，但索引字段上的值为空时，结果将不准确，故CBO没有选择索引。 SQL&gt;  select /<em>+ index(t t_ind) </em>/ count(id) from t; Execution Plan ———————————————————- Plan hash value: 646498162 ————————————————————————– | Id  | Operation        | Name  | Rows  | Bytes | Cost (%CPU)| Time     | ————————————————————————– |   0 | SELECT STATEMENT |       |     1 |     5 |   285   (1)| 00:00:04 | |   1 |  SORT AGGREGATE  |       |     1 |     5 |            |          | |   2 |   INDEX FULL SCAN| T_IND | 50366 |   245K|   285   (1)| 00:00:04 | ————————————————————————– 因为我们只对id进行count，这个动作相当于count索引上的所有id值，这个操作和对表上的id字段进行count是一样的(组函数会忽略null值) <strong>Hint的具体用法</strong> <strong>和优化器相关的hint</strong> 1、/<em>+ ALL_ROWS </em>/ 表明对语句块选择基于开销的优化方法,并获得最佳吞吐量,使资源消耗最小化. SELECT /<em>+ ALL+_ROWS</em>/ EMP_NO,EMP_NAM,DAT_IN FROM BSEMPMS WHERE EMP_NO=’SCOTT’; 2、/<em>+ FIRST_ROWS(n) </em>/ 表明对语句块选择基于开销的优化方法,并获得最佳响应时间,使资源消耗最小化. SELECT /<em>+FIRST_ROWS(20) </em>/ EMP_NO,EMP_NAM,DAT_IN FROM BSEMPMS WHERE EMP_NO=’SCOTT’; 3、/<em>+ RULE</em>/ 表明对语句块选择基于规则的优化方法. SELECT /<em>+ RULE </em>/ EMP_NO,EMP_NAM,DAT_IN FROM BSEMPMS WHERE EMP_NO=’SCOTT’; <strong>和访问路径相关的hint</strong> 1、/<em>+ FULL(TABLE)</em>/ 表明对表选择全局扫描的方法. SELECT /<em>+FULL(A)</em>/ EMP_NO,EMP_NAM FROM BSEMPMS A WHERE EMP_NO=’SCOTT’; 2、/<em>+ INDEX(TABLE INDEX_NAME) </em>/ 表明对表选择索引的扫描方法. SELECT /<em>+INDEX(BSEMPMS SEX_INDEX) </em>/ <em> FROM BSEMPMS WHERE SEX=’M’; 5、/</em>+ INDEX_ASC(TABLE INDEX_NAME)<em>/ 表明对表选择索引升序的扫描方法. SELECT /</em>+INDEX_ASC(BSEMPMS PK_BSEMPMS) <em>/ </em> FROM BSEMPMS WHERE DPT_NO=’SCOTT’; 6、/<em>+ INDEX_COMBINE</em>/ 为指定表选择位图访问路经,如果INDEX_COMBINE中没有提供作为参数的索引,将选择出位图索引的布尔组合方式. SELECT /<em>+INDEX_COMBINE(BSEMPMS SAL_BMI HIREDATE_BMI) </em>/  <em> FROM BSEMPMS WHERE SAL&lt;5000000 AND HIREDATE 7、/</em>+ INDEX_JOIN(TABLE INDEX_NAME1 INDEX_NAME2) <em>/ 当谓词中引用的列都有索引的时候，可以通过指定采用索引关联的方式，来访问数据 select /</em>+ index_join(t t_ind t_bm) <em>/ id from t where id=100 and object_name=’EMPLOYEES’ 8、/</em>+ INDEX_DESC(TABLE INDEX_NAME)<em>/ 表明对表选择索引降序的扫描方法. SELECT /</em>+INDEX_DESC(BSEMPMS PK_BSEMPMS) <em>/ </em> FROM BSEMPMS WHERE DPT_NO=’SCOTT’; 9、/<em>+ INDEX_FFS(TABLE INDEX_NAME) </em>/ 对指定的表执行快速全索引扫描,而不是全表扫描的办法. SELECT /<em> + INDEX_FFS(BSEMPMS IN_EMPNAM)</em>/ <em> FROM BSEMPMS WHERE DPT_NO=’TEC305’; 10、/</em>+ INDEX_SS(T T_IND) <em>/ 从9i开始，oracle引入了这种索引访问方式。当在一个联合索引中，某些谓词条件并不在联合索引的第一列时，可以通过Index Skip Scan来访问索引获得数据。当联合索引第一列的唯一值个数很少时，使用这种方式比全表扫描效率高。 SQL&gt; create table t as select 1 id,object_name from dba_objects; Table created. SQL&gt; insert into t select 2,object_name from dba_objects; 50366 rows created. SQL&gt; insert into t select 3,object_name from dba_objects; 50366 rows created. SQL&gt; insert into t select 4,object_name from dba_objects; 50366 rows created. SQL&gt; commit; Commit complete. SQL&gt; create index t_ind on t(id,object_name); Index created. SQL&gt; exec dbms_stats.gather_table_stats(‘HR’,’T’,cascade=&gt;true); PL/SQL procedure successfully completed. 执行全表扫描 SQL&gt; select /</em>+ full(t) <em>/ </em> from t where object_name=’EMPLOYEES’; 6 rows selected. Execution Plan ———————————————————- Plan hash value: 1601196873 ————————————————————————– | Id  | Operation         | Name | Rows  | Bytes | Cost (%CPU)| Time     | ————————————————————————– |   0 | SELECT STATEMENT  |      |     5 |   135 |   215   (3)| 00:00:03 | |<em>  1 |  TABLE ACCESS FULL| T    |     5 |   135 |   215   (3)| 00:00:03 | ————————————————————————– Predicate Information (identified by operation id): ————————————————— 1 - filter(“OBJECT_NAME”=’EMPLOYEES’) Statistics ———————————————————- 0  recursive calls 0  db block gets 942  consistent gets 0  physical reads 0  redo size 538  bytes sent via SQL\</em>Net to client 385  bytes received via SQL*Net from client 2  SQL*Net roundtrips to/from client 0  sorts (memory) 0  sorts (disk) 6  rows processed 不采用hint SQL&gt;  select * from t where object_name=’EMPLOYEES’; 6 rows selected. Execution Plan ———————————————————- Plan hash value: 2869677071 ————————————————————————– | Id  | Operation        | Name  | Rows  | Bytes | Cost (%CPU)| Time     | ————————————————————————– |   0 | SELECT STATEMENT |       |     5 |   135 |     5   (0)| 00:00:01 | |<em>  1 |  INDEX SKIP SCAN | T_IND |     5 |   135 |     5   (0)| 00:00:01 | ————————————————————————– Predicate Information (identified by operation id): ————————————————— 1 - access(“OBJECT_NAME”=’EMPLOYEES’) filter(“OBJECT_NAME”=’EMPLOYEES’) Statistics ———————————————————- 1  recursive calls 0  db block gets 17  consistent gets 1  physical reads 0  redo size 538  bytes sent via SQL\</em>Net to client 385  bytes received via SQL*Net from client 2  SQL<em>Net roundtrips to/from client 0  sorts (memory) 0  sorts (disk) 6  rows processed 当全表扫描扫描了942个块，联合索引只扫描了17个数据块。可以看到联合索引的第一个字段的值重复率很高时，即使谓词中没有联合索引的第一个字段，依然会使用index_ss方式，效率远远高于全表扫描效率。但当 第一个字段的值重复率很低时，使用 index_ss的效率要低于 全表扫描，读者可以自行实验 <strong>和表的关联相关的hint</strong> /\</em>+ leading(table_1,table_2) <em>/ 在多表关联查询中，指定哪个表作为驱动表，即告诉优化器首先要访问哪个表上的数据。 select /</em>+ leading(t,t1) <em>/ t.</em> from t,t1 where t.id=t1.id; /<em>+ order </em>/ 让Oracle根据from后面表的顺序来选择驱动表，oracle建议使用leading，他更为灵活 select /<em>+ order </em>/ t.<em> from t,t1 where t.id=t1.id; /</em>+ use_nl(table_1,table_2) <em>/ 在多表关联查询中，指定使用nest loops方式进行多表关联。 select /</em>+ use_nl(t,t1) <em>/ t.</em> from t,t1 where t.id=t1.id; /<em>+ use_hash(table_1,table_2) </em>/ 在多表关联查询中，指定使用hash join方式进行多表关联。 select /<em>+ use_hash(t,t1) </em>/ t.<em> from t,t1 where t.id=t1.id; 在多表关联查询中，指定使用hash join方式进行多表关联，并指定表t为驱动表。 select /</em>+ use_hash(t,t1) leading(t,t1) <em>/ t.</em> from t,t1 where t.id=t1.id; /<em>+ use_merge(table_1,table_2) </em>/ 在多表关联查询中，指定使用merge join方式进行多表关联。 select /<em>+ use_merge(t,t1) </em>/ t.<em> from t,t1 where t.id=t1.id; /</em>+ no_use_nl(table_1,table_2) <em>/ 在多表关联查询中，指定不使用nest loops方式进行多表关联。 select /</em>+ no_use_nl(t,t1) <em>/ t.</em> from t,t1 where t.id=t1.id; /<em>+ no_use_hash(table_1,table_2) </em>/ 在多表关联查询中，指定不使用hash join方式进行多表关联。 select /<em>+ no_use_hash(t,t1) </em>/ t.<em> from t,t1 where t.id=t1.id; /</em>+ no_use_merge(table_1,table_2) <em>/ 在多表关联查询中，指定不使用merge join方式进行多表关联。 select /</em>+ no_use_merge(t,t1) <em>/ t.</em> from t,t1 where t.id=t1.id; <strong>其他常用的hint</strong> /*+ parallel(table_name n) <em>/ 在sql中指定执行的并行度，这个值将会覆盖自身的并行度 select /</em>+ parallel(t 4) <em>/ count(</em>)  from t; /<em>+ no_parallel(table_name) </em>/ 在sql中指定执行的不使用并行 select /<em>+ no_parallel(t) </em>/ count(<em>)  from t; /</em>+ append <em>/以直接加载的方式将数据加载入库 insert into t /</em>+ append <em>/ select </em> from t; /<em>+ dynamic_sampling(table_name n) </em>/ 设置sql执行时动态采用的级别，这个级别为0~10 select /<em>+ dynamic_sampling(t 4) </em>/ <em> from t where id &gt; 1234 /</em>+ cache(table_name) <em>/ 进行全表扫描时将table置于LRU列表的最活跃端，类似于table的cache属性 select /</em>+ full(employees) cache(employees) */ last_name from employees <strong>附录hint表格</strong></p>
<p><strong>Hints for Optimization Approaches and Goals</strong></p>
<p>ALL_ROWS</p>
<p>The ALL_ROWS hint explicitly chooses the cost-based approach to optimize a statement block with a goal of best throughput (that is, minimum total resource consumption).</p>
<p>FIRST_ROWS</p>
<p>The FIRST_ROWS hint explicitly chooses the cost-based approach to optimize a statement block with a goal of best response time (minimum resource usage to return first row). In newer Oracle version you should give a parameter with this hint: FIRST_ROWS(n) means that the optimizer will determine an executionplan to give a fast response for returning the first n rows.</p>
<p>CHOOSE</p>
<p>The CHOOSE hint causes the optimizer to choose between the rule-based approach and the cost-based approach for a SQL statement based on the presence of statistics for the tables accessed by the statement</p>
<p>RULE</p>
<p>The RULE hint explicitly chooses rule-based optimization for a statement block. This hint also causes the optimizer to ignore any other hints specified for the statement block. The RULE hint does not work any more in Oracle 10g.</p>
<p><strong>Hints for Access Paths</strong></p>
<p>FULL</p>
<p>The FULL hint explicitly chooses a full table scan for the specified table. The syntax of the FULL hint is FULL(table) where table specifies the alias of the table (or table name if alias does not exist) on which the full table scan is to be performed.</p>
<p>ROWID</p>
<p>The ROWID hint explicitly chooses a table scan by ROWID for the specified table. The syntax of the ROWID hint is ROWID(table) where table specifies the name or alias of the table on which the table access by ROWID is to be performed. (This hint depricated in Oracle 10g)</p>
<p>CLUSTER</p>
<p>The CLUSTER hint explicitly chooses a cluster scan to access the specified table. The syntax of the CLUSTER hint is CLUSTER(table) where table specifies the name or alias of the table to be accessed by a cluster scan.</p>
<p>HASH</p>
<p>The HASH hint explicitly chooses a hash scan to access the specified table. The syntax of the HASH hint is HASH(table) where table specifies the name or alias of the table to be accessed by a hash scan.</p>
<p>HASH_AJ</p>
<p>The HASH_AJ hint transforms a NOT IN subquery into a hash anti-join to access the specified table. The syntax of the HASH_AJ hint is HASH_AJ(table) where table specifies the name or alias of the table to be accessed.(depricated in Oracle 10g)</p>
<p>INDEX</p>
<p>The INDEX hint explicitly chooses an index scan for the specified table. The syntax of the INDEX hint is INDEX(table index) where:table specifies the name or alias of the table associated with the index to be scanned and index specifies an index on which an index scan is to be performed. This hint may optionally specify one or more indexes:</p>
<p>NO_INDEX</p>
<p>The NO_INDEX hint explicitly disallows a set of indexes for the specified table. The syntax of the NO_INDEX hint is NO_INDEX(table index)</p>
<p>INDEX_ASC</p>
<p>The INDEX_ASC hint explicitly chooses an index scan for the specified table. If the statement uses an index range scan, Oracle scans the index entries in ascending order of their indexed values.</p>
<p>INDEX_COMBINE</p>
<p>If no indexes are given as arguments for the INDEX_COMBINE hint, the optimizer will use on the table whatever boolean combination of bitmap indexes has the best cost estimate. If certain indexes are given as arguments, the optimizer will try to use some boolean combination of those particular bitmap indexes. The syntax of INDEX_COMBINE is INDEX_COMBINE(table index).</p>
<p>INDEX_JOIN</p>
<p>Explicitly instructs the optimizer to use an index join as an access path. For the hint to have a positive effect, a sufficiently small number of indexes must exist that contain all the columns required to resolve the query.</p>
<p>INDEX_DESC</p>
<p>The INDEX_DESC hint explicitly chooses an index scan for the specified table. If the statement uses an index range scan, Oracle scans the index entries in descending order of their indexed values.</p>
<p>INDEX_FFS</p>
<p>This hint causes a fast full index scan to be performed rather than a full table.</p>
<p>NO_INDEX_FFS</p>
<p>Do not use fast full index scan (from Oracle 10g)</p>
<p>INDEX_SS</p>
<p>Exclude range scan from query plan (from Oracle 10g)</p>
<p>INDEX_SS_ASC</p>
<p>Exclude range scan from query plan (from Oracle 10g)</p>
<p>INDEX_SS_DESC</p>
<p>Exclude range scan from query plan (from Oracle 10g)</p>
<p>NO_INDEX_SS</p>
<p>The NO_INDEX_SS hint causes the optimizer to exclude a skip scan of the specified indexes on the specified table. (from Oracle 10g)</p>
<p><strong>Hints for Query Transformations</strong></p>
<p>NO_QUERY_TRANSFORMATION</p>
<p>Prevents the optimizer performing query transformations. (from Oracle 10g)</p>
<p>USE_CONCAT</p>
<p>The USE_CONCAT hint forces combined OR conditions in the WHERE clause of a query to be transformed into a compound query using the UNION ALL set operator. Normally, this transformation occurs only if the cost of the query using the concatenations is cheaper than the cost without them.</p>
<p>NO_EXPAND</p>
<p>The NO_EXPAND hint prevents the optimizer from considering OR-expansion for queries having OR conditions or IN-lists in the WHERE clause. Usually, the optimizer considers using OR expansion and uses this method if it decides that the cost is lower than not using it.</p>
<p>REWRITE</p>
<p>The REWRITE hint forces the optimizer to rewrite a query in terms of materialized views, when possible, without cost consideration. Use the REWRITE hint with or without a view list. If you use REWRITE with a view list and the list contains an eligible materialized view, then Oracle uses that view regardless of its cost.</p>
<p>NOREWRITE / NO_REWRITE</p>
<p>In Oracle 10g renamed to NO_REWRITE. The NOREWRITE/NO_REWRITE hint disables query rewrite for the query block, overriding the setting of the parameter QUERY_REWRITE_ENABLED.</p>
<p>MERGE</p>
<p>The MERGE hint lets you merge views in a query.</p>
<p>NO_MERGE</p>
<p>The NO_MERGE hint causes Oracle not to merge mergeable views. This hint is most often used to reduce the number of possible permutations for a query and make optimization faster.</p>
<p>FACT</p>
<p>The FACT hint indicated that the table should be considered as a fact table. This is used in the context of the star transformation.</p>
<p>NO_FACT</p>
<p>The NO_FACT hint is used in the context of the star transformation to indicate to the transformation that the hinted table should not be considered as a fact table.</p>
<p>STAR_TRANSFORMATION</p>
<p>The STAR_TRANSFORMATION hint makes the optimizer use the best plan in which the transformation has been used. Without the hint, the optimizer could make a query optimization decision to use the best plan generated without the transformation, instead of the best plan for the transformed query.</p>
<p>NO_STAR_TRANSFORMATION</p>
<p>Do not use star transformation (from Oracle 10g)</p>
<p>UNNEST</p>
<p>The UNNEST hint specifies subquery unnesting.</p>
<p>NO_UNNEST</p>
<p>Use of the NO_UNNEST hint turns off unnesting for specific subquery blocks.</p>
<p><strong>Hints for Join Orders</strong></p>
<p>LEADING</p>
<p>Give this hint to indicate the leading table in a join. This will indicate only 1 table. If you want to specify the whole order of tables, you can use the ORDERED hint. Syntax: LEADING(table)</p>
<p>ORDERED</p>
<p>The ORDERED hint causes Oracle to join tables in the order in which they appear in the FROM clause. If you omit the ORDERED hint from a SQL statement performing a join , the optimizer chooses the order in which to join the tables. You may want to use the ORDERED hint to specify a join order if you know something about the number of rows selected from each table that the optimizer does not. Such information would allow you to choose an inner and outer table better than the optimizer could.</p>
<p><strong>Hints for Join Operations</strong></p>
<p>USE_NL</p>
<p>The USE_NL hint causes Oracle to join each specified table to another row source with a nested loops join using the specified table as the inner table. The syntax of the USE_NL hint is USE_NL(table table) where table is the name or alias of a table to be used as the inner table of a nested loops join.</p>
<p>NO_USE_NL</p>
<p>Do not use nested loop (from Oracle 10g)</p>
<p>USE_NL_WITH_INDEX</p>
<p>Specifies a nested loops join. (from Oracle 10g)</p>
<p>USE_MERGE</p>
<p>The USE_MERGE hint causes Oracle to join each specified table with another row source with a sort-merge join. The syntax of the USE_MERGE hint is USE_MERGE(table table) where table is a table to be joined to the row source resulting from joining the previous tables in the join order using a sort-merge join.</p>
<p>NO_USE_MERGE</p>
<p>Do not use merge (from Oracle 10g)</p>
<p>USE_HASH</p>
<p>The USE_HASH hint causes Oracle to join each specified table with another row source with a hash join. The syntax of the USE_HASH hint is USE_HASH(table table) where table is a table to be joined to the row source resulting from joining the previous tables in the join order using a hash join.</p>
<p>NO_USE_HASH</p>
<p>Do not use hash (from Oracle 10g)</p>
<p>Hints for Parallel Execution</p>
<p>PARALLEL</p>
<p>The PARALLEL hint allows you to specify the desired number of concurrent query servers that can be used for the query. The syntax is PARALLEL(table number number). The PARALLEL hint must use the table alias if an alias is specified in the query. The PARALLEL hint can then take two values separated by commas after the table name. The first value specifies the degree of parallelism for the given table, the second value specifies how the table is to be split among the instances of a parallel server. Specifying DEFAULT or no value signifies the query coordinator should examine the settings of the initialization parameters (described in a later section) to determine the default degree of parallelism.</p>
<p>NOPARALLEL / NO_PARALLEL</p>
<p>The NOPARALLEL hint allows you to disable parallel scanning of a table, even if the table was created with a PARALLEL clause. In Oracle 10g this hint was renamed to NO_PARALLEL.</p>
<p>PQ_DISTRIBUTE</p>
<p>The PQ_DISTRIBUTE hint improves the performance of parallel join operations. Do this by specifying how rows of joined tables should be distributed among producer and consumer query servers. Using this hint overrides decisions the optimizer would normally make.</p>
<p>NO_PARALLEL_INDEX</p>
<p>The NO_PARALLEL_INDEX hint overrides a PARALLEL attribute setting on an index to avoid a parallel index scan operation.</p>
<p>Additional Hints</p>
<p>APPEND</p>
<p>When the APPEND hint is used with the INSERT statement, data is appended to the table. Existing free space in the block is not used. If a table or an index is specified with nologging, this hint applied with an insert statement produces a direct path insert which reduces generation of redo.</p>
<p>NOAPPEND</p>
<p>Overrides the append mode.</p>
<p>CACHE</p>
<p>The CACHE hint specifies that the blocks retrieved for the table in the hint are placed at the most recently used end of the LRU list in the buffer cache when a full table scan is performed. This option is useful for small lookup tables. In the following example, the CACHE hint overrides the table default caching specification.</p>
<p>NOCACHE</p>
<p>The NOCACHE hint specifies that the blocks retrieved for this table are placed at the least recently used end of the LRU list in the buffer cache when a full table scan is performed. This is the normal behavior of blocks in the buffer cache.</p>
<p>PUSH_PRED</p>
<p>The PUSH_PRED hint forces pushing of a join predicate into the view.</p>
<p>NO_PUSH_PRED</p>
<p>The NO_PUSH_PRED hint prevents pushing of a join predicate into the view.</p>
<p>PUSH_SUBQ</p>
<p>The PUSH_SUBQ hint causes nonmerged subqueries to be evaluated at the earliest possible place in the execution plan.</p>
<p>NO_PUSH_SUBQ</p>
<p>The NO_PUSH_SUBQ hint causes non-merged subqueries to be evaluated as the last step in the execution plan.</p>
<p>QB_NAME</p>
<p>Specifies a name for a query block. (from Oracle 10g)</p>
<p>CURSOR_SHARING_EXACT</p>
<p>Oracle can replace literals in SQL statements with bind variables, if it is safe to do so. This is controlled with the CURSOR_SHARING startup parameter. The CURSOR_SHARING_EXACT hint causes this behavior to be switched off. In other words, Oracle executes the SQL statement without any attempt to replace literals by bind variables.</p>
<p>DRIVING_SITE</p>
<p>The DRIVING_SITE hint forces query execution to be done for the table at a different site than that selected by Oracle</p>
<p>DYNAMIC_SAMPLING</p>
<p>The DYNAMIC_SAMPLING hint lets you control dynamic sampling to improve server performance by determining more accurate predicate selectivity and statistics for tables and indexes. You can set the value of DYNAMIC_SAMPLING to a value from 0 to 10. The higher the level, the more effort the compiler puts into dynamic sampling and the more broadly it is applied. Sampling defaults to cursor level unless you specify a table.</p>
<p>SPREAD_MIN_ANALYSIS</p>
<p>This hint omits some of the compile time optimizations of the rules, mainly detailed dependency graph analysis, on spreadsheets. Some optimizations such as creating filters to selectively populate spreadsheet access structures and limited rule pruning are still used. (from Oracle 10g)</p>
<p><strong>Hints with unknown status</strong></p>
<p>MERGE_AJ</p>
<p>The MERGE_AJ hint transforms a NOT IN subquery into a merge anti-join to access the specified table. The syntax of the MERGE_AJ hint is MERGE_AJ(table) where table specifies the name or alias of the table to be accessed.(depricated in Oracle 10g)</p>
<p>AND_EQUAL</p>
<p>The AND_EQUAL hint explicitly chooses an execution plan that uses an access path that merges the scans on several single-column indexes. The syntax of the AND_EQUAL hint is AND_EQUAL(table index index) where table specifies the name or alias of the table associated with the indexes to be merged. and index specifies an index on which an index scan is to be performed. You must specify at least two indexes. You cannot specify more than five. (depricated in Oracle 10g)</p>
<p>STAR</p>
<p>The STAR hint forces the large table to be joined last using a nested loops join on the index. The optimizer will consider different permutations of the small tables. (depricated in Oracle 10g)</p>
<p>BITMAP</p>
<p>Usage: BITMAP(table_name index_name) Uses a bitmap index to access the table. (depricated ?)</p>
<p>HASH_SJ</p>
<p>Use a Hash Anti-Join to evaluate a NOT IN sub-query. Use this hint in the sub-query, not in the main query. Use this when your high volume NOT IN sub-query is using a FILTER or NESTED LOOPS join. Try MERGE_AJ if HASH_AJ refuses to work.(depricated in Oracle 10g)</p>
<p>NL_SJ</p>
<p>Use a Nested Loop in a sub-query. (depricated in Oracle 10g)</p>
<p>NL_AJ</p>
<p>Use an anti-join in a sub-query. (depricated in Oracle 10g)</p>
<p>ORDERED_PREDICATES</p>
<p>(depricated in Oracle 10g)</p>
<p>EXPAND_GSET_TO_UNION</p>
<p>(depricated in Oracle 10g)</p>
</blockquote>

            
            <p class="more">
                <a href="/2015/07/02/2019030500127/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/02/2019030500127/" title="Oracle中Hint深入理解">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/02/2019030500122/">
    		NoSQL数据库概览及其与SQL语法的比较
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-02T06:14:20.000Z">2015-07-02</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/NoSQL/" title="NoSQL">NoSQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p><strong>【文章摘要</strong>】 HBase是一个高可靠性、高性能、面向列、可伸缩的分布式存储系统，同时也是知名的NoSQL数据库之一。NoSQL数据库的产生就是为了解决大规模数据集合多重数据种类带来的挑战，尤其是大数据应用的难题。 本文对NoSQL数据库的定义、分类、特征、当前比较流行的NoSQL数据库系统等进行了简单的介绍，并对NoSQL和SQL语法进行了简单的比较，为大家对NoSQL数据库的学习提供了有益的参考。   <strong>一、NoSQL的出现</strong> 关系型数据库系统多年来在解决数据存储、服务和处理问题方面取得了巨大的成功。一些大型的公司使用关系型数据库建立了自己的系统，如联机事务处理系统和后端分析应用系统。联机事务处理(OLTP)系统用来实时记录交易信息。对这类系统的期望是能够快速返回响应信息(一般在毫秒级)。联机分析处理(OLAP)系统用来分析查询所储存的数据。OLAP属于商业智能的范畴，数据需要研究、处理和分析，以便收集信息，进一步驱动商业决策。 关系型数据库的内部设计由关系算法决定，这些系统需要预先定义一个模式(schema)和数据要遵守的类型。SQL是与这些系统交互的标准方式。但在对象-关系不匹配问题出现的场合，SQL就不是表达访问模式的最好方式了。例如目前炙手可热的大数据领域，关系型数据库不能很好地工作。 有关大数据常见定义包括：第一，大数据意味着数据足够大，为了从这些数据中获得一些真知灼见，你不得不研究它；第二，大数据就是不再适用于单台机器的数据。这些观点并不完整，我们需要用一种根本上不同的方式来考虑数据，从如何驱动商业价值的角度来考虑数据，这种数据就是大数据。 在大数据领域中，系统需要能够适应不同种类的数据格式和数据源，不需要预先严格定义模式，并且能够处理大规模数据。这样，NoSQL就出现了。   <strong>二、NoSQL的定义</strong> NoSQL(NoSQL= Not Only SQL )，意即“不仅仅是SQL”，是一项全新的数据库革命性运动。NoSQL的拥护者们提倡运用非关系型的数据存储。大多数数据库技术不能保证支持ACID(原子性、一致性、隔离性和持久性)，而且大部分技术都是开源项目，这些技术作为整体被称为NoSQL。   <strong>三、NoSQL的分类</strong> 一般将NoSQL数据库分为四大类：键值(Key-Value)存储数据库、列存储数据库、文档型数据库和图形(Graph)数据库。它们的数据模型、优缺点、典型应用场景如表1所示。</p>
<p>表1 四大NoSQL数据库分析</p>
<p><strong>分类</strong></p>
<p><strong>数据模型</strong></p>
<p><strong>优点</strong></p>
<p><strong>缺点</strong></p>
<p><strong>典型应用场景</strong></p>
<p>键值(Key-Value)存储数据库</p>
<p>Key指向Value的键值对，通常用hash表来实现</p>
<p>查找速度快</p>
<p>数据无结构化(通常只被当作字符串或者二进制数据)</p>
<p>内容缓存，主要用于处理大量数据的高访问负载，也用于一些日志系统等</p>
<p>列存储数据库</p>
<p>以列簇式存储，将同一列数据存在一起</p>
<p>查找速度快，可扩展性强，更容易进行分布式扩展</p>
<p>功能相对局限</p>
<p>分布式的文件系统</p>
<p>文档型数据库</p>
<p>Key-Value对应的键值对，Value为结构化数据</p>
<p>数据结构要求不严格，表结构可变(不需要像关系型数据库一样需预先定义表结构)</p>
<p>查询性能不高，而且缺乏统一的查询语法</p>
<p>Web应用</p>
<p>图形(Graph)数据库</p>
<p>图结构</p>
<p>利用图结构相关算法(如最短路径寻址，N度关系查找等)</p>
<p>很多时候需要对整个图做计算才能得出需要的信息，而且这种结构不太好做分布式的集群方案</p>
<p>社交网络，推荐系统等</p>
<pre><code>**四、NoSQL的特征** NoSQL数据库并没有一个统一的架构，但是它们都普遍存在表2所示的一些共同特征。
</code></pre><p>表2 NoSQL的特征</p>
<p><strong>特征</strong></p>
<p><strong>描述</strong></p>
<p>不需要预定义模式</p>
<p>不需事先定义数据模式，预定义表结构等。数据中每条记录都可能有不同的属性和格式</p>
<p>无共享架构</p>
<p>NoSQL往往将数据划分后存储在各个本地服务器上，从而提高了系统的性能</p>
<p>弹性可扩展</p>
<p>可以在系统运行的时候，动态增加或者删除结点。不需要停机维护，数据可以自动迁移</p>
<p>分区</p>
<p>NoSQL数据库将数据进行分区，将记录分散在多个节点上面，并且通常分区的同时还要做复制</p>
<p>异步复制</p>
<p>NoSQL中的复制，往往是基于日志的异步复制。这样，数据就可以尽快地写入一个节点，而不会出现网络传输迟延</p>
<p>BASE</p>
<p>相对于ACID特性，NoSQL数据库保证的是BASE特性(BASE是最终一致性和软事务)</p>
<p>  <strong>五、常见的NoSQL数据库</strong> 比较适合采用NoSQL数据库的场合是：(1)数据模型比较简单；(2)需要灵活性更强的IT系统；(3)对数据库性能要求较高；(4)不需要高度的数据一致性；(5)对于给定key，比较容易映射复杂值的环境。 常见的NoSQL数据库如表3所示。</p>
<p>表3常见的NoSQL数据库</p>
<p><strong>分类</strong></p>
<p><strong>实例</strong></p>
<p>键值(Key-Value)存储数据库</p>
<p>*  Riak：一个开源、分布式键值数据库，支持数据复制和容错</p>
<p>*  Redis：一个开源的键值存储数据库，支持主从式复制、事务，Pub/Sub、Lua脚本，还支持给Key添加时限</p>
<p>*  Dynamo：一个键值分布式存储数据库，直接由亚马逊Dynamo数据库实现</p>
<ul>
<li><p>Oracle NoSQL Database：来自Oracle的键值NoSQL数据库，支持事务ACID和JSON</p>
</li>
<li><p>Oracle NoSQL Database：具备数据备份和分布式键值存储系统</p>
</li>
<li><p>Voldemort：具备数据备份和分布式键值存储系统</p>
</li>
<li><p>Aerospike：一个键值存储数据库，支持混合内存架构，通过强一致性和可调一致性保证数据的完整性</p>
</li>
</ul>
<p>列存储数据库</p>
<ul>
<li><p>Cassandra：支持跨数据中心的数据复制，提供列索引</p>
</li>
<li><p>HBase：一个开源、分布式、面向列存储的模型</p>
</li>
<li><p>Amazon SimpleDB：一个非关系型数据存储</p>
</li>
<li><p>Apache Accumulo：有序的、分布式键值数据存储，基于Google的BigTable设计</p>
</li>
<li><p>Hypertable：一个开源、可扩展的数据库，模仿Bigtable，支持分片</p>
</li>
<li><p>Azure Tables：为要求大量非结构化数据存储的应用提供NoSQL性能</p>
</li>
</ul>
<p>文档型数据库</p>
<ul>
<li><p>MongoDB：开源、面向文档</p>
</li>
<li><p>CounchDB：一个使用JSON的文档数据库，使用Javascript做MapReduce查询，也是一个使用HTTP的API</p>
</li>
<li><p>Couchbase：基于JSON模型</p>
</li>
<li><p>RavenDB：一个基于.net语言的面向文档数据库</p>
</li>
<li><p>MarkLogic：用来存储基于XML和以文档为中心的信息，支持灵活的模式</p>
</li>
</ul>
<p>图形(Graph)数据库</p>
<ul>
<li><p>Neo4j：一个图数据库，支持ACID事务</p>
</li>
<li><p>InfiniteGraph：用来维持和遍历对象间的关系，支持分布式数据存储</p>
</li>
<li><p>AllegroGraph：结合使用了内存和磁盘，提供了高可扩展性，支持SPARQ、RDFS++和Prolog推理</p>
</li>
</ul>
<p><strong>六、NoSQL和SQL语法的简单比较</strong> 前面介绍了NoSQL的基本情况，下面以HBase和ORACLE为例，对NoSQL和SQL的语法进行简单的比较。HBase数据库被认为是安全特性最完善的NoSQL数据库产品之一，它被证实是一个强大的工具，尤其是在已经使用Hadoop的场合。如今，它已经是Apache顶级项目，有着众多的开发人员和兴旺的用户社区。 1.创建表 如果要创建一个表“mytable”，其中包含了一个“info”字段，那么： (1)ORACLE中的语法为： create table mytable ( info  varchar(30) not null ); (2)HBase中的语法为： create ‘mytable’, ‘cf’ 该命令创建了一个有一个列族(“cf”)的表“mytable”。   2.写数据 如果要向表中写入数据“hello hbase”，那么： (1)ORACLE中的语法为： insert into mytable(info) values(‘hello hbase’); (2)HBase中的语法为： put ‘mytable’, ‘first’, ‘cf:info’, ‘hello hbase’ 该命令在“mytable”表的“first”行中的“cf:info”列对应的数据单元中插入“hello hbase”。   3.读(查)数据 如果要从表中读出单条数据，那么： (1)ORACLE中的语法为： select <em> from mytable where info = ‘hello hbase’; (2)HBase中的语法为： get ‘mytable’, ‘first’ 该命令输出了该行的数据单元。   如果要从表中读出所有数据，那么： (1)ORACLE中的语法为： select </em> from mytable; (2)HBase中的语法为： scan ‘mytable’ 该命令输出了所有数据。   4.删数据 如果要从表中删除数据，那么： (1)ORACLE中的语法为： delete from mytable where info = ‘hello hbase’; (2)HBase中的语法为： put ‘mytable’, ‘first’, ‘cf:info’, ‘hello hbase1’ 该命令用最新的值覆盖了旧的值，就相当于将原数据删除了。   5.修改数据 如果要在表中修改数据，那么： (1)ORACLE中的语法为： update mytable set info = ‘hello hbase1’ where info = ‘hellohbase’; (2)HBase中的语法为： put ‘mytable’, ‘first’, ‘cf:info’, ‘hello hbase1’ 该命令用最新的值覆盖了旧的值，就相当于修改了原数据。   6.删表 如果要删除表，那么： (1)ORACLE中的语法为： drop table mytable; (2)HBase中的语法为： disable ‘mytable’ drop ‘mytable’ 该命令先将表“disable”掉，然后再“drop”掉。   我们可以看到，HBase的语法比较的简单，因此完全可以将上述所有命令放到一个shell脚本中，让命令批量执行。下面，我们来具体操作一下： 第一步，编写名为“command.sh”的脚本，其内容如下： exec /root/zhouzx/hbase-1.0.1/bin/hbase shell &lt;&lt;EOF create ‘mytable’, ‘cf’ put ‘mytable’, ‘first’, ‘cf:info’, ‘hello hbase’ get ‘mytable’, ‘first’ scan ‘mytable’ put ‘mytable’, ‘first’, ‘cf:info’, ‘hello hbase1’ disable ‘mytable’ drop ‘mytable’ EOF   第二步，将该脚本上传到Linux机器的安装HBase的用户下，依次执行“dos2unix command.sh”和“chmod 777command.sh”命令来转换文件格式和对文件赋权限。   第三步，执行“./command.sh”命令，在Linux界面上，我们可以看到如下输出信息： HBase Shell; enter ‘help<return>‘ for list of supportedcommands. Type “exit<return>“ to leave the HBase Shell Version 1.0.1, r66a93c09df3b12ff7b86c39bc8475c60e15af82d, Fri Apr17 22:14:06 PDT 2015   create ‘mytable’, ‘cf’ 0 row(s) in 0.6660 seconds   Hbase::Table - mytable put ‘mytable’, ‘first’, ‘cf:info’, ‘hello hbase’ 0 row(s) in 0.1140 seconds   get ‘mytable’, ‘first’ COLUMN                           CELL cf:info                         timestamp=1435807200326, value=hello hbase 1 row(s) in 0.0440 seconds   scan ‘mytable’ ROW                  COLUMN+CELL first                   column=cf:info,timestamp=1435807200326, value=hello hbase 1 row(s) in 0.0210 seconds   put ‘mytable’, ‘first’, ‘cf:info’, ‘hello hbase1’ 0 row(s) in 0.0040 seconds   disable ‘mytable’ 0 row(s) in 1.1930 seconds   drop ‘mytable’ 0 row(s) in 0.1940 seconds   整个脚本执行过程不过几秒钟，但我们之前提到的所有HBase命令都包括其中了，由此可见批处理的威力。大家一定要好好体会一下。   <strong>七、总结</strong> 本文对NoSQL进行了全面的介绍，并比较了它与SQL语法之间的不同。尽管大多数NoSQL数据存储系统都已被部署到实际应用中，但仍存在以下挑战性问题需要解决： 第一，已有key-value数据库产品大多是面向特定应用自治构建的，缺乏通用性。 第二，已有产品支持的功能有限(不支持事务特性)，导致其应用具有一定的局限性。 第三，已有一些研究成果和改进的NoSQL数据存储系统，但它们都是针对不同应用需求而提出的相应解决方案，很少从全局考虑系统的通用性，也没有形成系列化的研究成果。 第四，缺乏类似关系数据库所具有的强有力的理论(如armstrong公理系统)、技术(如成熟的基于启发式的优化策略、两段封锁协议等)、标准规范(如SQL语言)的支持。 第五，很多NoSQL数据库没有提供内建的安全机制。   随着云计算、移动互联网等技术的发展，大数据广泛存在，同时也出现了许多云环境下的新型应用，如社交网络、移动服务、协作编辑等。这些新型应用对海量数据管理或称云数据管理系统也提出了新的需求，NoSQL数据库在这些方面有大展身手的机会。我们有理由相信，NoSQL数据库的明天会更加的美好！</return></return></p>
</blockquote>

            
            <p class="more">
                <a href="/2015/07/02/2019030500122/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/02/2019030500122/" title="NoSQL数据库概览及其与SQL语法的比较">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/02/2019030500104/">
    		mysql行转列（拆分字符串场景）
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-02T05:52:29.000Z">2015-07-02</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>一对多没有建立中间表的时候经常会采用分隔符的形式将“多”存储在“一”的一个字段里，这样做的代价是无法向一对多的时候那样直接关联查询，一般采用在程序中分割后分别查询的办法。如下图： <img src="http://img.blog.csdn.net/20150701165850674?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFva3g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> 如何才能直接用sql语句查询出下图的效果呢？ <img src="http://img.blog.csdn.net/20150701170018457?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFva3g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> 可以借助一个序号表，该表中除了连续的id没有其它字段，id的值范围取决于”一”中存储的信息拆分后的数量。 <img src="http://img.blog.csdn.net/20150701170230086?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvYmFva3g=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> 实现sql：</p>
<p><strong>[sql]</strong></p>
<ol>
<li>SELECT</li>
<li>NAME,</li>
<li>REPLACE(</li>
<li>SUBSTRING_INDEX(mobile, ‘,’, a.id),</li>
<li>CONCAT(</li>
<li>SUBSTRING_INDEX(mobile, ‘,’, a.id - 1),</li>
<li>‘,’</li>
<li>),</li>
<li>‘’</li>
<li>)AS mobile</li>
<li>FROM</li>
<li>squence a</li>
<li>CROSS JOIN(</li>
<li>SELECT</li>
<li>NAME,</li>
<li>CONCAT(mobile, ‘,’)AS mobile,</li>
<li>LENGTH(mobile)- LENGTH(REPLACE(mobile, ‘,’, ‘’))+ 1 AS size</li>
<li>FROM</li>
<li><code>user</code></li>
<li>)b ON a.id &lt;= b.size</li>
</ol>

            
            <p class="more">
                <a href="/2015/07/02/2019030500104/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/02/2019030500104/" title="mysql行转列（拆分字符串场景）">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/02/2019030500139/">
    		Oracle移除表空间的数据文件 ora-00604 ora-01426
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-02T05:05:35.000Z">2015-07-02</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a> / 
    
        <a href="/tags/ora-00604/" title="ora-00604">ora-00604</a> / 
    
        <a href="/tags/ora-01426/" title="ora-01426">ora-01426</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p>项目背景:在之前开发环境数据库管理比较乱,在表空间不足时只是添加数据文件,测试完后数据己删除,但数据库表空间所占的空间不能回收,导致数据库的存储目录使用率达到97%以上实际使用只有10%,迫切需要将不用空间进行回收. 技术背景:Oracle不提供如删除表、视图一样删除数据文件的方法，数据文件是表空间的一部分，所以不能“移走”表空间。Oracle 10G R2开始，可以采用：Alter tablespace tablespace_name drop datafile file_name;来删除一个空数据文件，并且相应的数据字典信息也会清除: A.确认oracle版本(我是以本机(windows)查看数据库版本,测试环境为AIX操作系统,但数据库版本一致),版本满足可以直接删除数据文件 select <em> from v$version; B.确认移除的数据文件 a.确定需要移去的数据文件,可以用数据文件最大扩展的大小和对象多少综合评估一下,是否将这个文件进行移除 扩展大小: select file_id,tablespace_name,max(t.block_id)\</em>8192/1024/1024 from dba_extents t where tablespace_name = ‘FERMATDATA’ group by file_id,tablespace_name 对象多少: select * from dba_extents t where t.file_id =10 C.将数据文件中己有的对象move到其他表空间 a.对于segment_type为TABLE的非分区表采用以下语句 alter table bob_rwa3.db move tablespace ETLDATA; 批量语句: select ‘alter table ‘||t.owner||’.’||t.segment_name||’ move tablespace ETLDATA ;’ from dba_extents t where t.file_id =10 and t.partition_name is null b.对于segment_type为TABLE的分区表采用以下语句(非复合分区) alter table BOB_RAY.T_TRANSITION_MATRIX move partition P199001010001 tablespace ETLDATA update global indexes ; 批量脚本: select ‘alter table ‘||t.owner||’.’||t.segment_name||’ move partition ‘||t.partition_name||’ tablespace ETLDATA update global indexes ;’ from dba_extents t where t.file_id =10 and t.partition_name is not null ; c.对于segment_type 为TABLE复合分区采用以下语句 alter table BOB_RAY.LOG_TABLE move subpartition P199001010001_NULL tablespace IRM_DATA; 批量脚本可以自己关联dba_tab_subpartitions表写出. d.对于segment_type为LOBSEGMENT或LOBINDEX可以采用以下语句,因为LOB类型的字段会自动生成存储数据和索引两部份(lobsegment,lobindex) 1.查看找segment_type为lob的segment_name: select <em>  from dba_extents t where t.file_id =10 and t.segment_type like ‘%LOB%’; 2.查看segment_type为LOB对应的column select </em> from dba_lobs t where t.segment_name like ‘%SYS_LOB0000145648C00003%’ ; 3.将segment_type为LOB类型转移到其他表空间,因为move table只转移动非lob字段,所以需要执行以下语句 alter table BOB_RAY.BIRT_RESOURCE move tablespace ETLDADA lob(CONTENT) store as (tablespace ETLDATA); 批量脚本关联即可写出 因为本项目中数据表空间和索引表空间是分开的,所以这里不涉及索引的相关操作,如果有索引的情况估计与表的情况相似. D.确认数据文件是否为空 a.查看dba_extents 是否有记录(需要没有记录) select <em>  from dba_extents t where t.file_id =10; b.查看dba_segments是否有记录(需要没有记录) select </em> from dba_segments t where t.header_file = 10 注意:如果dba_segments有回收站的数据,那么在删除表空间数据文件时会报错 ora-00604 ora-01426 c.删除回收站数据 purge recyclebin; E.删除表空间对应的数据文件 1.查看数据文件名称 select * from dba_data_files t where t.file_id = 10 ; 2.删除表空间数据文件 alter tablespace FERMATDATA drop  datafile ‘D:\APP\ORADATA\RWADB\FERMATDATA02.DBF’; 注意:当执行完语句时数据库服务器用df -g查看空间时没有变化,重启数据库后才能看到空间明显回收了 F.指定表存储在固定的数据文件方法以(扩展) alter  table bob_ray.bis_risk_bucket allocate extent( datafie ‘/oracle/oradata/orcl/appdata.dbf’ ); 此语句不会改变表中现有数据的存储,当新insert数据时才生效,</p>
</blockquote>

            
            <p class="more">
                <a href="/2015/07/02/2019030500139/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/02/2019030500139/" title="Oracle移除表空间的数据文件 ora-00604 ora-01426">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/02/2019030500109/">
    		MYSQL错误1053:服务没有及时响应启动或控制请求
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-02T04:46:37.000Z">2015-07-02</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/1053/" title="1053">1053</a> / 
    
        <a href="/tags/my-ini/" title="my.ini">my.ini</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <ol>
<li>错误描述 <img src="http://img.blog.csdn.net/20150701210957279" alt="这里写图片描述"></li>
<li>错误原因 由于连接不上本地数据库，我将MySQL安装目录下的my.ini配置文件删除，结果导致MySQL56服务无法启动；再次将my.ini复制到安装目录指定位置下，但是MySQL服务还是无法启动</li>
<li>解决办法 上述方法尝试失败后，我将原先安装的MySQL相关的程序全部卸载掉，然后重新安装MySQL，重装后可以启动MySQL服务</li>
</ol>

            
            <p class="more">
                <a href="/2015/07/02/2019030500109/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/02/2019030500109/" title="MYSQL错误1053:服务没有及时响应启动或控制请求">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/01/2019030500170/">
    		TNS-12541，TNS-12560，TNS-00511，TNS-12542，TNS-12560，TNS-00512数据库启动监听报错
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-01T04:22:02.000Z">2015-07-01</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/TNS/" title="TNS">TNS</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p>服务器环境为ORACLE11G RAC环境，系统启动后，监听没起来。</p>
<p><strong>[oracle@RAC4 ~]$ lsnrctl status</strong> LSNRCTL for Linux: Version 11.2.0.3.0 - Production on 29-JUN-2015 10:44:45 Copyright (c) 1991, 2011, Oracle.  All rights reserved. Connecting to (ADDRESS=(PROTOCOL=tcp)(HOST=)(PORT=1521)) TNS-12541: TNS:no listener TNS-12560: TNS:protocol adapter error TNS-00511: No listener Linux Error: 111: Connection refused</p>
<p><strong>1.1.1.2 检查思路</strong></p>
<p><strong>当时同事已经检查过CRS、也尝试过使用命令启动监听等步骤。但是启动监听的时候会有以下报错</strong>。</p>
<p><strong>[oracle@RAC4 ~]$ lsnrctl start</strong> LSNRCTL for Linux: Version 11.2.0.3.0 - Production on 29-JUN-2015 10:51:46 Copyright (c) 1991, 2011, Oracle.  All rights reserved. Starting /u01/app/oracle/product/11.2.0/db_1/bin/tnslsnr: please wait… TNSLSNR for Linux: Version 11.2.0.3.0 - Production Log messages written to /u01/app/oracle/diag/tnslsnr/RAC4/listener/alert/log.xml Error listening on: (ADDRESS=(PROTOCOL=tcp)(HOST=)(PORT=1521)) TNS-12542: TNS:address already in use TNS-12560: TNS:protocol adapter error TNS-00512: Address already in use Linux Error: 98: Address already in use Listener failed to start. See the error message(s) above…</p>
<p><strong>居然说系统已使用，那么理所当然的就去查看1521端口和lsn进程</strong></p>
<p><strong>[root@RAC4 ~]# ps-ef | grep lsn</strong></p>
<p>grid     52181     1  0 10:04?        00:00:11/u01/<em>/</em>/bin/tnslsnrLISTENER_SCAN1 -inherit</p>
<p>root    101600 100759  0 22:30 pts/0    00:00:00 grep lsn</p>
<p>[root@RAC4 ~]#netstat-anp | grep 1521</p>
<p>tcp       0     0xxx.xxx.xxx.xxx:1521          0.0.0.0:*                  LISTEN      52181/tnslsnr     （有些内容不便列出）</p>
<p>发现1521端口和/u01/11.2.0/grid/bin/tnslsnrLISTENER_SCAN1-inherit进程存在，所以尝试杀掉此进程</p>
<p><strong>[root@RAC4 ~]#kill -9 52181</strong></p>
<p>-bash: kill:(52181) - No suchprocess</p>
<p>杀掉后发现系统提示没有这个进程,再次查询</p>
<p>[root@RAC4 ~]# ps-ef |grep lsn</p>
<p>grid    104147     1  0 23:23?        00:00:00/u01/<em>/</em>/bin/tnslsnrLISTENER_SCAN1 -inherit</p>
<p>root    104379 104353  0 23:28 pts/0    00:00:00 grep lsn</p>
<p>又有了，应该是父进程自动又给他启动了，查看其父进程是init进程。</p>
<p><strong>[grid@RAC4 ~]$pstree 1</strong></p>
<p>init─┬─MBADataMover───MBADataMover───MBADataMover</p>
<pre><code>├─2*\[tnslsnr───2*\[{tnslsnr}\]\]
</code></pre><p><strong>1.1.1.3 出现问题的原因</strong></p>
<p>因为我记得在书上看到过，11G的RAC中SRVCTL可以管理监听，于是尝试使用此命令来启动监听。</p>
<p><strong>1.1.1.4 解决方法</strong></p>
<p><strong>[grid@RAC4 ~]$srvctl start listener -n RAC4</strong></p>
<p><strong>[grid@RAC4~]$ exit</strong></p>
<p>logout</p>
<p><strong>[root@RAC4~]# su -oracle</strong></p>
<p><strong>[oracle@RAC4~]$lsnrctl status;</strong></p>
<p>LSNRCTLfor Linux:Version 11.2.0.3.0 - Production on 01-JUL-2015 11:32:45</p>
<p>Copyright(c) 1991,2011, Oracle.  All rightsreserved.</p>
<p>Connectingto(ADDRESS=(PROTOCOL=tcp)(HOST=)(PORT=1521))</p>
<p>STATUSof theLISTENER</p>
<p>------------------------</p>
<p>Alias                    LISTENER</p>
<p>Version                  TNSLSNR for Linux: Version11.2.0.3.0 - Production</p>
<p>StartDate               01-JUL-2015 10:38:57</p>
<p>Uptime                   0 days 0 hr. 53 min. 47 sec</p>
<p>TraceLevel              off</p>
<p>Security                 ON: Local OS Authentication</p>
<p>SNMP                     OFF</p>
<p>ListenerParameterFile  /u01/11.2.0/grid/network/admin/listener.ora</p>
<p>ListenerLogFile        /u01/app/oracle/diag/tnslsnr/RAC4/listener/alert/log.xml</p>
<p>ListeningEndpointsSummary…</p>
<p> (DESCRIPTION=(ADDRESS=(PROTOCOL=ipc)(KEY=LISTENER)))</p>
<p> (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=11.10.110.23)(PORT=1521)))</p>
<p> (DESCRIPTION=(ADDRESS=(PROTOCOL=tcp)(HOST=11.10.110.25)(PORT=1521)))</p>
<p>ServicesSummary…</p>
<p>Service”+ASM”has 1 instance(s).</p>
<p>  Instance”+ASM2”, status READY, has1 handler(s) for this service…</p>
<p>Service”RAC3”has 1 instance(s).</p>
<p>  Instance”RAC32”, status READY, has1 handler(s) for this service…</p>
<p>Service”RAC3XDB”has 1 instance(s).</p>
<p>  Instance”RAC32”, status READY, has1 handler(s) for this service…</p>
<p>Service”RACDB007”has 1 instance(s).</p>
<p>  Instance “RACDB0072”,status READY, has1 handler(s) for this service…</p>
<p>Service”RACDB007JL_BJ”has 1 instance(s).</p>
<p>  Instance”RACDB007JL2”, status READY,has 1 handler(s) for this service…</p>
<p>Service”RACDB007JL_BJXDB”has 1 instance(s).</p>
<p>  Instance”RACDB007JL2”, status READY,has 1 handler(s) for this service…</p>
<p>Service”RACDB007XDB”has 1 instance(s).</p>
<p>  Instance”RACDB0072”, status READY, has1 handler(s) for this service…</p>
<p>The commandcompleted successfully</p>
<p><strong>1.1.1.5 知识点</strong></p>
<p>经过这次问题的解决，发现oracle 11G的RAC中有很多功能都通过集群命令来控制，而不能单一的通过单机管理的方法来控制集群的某些功能</p>
</blockquote>

            
            <p class="more">
                <a href="/2015/07/01/2019030500170/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/01/2019030500170/" title="TNS-12541，TNS-12560，TNS-00511，TNS-12542，TNS-12560，TNS-00512数据库启动监听报错">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <a class="extend prev" rel="prev" href="/archives/2015/07/">前一页</a><a class="page-number" href="/archives/2015/07/">1</a><span class="page-number current">2</span>
    </nav>
    


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/MySQL/">MySQL</a>
        <span class="badge">(92)</span>
    </li>
    
    <li>
        <a href="/categories/开发语言/">开发语言</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="/categories/Oracle/">Oracle</a>
        <span class="badge">(40)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/">NOSQL</a>
        <span class="badge">(17)</span>
    </li>
    
    <li>
        <a href="/categories/其他数据库/">其他数据库</a>
        <span class="badge">(4)</span>
    </li>
    
    <li>
        <a href="/categories/SQL-Server/">SQL Server</a>
        <span class="badge">(13)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/">Oracle</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/SQL-Server/">SQL Server</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/开发语言/">开发语言</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/MySQL/" title="MySQL">MySQL (71)</a>
  
    <a class="tag-item" href="/tags/位运算/" title="位运算">位运算 (0)</a>
  
    <a class="tag-item" href="/tags/allow/" title="allow">allow (1)</a>
  
    <a class="tag-item" href="/tags/Apache/" title="Apache">Apache (1)</a>
  
    <a class="tag-item" href="/tags/deny/" title="deny">deny (1)</a>
  
    <a class="tag-item" href="/tags/sqlplus/" title="sqlplus">sqlplus (1)</a>
  
    <a class="tag-item" href="/tags/CentOS/" title="CentOS">CentOS (2)</a>
  
    <a class="tag-item" href="/tags/redis/" title="redis">redis (6)</a>
  
    <a class="tag-item" href="/tags/druid/" title="druid">druid (1)</a>
  
    <a class="tag-item" href="/tags/心跳/" title="心跳">心跳 (1)</a>
  
    <a class="tag-item" href="/tags/事务/" title="事务">事务 (5)</a>
  
    <a class="tag-item" href="/tags/分布式/" title="分布式">分布式 (1)</a>
  
    <a class="tag-item" href="/tags/消息/" title="消息">消息 (1)</a>
  
    <a class="tag-item" href="/tags/Oracle/" title="Oracle">Oracle (30)</a>
  
    <a class="tag-item" href="/tags/schedule-job/" title="schedule job">schedule job (1)</a>
  
    <a class="tag-item" href="/tags/KeepAlived/" title="KeepAlived">KeepAlived (1)</a>
  
    <a class="tag-item" href="/tags/分库/" title="分库">分库 (1)</a>
  
    <a class="tag-item" href="/tags/分库分表/" title="分库分表">分库分表 (1)</a>
  
    <a class="tag-item" href="/tags/分表/" title="分表">分表 (1)</a>
  
    <a class="tag-item" href="/tags/数据库/" title="数据库">数据库 (7)</a>
  
    <a class="tag-item" href="/tags/结构同步/" title="结构同步">结构同步 (1)</a>
  
    <a class="tag-item" href="/tags/truncate/" title="truncate">truncate (1)</a>
  
    <a class="tag-item" href="/tags/SQL/" title="SQL">SQL (17)</a>
  
    <a class="tag-item" href="/tags/批量/" title="批量">批量 (1)</a>
  
    <a class="tag-item" href="/tags/Excel/" title="Excel">Excel (1)</a>
  
    <a class="tag-item" href="/tags/Sqlite/" title="Sqlite">Sqlite (1)</a>
  
    <a class="tag-item" href="/tags/FineReport/" title="FineReport">FineReport (1)</a>
  
    <a class="tag-item" href="/tags/报表/" title="报表">报表 (1)</a>
  
    <a class="tag-item" href="/tags/数据集/" title="数据集">数据集 (1)</a>
  
    <a class="tag-item" href="/tags/Hash索引/" title="Hash索引">Hash索引 (1)</a>
  
    <a class="tag-item" href="/tags/InnoDB/" title="InnoDB">InnoDB (3)</a>
  
    <a class="tag-item" href="/tags/MyISAM/" title="MyISAM">MyISAM (3)</a>
  
    <a class="tag-item" href="/tags/索引优化/" title="索引优化">索引优化 (1)</a>
  
    <a class="tag-item" href="/tags/Linux/" title="Linux">Linux (2)</a>
  
    <a class="tag-item" href="/tags/Character-set/" title="Character set">Character set (1)</a>
  
    <a class="tag-item" href="/tags/NLS-LANG/" title="NLS_LANG">NLS_LANG (1)</a>
  
    <a class="tag-item" href="/tags/rowid/" title="rowid">rowid (2)</a>
  
    <a class="tag-item" href="/tags/重复/" title="重复">重复 (1)</a>
  
    <a class="tag-item" href="/tags/mysqldump/" title="mysqldump">mysqldump (2)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="http://www.devba.com" target="_blank" title="软件开发吧">软件开发吧</a>
        </li>
    
        <li>
            <a href="https://www.sqlyun.cn" target="_blank" title="SQL云笔记">SQL云</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>