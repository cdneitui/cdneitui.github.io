<!doctype html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8">
    <meta name="baidu-site-verification" content="dIcXMeY8Ya">
    
    <title>文章归档: 2015 | 软件开发吧</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="keywords" content="SQL云,SQL云开发,SQL笔记,SQL开发,云开发,MySQL,Oralce,数据库,数据库云,数据库开发,数据库云开发,SQL教程,数据库教程,开发笔记,MySQL笔记,MySQL教程">
    <meta name="description" content="为满足广大程序猿兄弟对日常工作中学习数据库、使用使用数据库资料查询需求，SQL云开发免费将自己整理的各种数据库技术资料分享出来，并希望与广大猿兄一起讨论学习与进步,致力于一起更方便、快捷资料学习查询,实现更安全、高效的数据存储.">

    
    <link rel="alternative" href="/atom.xml" title="软件开发吧" type="application/atom+xml">
    
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
</html>
<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">软件开发吧</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/archives/2015/page/5/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/archives/2015/page/5/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/archives/2015/page/5/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/archives/2015/page/5/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/cdneitui" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.github.com/" target="_blank">Hosted by GitHub Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon">
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 文章归档 -->

    <h3 class="widget-hd">
        <strong>
            
                文章归档
                <!-- 文章归档，可以根据日期分类 -->
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/10/30/2019030500123/">
    		ORA-12514: TNS:监听程序当前无法识别连接描述符中请求的服务
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-10-30T01:22:34.000Z">2015-10-30</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a> / 
    
        <a href="/tags/PL-SQL/" title="PL/SQL">PL/SQL</a> / 
    
        <a href="/tags/ORA-12514/" title="ORA-12514">ORA-12514</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>PL/SQL连接Oracle数据库的时候 报”ORA-12514: TNS:监听程序当前无法识别连接描述符中请求的服务” 错误   本例原因： 安装Oracle时一般默认实例都是orcl，发现有人不按套路出牌，改了名字，如图 <img src="http://img.blog.csdn.net/20151023163912605?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast" alt>   解决方法： 在Oracle安装目录 找到listener.ora文件 路径为 D:\oracle\product\11.2.0\dbhome_1\NETWORK\ADMIN (根据自己情况查找) 修改：   # listener.ora Network Configuration File: D:\oracl\product\11.2.0\dbhome_1\network\admin\listener.ora # Generated by Oracle configuration tools. SID_LIST_LISTENER = (SID_LIST = (SID_DESC = (SID_NAME = CLRExtProc) (ORACLE_HOME = D:\oracle\product\11.2.0\dbhome_1) (PROGRAM = extproc) (ENVS = “EXTPROC_DLLS=ONLY:D:\oracle\product\11.2.0\dbhome_1\bin\oraclr11.dll”) ) (SID_DESC = (GLOBAL_DBNAME = JTW) (ORACLE_HOME = D:\oracle\product\11.2.0\dbhome_1) (SID_NAME = JTW) ) ) LISTENER = (DESCRIPTION_LIST = (DESCRIPTION = (ADDRESS = (PROTOCOL = IPC)(KEY = EXTPROC1521)) (ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521)) ) )   红色部分为新添加内容，JTW为监听的实例名 然后修改(添加)instantclient_11_2\network\admin\tnsnames.ora</p>
<p><strong>[plain]</strong></p>
<ol>
<li>MyOracle =</li>
<li>(DESCRIPTION =</li>
<li>(ADDRESS = (PROTOCOL = TCP)(HOST = localhost)(PORT = 1521))</li>
<li>(CONNECT_DATA =</li>
<li>(SERVER = DEDICATED)</li>
<li>(SERVICE_NAME = jtw)</li>
<li>)</li>
<li>)</li>
</ol>
<p>重启Oracle监听 即可。</p>

            
            <p class="more">
                <a href="/2015/10/30/2019030500123/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/10/30/2019030500123/" title="ORA-12514: TNS:监听程序当前无法识别连接描述符中请求的服务">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/0.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/10/28/2019030500052/">
    		Linux下快速安装MongoDB
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-10-28T04:54:47.000Z">2015-10-28</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MongoDB/" title="MongoDB">MongoDB</a> / 
    
        <a href="/tags/Database/" title="Database">Database</a> / 
    
        <a href="/tags/dba/" title="dba">dba</a> / 
    
        <a href="/tags/NoSQL/" title="NoSQL">NoSQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>Mongo DB 是目前在IT行业非常流行的一种非关系型数据库(NoSql),其灵活的数据存储方式备受当前IT从业人员的青睐。Mongo DB很好的实现了面向对象的思想(OO思想),在Mongo DB中 每一条记录都是一个Document对象。Mongo DB最大的优势在于所有的数据持久操作都无需开发人员手动编写SQL语句,直接调用方法就可以轻松的实现CRUD操作。本文介绍了如何快速安装mongodb供大家参考。 一、安装配置mongodb Step 1: 设置系统环境及确保缺省端口27107可用 ###当前环境 # cat /etc/issue Red Hat Enterprise Linux Server release 6.5 (Santiago) # vi /etc/selinux/config SELINUX=disabled Step 2: 下载安装文件 下载地址： <a href="https://www.mongodb.org/downloads" target="_blank" rel="noopener">https://www.mongodb.org/downloads</a>. 或者直接在命令提示符下使用curl命令下载 curl -O <a href="https://fastdl.mongodb.org/linux/mongodb-linux-x86\_64-3.0.6.tgz" target="_blank" rel="noopener">https://fastdl.mongodb.org/linux/mongodb-linux-x86\_64-3.0.6.tgz</a> Step 3: 解压下载的文件 # pwd /usr/local/src # tar -xvf mongodb-linux-x86_64-rhel62-3.0.6.gz  ###注，本文直接从网站下载，所以文件为.gz Step 4: 复制解压文件到运行目录 # mkdir -p /var/lib/mongodb # cp -R -n /usr/local/src/mongodb-linux-x86_64-rhel62-3.0.6/. /var/lib/mongodb/ Step 5: 设置环境变量 e.g. export PATH=<mongodb-install-directory>/bin:$PATH # vi ~/.bash_profile export PATH=/var/lib/mongodb/bin:$PATH # source ~/.bash_profile Step 6: 创建数据目录 # mkdir -p /data/mongodata 二、启动及验证mongodb ###启动mongo # mongod –dbpath /data/mongodata ###以下内容为启动后输出的相关信息 2015-10-28T10:03:33.100+0800 I JOURNAL  [initandlisten] journal dir=/data/mongodata/journal 2015-10-28T10:03:33.101+0800 I JOURNAL  [initandlisten] recover : no journal files present, no recovery needed 2015-10-28T10:03:33.264+0800 I JOURNAL  [initandlisten] preallocateIsFaster=true 2.18 2015-10-28T10:03:33.398+0800 I JOURNAL  [durability] Durability thread started 2015-10-28T10:03:33.398+0800 I JOURNAL  [journal writer] Journal writer thread started 2015-10-28T10:03:33.401+0800 I CONTROL  [initandlisten] MongoDB starting : pid=10191 port=27017 dbpath=/data/mongodata 64-bit host=java_2 2015-10-28T10:03:33.401+0800 I CONTROL  [initandlisten] <strong> WARNING: You are running this process as the root user, which is not recommended. 2015-10-28T10:03:33.401+0800 I CONTROL  [initandlisten] 2015-10-28T10:03:33.402+0800 I CONTROL  [initandlisten] 2015-10-28T10:03:33.402+0800 I CONTROL  [initandlisten] </strong> WARNING: /sys/kernel/mm/transparent_hugepage/enabled is ‘always’. 2015-10-28T10:03:33.402+0800 I CONTROL  [initandlisten] <strong>        We suggest setting it to ‘never’ 2015-10-28T10:03:33.402+0800 I CONTROL  [initandlisten] 2015-10-28T10:03:33.402+0800 I CONTROL  [initandlisten] </strong> WARNING: /sys/kernel/mm/transparent_hugepage/defrag is ‘always’. 2015-10-28T10:03:33.402+0800 I CONTROL  [initandlisten] <strong>        We suggest setting it to ‘never’ 2015-10-28T10:03:33.402+0800 I CONTROL  [initandlisten] 2015-10-28T10:03:33.402+0800 I CONTROL  [initandlisten] db version v3.0.6 2015-10-28T10:03:33.402+0800 I CONTROL  [initandlisten] git version: 1ef45a23a4c5e3480ac919b28afcba3c615488f2 2015-10-28T10:03:33.402+0800 I CONTROL  [initandlisten] build info: Linux ip-10-67-194-123 2.6.32-220.el6.x86_64 #1 SMP Wed Nov 9 08:03:13 EST 2011 x86_64 BOOST_LIB_VERSION=1_49 2015-10-28T10:03:33.402+0800 I CONTROL  [initandlisten] allocator: tcmalloc 2015-10-28T10:03:33.402+0800 I CONTROL  [initandlisten] options: { storage: { dbPath: “/data/mongodata” } } 2015-10-28T10:03:33.404+0800 I INDEX    [initandlisten] allocating new ns file /data/mongodata/local.ns, filling with zeroes… 2015-10-28T10:03:33.491+0800 I STORAGE  [FileAllocator] allocating new datafile /data/mongodata/local.0, filling with zeroes… 2015-10-28T10:03:33.491+0800 I STORAGE  [FileAllocator] creating directory /data/mongodata/_tmp 2015-10-28T10:03:33.497+0800 I STORAGE  [FileAllocator] done allocating datafile /data/mongodata/local.0, size: 64MB,  took 0.001 secs 2015-10-28T10:03:33.511+0800 I NETWORK  [initandlisten] waiting for connections on port 27017 ###停止mongo，直接使用ctrl + c ^C2015-10-28T10:09:21.510+0800 I CONTROL  [signalProcessingThread] got signal 2 (Interrupt), will terminate after current cmd ends 2015-10-28T10:09:21.511+0800 I CONTROL  [signalProcessingThread] now exiting 2015-10-28T10:09:21.511+0800 I NETWORK  [signalProcessingThread] shutdown: going to close listening sockets… 2015-10-28T10:09:21.511+0800 I NETWORK  [signalProcessingThread] closing listening socket: 5 2015-10-28T10:09:21.511+0800 I NETWORK  [signalProcessingThread] closing listening socket: 6 2015-10-28T10:09:21.511+0800 I NETWORK  [signalProcessingThread] removing socket file: /tmp/mongodb-27017.sock 2015-10-28T10:09:21.511+0800 I NETWORK  [signalProcessingThread] shutdown: going to flush diaglog… 2015-10-28T10:09:21.511+0800 I NETWORK  [signalProcessingThread] shutdown: going to close sockets… 2015-10-28T10:09:21.512+0800 I STORAGE  [signalProcessingThread] shutdown: waiting for fs preallocator… 2015-10-28T10:09:21.512+0800 I STORAGE  [signalProcessingThread] shutdown: final commit… 2015-10-28T10:09:21.512+0800 I JOURNAL  [signalProcessingThread] journalCleanup… 2015-10-28T10:09:21.512+0800 I JOURNAL  [signalProcessingThread] removeJournalFiles 2015-10-28T10:09:21.515+0800 I JOURNAL  [signalProcessingThread] Terminating durability thread … 2015-10-28T10:09:21.615+0800 I JOURNAL  [journal writer] Journal writer thread stopped 2015-10-28T10:09:21.615+0800 I JOURNAL  [durability] Durability thread stopped 2015-10-28T10:09:21.615+0800 I STORAGE  [signalProcessingThread] shutdown: closing all files… 2015-10-28T10:09:21.618+0800 I STORAGE  [signalProcessingThread] closeAllFiles() finished 2015-10-28T10:09:21.618+0800 I STORAGE  [signalProcessingThread] shutdown: removing fs lock… 2015-10-28T10:09:21.618+0800 I CONTROL  [signalProcessingThread] dbexit:  rc: 0 ###修复启动过程中的两个警告，关于使用root用户启动mongo的警告先忽略 # echo “never” &gt; /sys/kernel/mm/transparent_hugepage/enabled # echo “never” &gt; /sys/kernel/mm/transparent_hugepage/defrag ###再次重启，后置于后台进程， # mongod –dbpath /data/mongodata &amp; ###查看启动后的进程 # ps -ef|grep mongo |grep -v grep root     11115 27956  0 10:11 pts/2    00:00:00 mongod –dbpath /data/mongodata # lsof -i:27017 COMMAND   PID USER   FD   TYPE   DEVICE SIZE/OFF NODE NAME mongod  11115 root    5u  IPv4 50567119      0t0  TCP *:27017 (LISTEN) ###使用mongo连接到mongod # mongo MongoDB shell version: 3.0.6 connecting to: test 2015-10-28T10:14:30.685+0800 I NETWORK  [initandlisten] connection accepted from 127.0.0.1:53907 #1 (1 connection now open) Server has startup warnings: 2015-10-28T10:11:49.217+0800 I CONTROL  [initandlisten] </strong> WARNING: You are running this process as the root user, which is not recommended. 2015-10-28T10:11:49.217+0800 I CONTROL  [initandlisten] &gt; help db.help()                    help on db methods db.mycoll.help()             help on collection methods sh.help()                    sharding helpers rs.help()                    replica set helpers help admin                   administrative help help connect                 connecting to a db help help keys                    key shortcuts help misc                    misc things to know help mr                      mapreduce show dbs                     show database names show collections             show collections in current database show users                   show users in current database show profile                 show most recent system.profile entries with time &gt;= 1ms show logs                    show the accessible logger names show log [name]              prints out the last segment of log in memory, ‘global’ is default use &lt;db_name&gt;                set current database db.foo.find()                list objects in collection foo db.foo.find( { a : 1 } )     list objects in foo where a == 1 it                           result of the last line evaluated; use to further iterate DBQuery.shellBatchSize = x   set default number of items to display on shell exit                         quit the mongo shell &gt; db.getCollection(“version”); test.version &gt; exit bye 三、mongodb相关工具 ###在安装文件下有README，描述了常用的mongodb相关命令行工具 # more /usr/local/mongodb/README MongoDB README Welcome to MongoDB! COMPONENTS bin/mongod - The database process. bin/mongos - Sharding controller. bin/mongo  - The database shell (uses interactive javascript). UTILITIES bin/mongodump         - MongoDB dump tool - for backups, snapshots, etc.. bin/mongorestore      - MongoDB restore a dump bin/mongoexport       - Export a single collection to test (JSON, CSV) bin/mongoimport       - Import from JSON or CSV bin/mongofiles        - Utility for putting and getting files from MongoDB GridFS bin/mongostat         - Show performance statistics RUNNING For command line options invoke: $ ./mongod –help To run a single server database: $ mkdir /data/db $ ./mongod $ $ # The mongo javascript shell connects to localhost and test database by default: $ ./mongo &gt; help DRIVERS Client drivers for most programming languages are available at mongodb.org.  Use the shell (“mongo”) for administrative tasks. ###获取单个命令用法 # <command> –help # mongod –help|more Options: General options: -h [ –help ]               show this usage information –version                   show version information # mongod –version db version v3.0.6 git version: 1ef45a23a4c5e3480ac919b28afcba3c615488f2</mongodb-install-directory></p>

            
            <p class="more">
                <a href="/2015/10/28/2019030500052/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/10/28/2019030500052/" title="Linux下快速安装MongoDB">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/8.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/10/28/2019030500154/">
    		Spring集成MongoDB
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-10-28T04:50:04.000Z">2015-10-28</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MongoDB/" title="MongoDB">MongoDB</a> / 
    
        <a href="/tags/Spring/" title="Spring">Spring</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <h2 id="开篇"><a href="#开篇" class="headerlink" title="开篇"></a>开篇</h2><pre><code>Spring提供了对非关系数据库的集成，Spring的spring-data包提供了对mongoDB和redis集成的工具包。此篇博客介绍一下Spring和MongoDB的集成。
</code></pre><h2 id="导入工具包"><a href="#导入工具包" class="headerlink" title="导入工具包"></a>导入工具包</h2><pre><code>需要的工具包有spring的jar包、spring-common的jar包以及spring-data的mongoDB的jar包。
其中，
spring的jar包有aop、asm、aspects、beans、context、core、expression、jdbc、transaction等。
spring-common的jar包有commons-beanutils、commons-codec、commons-collections、commons-io、commons-lang、commons-logging、commons-pool等。
spring-data的mongoDB的jar包有spring-data-commons-aspects、spring-data-commons-core、spring-data-document-core、spring-data-mongodb、spring-data-mongodb-cross-store、spring-data-mongodb-log4j等。
另外还有一个是mongo.jar
</code></pre><h2 id="工具包截图"><a href="#工具包截图" class="headerlink" title="工具包截图"></a>工具包截图</h2><p><img src="http://img.blog.csdn.net/20151028115904114" alt="这里写图片描述"></p>
<h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;beans xmlns=&quot;http://www.springframework.org/schema/beans&quot;  
          xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;  
          xmlns:context=&quot;http://www.springframework.org/schema/context&quot;  
          xmlns:mongo=&quot;http://www.springframework.org/schema/data/mongo&quot;  
          xsi:schemaLocation=&quot;http://www.springframework.org/schema/context   
          http://www.springframework.org/schema/context/spring-context-3.0.xsd   
          http://www.springframework.org/schema/data/mongo   
          http://www.springframework.org/schema/data/mongo/spring-mongo-1.0.xsd   
          http://www.springframework.org/schema/beans   
          http://www.springframework.org/schema/beans/spring-beans-3.0.xsd&quot;&gt;   

        &lt;mongo:mongo host=&quot;192.168.0.138&quot; port=&quot;27017&quot;/&gt;



       &lt;bean id=&quot;mongoTemplate&quot; class=&quot;org.springframework.data.document.mongodb.MongoTemplate&quot;&gt;   
        &lt;constructor-arg ref=&quot;mongo&quot;/&gt;   
        &lt;constructor-arg name=&quot;databaseName&quot; value=&quot;db&quot;/&gt;   
        &lt;constructor-arg name=&quot;defaultCollectionName&quot; value=&quot;person&quot; /&gt;   
      &lt;/bean&gt;   

     &lt;bean id=&quot;personRepository&quot; class=&quot;com.mongo.dao.impl.PersonRepository&quot;&gt;   
        &lt;property name=&quot;mongoTemplate&quot; ref=&quot;mongoTemplate&quot;&gt;&lt;/property&gt;   
    &lt;/bean&gt;   

     &lt;context:annotation-config /&gt;

&lt;/beans&gt; 
</code></pre><h2 id="代码编写"><a href="#代码编写" class="headerlink" title="代码编写"></a>代码编写</h2><p>实体类：</p>
<pre><code>public class Person implements Serializable {

    /**
     * 
     */
    private static final long serialVersionUID = 3617931430808763429L;

    private String id;   
    private String name;   
    private int age;
    public Person() {
        super();
    }
    public Person(String id, String name, int age) {
        super();
        this.id = id;
        this.name = name;
        this.age = age;
    }
    /**
     * @return the id
     */
    public String getId() {
        return id;
    }
    /**
     * @param id the id to set
     */
    public void setId(String id) {
        this.id = id;
    }
    /**
     * @return the name
     */
    public String getName() {
        return name;
    }
    /**
     * @param name the name to set
     */
    public void setName(String name) {
        this.name = name;
    }
    /**
     * @return the age
     */
    public int getAge() {
        return age;
    }
    /**
     * @param age the age to set
     */
    public void setAge(int age) {
        this.age = age;
    }
    /**
     * 
     * @param name
     * @param age
     */
    public Person(String name, int age) {
        super();
        this.name = name;
        this.age = age;
    }   

     public String toString() {   
            return &quot;Person[id=&quot;+id+&quot;,name=&quot;+name+&quot;,age=&quot;+age+&quot;]&quot;;   
        }   


}
</code></pre><p>DAO层接口</p>
<pre><code>public interface AbstractRepository {


    public void insert(Person person); 


    public Person findOne(String id);   

    public List&lt;Person&gt; findAll();   

    public List&lt;Person&gt; findByRegex(String regex);

    public void removeOne(String id);   

    public void removeAll();   

    public void findAndModify(String id);   


}
</code></pre><p>DAO层接口实现</p>
<pre><code>public class PersonRepository implements AbstractRepository {

      private MongoTemplate mongoTemplate;   


    @Override
    public List&lt;Person&gt; findAll() {
        return getMongoTemplate().find(new Query(), Person.class);   

    }


    @Override
    public void findAndModify(String id) {

        getMongoTemplate().updateFirst(new Query(Criteria.where(&quot;id&quot;).is(id)), new Update().inc(&quot;age&quot;, 3));

    }


    @Override
    public List&lt;Person&gt; findByRegex(String regex) {
         Pattern pattern = Pattern.compile(regex,Pattern.CASE_INSENSITIVE);   
          Criteria criteria = new Criteria(&quot;name&quot;).regex(pattern.toString());   
            return getMongoTemplate().find(new Query(criteria), Person.class);   

    }


    @Override
    public Person findOne(String id) {
         return getMongoTemplate().findOne(new Query(Criteria.where(&quot;id&quot;).is(id)), Person.class);   

    }


    @Override
    public void insert(Person person) {
        getMongoTemplate().insert(person);   
    }


    @Override
    public void removeAll() {
        List&lt;Person&gt; list = this.findAll();   
        if(list != null){   
            for(Person person : list){   
                getMongoTemplate().remove(person);   
            }   
        }   

    }


    @Override
    public void removeOne(String id) {
        Criteria criteria = Criteria.where(&quot;id&quot;).in(id);   
        if(criteria == null){   
             Query query = new Query(criteria);   
             if(query != null &amp;&amp; getMongoTemplate().findOne(query, Person.class) != null)   
                 getMongoTemplate().remove(getMongoTemplate().findOne(query, Person.class));   
        }   

    }

    /**
     * @return the mongoTemplate
     */
    public MongoTemplate getMongoTemplate() {
        return mongoTemplate;
    }

    /**
     * @param mongoTemplate the mongoTemplate to set
     */
    public void setMongoTemplate(MongoTemplate mongoTemplate) {
        this.mongoTemplate = mongoTemplate;
    }

}
测试程序
public class MongoTest {

    private static Log log = LogFactory.getLog(MongoTest.class.getName());

    private  AbstractRepository pr=null;


    public void init(){

         ApplicationContext ctx = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);
          pr= (PersonRepository)ctx.getBean(&quot;personRepository&quot;);



    }

    public void insert(){

        Person p=new Person(&quot;cuiran&quot;,27);
         pr.insert(p);
    }

    public void findOne(){
        String id=&quot;50c83cb552c2ceb0463177d6&quot;;
        Person p= pr.findOne(id);
        log.debug(p);
    }



    public void listAll(){

        List&lt;Person&gt; list=pr.findAll();

        for (Person p:list){
            log.debug(p.toString());
        }


    }


    public void start(){
        init();

        //insert();
        //listAll();

        findOne();
    }

    public static void main(String[] args) {
        MongoTest t=new MongoTest();
        t.start();
    }

}
</code></pre><h2 id="结束"><a href="#结束" class="headerlink" title="结束"></a>结束</h2><pre><code>通过Spring集成MongoDB的底层代码封装，项目中用到非关系型数据MongoDB存储就变得容易很多。
</code></pre>
            
            <p class="more">
                <a href="/2015/10/28/2019030500154/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/10/28/2019030500154/" title="Spring集成MongoDB">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/8.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/10/15/2019030500144/">
    		Oracle MySql SqlServer分页查询
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-10-15T15:14:25.000Z">2015-10-15</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a> / 
    
        <a href="/tags/sqlserver/" title="sqlserver">sqlserver</a> / 
    
        <a href="/tags/分页查询/" title="分页查询">分页查询</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p><strong>SQL Server</strong> 从数据库表中的第M条记录开始取N条记录，利用Top关键字：注意如果Select语句中既有top，又有order by，则是从排序好的结果集中选择：</p>
<ol>
<li>SELECT *</li>
<li>FROM  ( SELECT Top N *</li>
<li>FROM    (SELECT Top (M + N - 1) * FROM 表名称 Order by 主键 desc) t1 ) t2</li>
<li><p>Order by 主键 asc</p>
<p>例如从表Sys_option（主键为sys_id)中从10条记录还是检索20条记录，语句如下：</p>
</li>
<li><p>SELECT *</p>
</li>
<li>FROM ( SELECT TOP 20 *</li>
<li>FROM (SELECT TOP 29 * FROM Sys_option order by sys_id desc) t1) t2</li>
<li><p>Order by sys_id asc</p>
<p><strong> Oralce数据库</strong> 从数据库表中第M条记录开始检索N条记录</p>
</li>
<li><p>SELECT *</p>
</li>
<li>FROM (SELECT ROWNUM r,t1.* From 表名称 t1 where rownum &lt; M + N) t2</li>
<li>where t2.r &gt;= M</li>
</ol>
<p>例如从表Sys_option（主键为sys_id)中从10条记录还是检索20条记录，语句如下：</p>
<ol>
<li>SELECT *</li>
<li>FROM (SELECT ROWNUM R,t1.* From Sys_option where rownum &lt; 30 ) t2</li>
<li>Where t2.R &gt;= 10</li>
</ol>
<p><strong>My sql数据库</strong> My sql数据库最简单，是利用mysql的LIMIT函数,LIMIT [offset,] rows从数据库表中M条记录开始检索N条记录的语句为：</p>
<ol>
<li><p>SELECT * FROM 表名称 LIMIT M,N</p>
<p>例如从表Sys_option（主键为sys_id)中从10条记录还是检索20条记录，语句如下：</p>
</li>
<li><p>select * from sys_option limit 10,20</p>
</li>
</ol>

            
            <p class="more">
                <a href="/2015/10/15/2019030500144/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/10/15/2019030500144/" title="Oracle MySql SqlServer分页查询">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/5.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/10/15/2019030500140/">
    		Oracle联合索引
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-10-15T15:10:42.000Z">2015-10-15</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a> / 
    
        <a href="/tags/sql优化/" title="sql优化">sql优化</a> / 
    
        <a href="/tags/联合索引/" title="联合索引">联合索引</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>我现在用的是oracle 1.一个表建立多少个索引比较合适？比如说不大于5个 这个没有定论，楼主要综合查询效率和dml效率自己确定，索引可以加快select的查询速度，但也会降低delete，insert和update等dml语句的执行速度。 2.联合索引比单索引的效率高么？ 如果联合索引中的多个字段都在where谓词中出现了，则联合索引效率比单列索引高，因为通过多个条件可以从索引中过滤得到更少的记录条数，也就减少了需要回表扫描的次数，甚至可以直接在联合索引中得到所查的所有结果，则不再需要回表。 但是由于多列的联合索引肯定要比单列索引大，也就是说同样的索引需要存储的物理块要多于单列索引，所以，如果查询中只出现了联合索引中的某一列，则其效率不如单列索引。 3.compress 这个压缩 ，能起到什么作用？ 没研究过 4.上网上查资料时，都说oracle使用联合索引需要前导列，这个和版本有关系吗？ 前导列跟版本没有关系。 前导列的概念是这样的，如果建立了f1，f2上的联合索引，则在查询时必须要用到f1，也就是所谓的前导列，该索引才会有效，因为索引是按照前导列排序的，如果where条件谓词中没有前导列，则需要执行索引扫描才能得到想要的结果，这种情况下其效率往往较差。 5.如果不需要前导列的话，reverse 这个反转 又起到什么作用呢？ 鉴于前面描述的前导列的概念，我们考虑如下表存储table(f1,f2); aa  1 ab  2 ac  3 ad  4 ae  5 如果我们对表table建立f1上的普通索引，由于按照f1进行排序，所以针对where f1=ad则需要遍历所有的a开始的索引，而如果对f1建立reverse索引，则由于da只有一个，则可以更快的得到需要的结果。</p>

            
            <p class="more">
                <a href="/2015/10/15/2019030500140/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/10/15/2019030500140/" title="Oracle联合索引">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/5.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/10/12/2019030500112/">
    		MySQL EXPLAIN SQL 输出信息描述
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-10-12T04:41:26.000Z">2015-10-12</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/SQL/" title="SQL">SQL</a> / 
    
        <a href="/tags/EXPLAIN/" title="EXPLAIN">EXPLAIN</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>EXPLAIN语句能够被用于获取一些关于SQL执行时的相关信息，比如表的连接顺序，对表的方式方式等等。通过对该相关信息进行进一步的分析，我们    可以通过对表添加适当的索引，以及优化连接顺序，使用提示等等手段来达到使SQL高效运行的目的。本文描述了EXPLAIN的用法并给出了相关示例。 一、EXPLAIN概述 EXPLAIN 语句主要是用于解析SQL执行计划，通过分析执行计划采取适当的优化方式提高SQL运行的效率。EXPLAIN 语句输出通常包括id列，select_type，table，type，possible_keys，key等等列信息MySQL 5.6.3后支持SELECT, DELETE, INSERT,REPLACE, and UPDATE. EXPLAIN EXTENDED支持一些额外的执行计划相关的信息EXPLAIN PARTITIONS支持基于分区表查询执行计划的相关信息 二、EXPLAIN输出列描述 – 下面通过示例来展示EXPLAIN输出列(root@localhost) [sakila]&gt; explain select sum(amount) from customer a,    -&gt; payment b where 1=1 and a.customer_id=b.customer_id and    -&gt; <a href="mailto:email=&#39;JANE.BENNETT@sakilacustomer.org" target="_blank" rel="noopener">email=&#39;JANE.BENNETT@sakilacustomer.org</a>‘\G<strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong>           id: 1  select_type: SIMPLE        table: a         type: ALLpossible_keys: PRIMARY          key: NULL      key_len: NULL          ref: NULL         rows: 590        Extra: Using where<strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 2. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong>           id: 1  select_type: SIMPLE        table: b         type: refpossible_keys: idx_fk_customer_id          key: idx_fk_customer_id      key_len: 2          ref: sakila.a.customer_id         rows: 14        Extra: 1、各列表示的意义 Column        Meaning——        ————————————id            The SELECT identifier                       select_type   The SELECT typetable         The table for the output rowpartitions    The matching partitionstype          The join typepossible_keys The possible indexes to choosekey           index actually chosenkey_len       The length of the chosen keyref           The columns compared to the indexrows          Estimate of rows to be examinedfiltered      Percentage of rows filtered by table conditionExtra         Additional information 2、各列上的具体描述 id：    包含一组数字，表示查询中执行select子句或操作表的顺序    id相同，执行顺序由上至下，否则id值越大(通常子查询会产生)优先级越高，越先被执行    id如果相同，可以认为是一组，从上往下顺序执行；在所有组中，id值越大，优先级越高，越先执行 select_type:      表示查询中每个select子句的类型（简单 OR复杂）    select_type              Value Meaning    ————-            ———————————————–    SIMPLE                   Simple SELECT (not using UNION or subqueries)    PRIMARY                  Outermost SELECT 最外层select    UNION                    Second or later SELECT statement in a UNION    DEPENDENT UNION          Second or later SELECT statement in a UNION, dependent on outer query    UNION                    RESULT Result of a UNION.    SUBQUERY                 First SELECT in subquery    DEPENDENT SUBQUERY       First SELECT in subquery, dependent on outer query(通常为相关子查询)    DERIVED                  Derived table SELECT (subquery in FROM clause)    MATERIALIZED             Materialized subquery    UNCACHEABLE SUBQUERY     A subquery for which the result cannot be cached and must be reevaluated                             for each row of the outer query    UNCACHEABLE UNION        The second or later select in a UNION that belongs to an uncacheable                             subquery (see UNCACHEABLE SUBQUERY)    table：      从哪个表(表名)上输出行记录，也可能是下列值:     • &lt;unionM,N&gt;: The row refers to the union of the rows with id values of M and N.    • <derivedn>: The row refers to the derived table result for the row with an id value of N.                   A derived table may result, for example, from a subquery in the FROM clause.    • <subqueryn>: The row refers to the result of a materialized subquery for the row with an id value of N.  partitions:     查询匹配的记录来自哪一个分区，当使用EXPLAIN，分区PARTITIONS关键字被指定时 type：    连接类型    system          表只有一行    const           表最多只有一行匹配，通用用于主键或者唯一索引比较时    eq_ref          每次与之前的表合并行都只在该表读取一行，这是除了system，const之外最好的一种，                    特点是使用=，而且索引的所有部分都参与join且索引是主键或非空唯一键的索引    ref             如果每次只匹配少数行，那就是比较好的一种，使用=或&lt;=&gt;，可以是左覆盖索引或非主键或非唯一键    fulltext        全文搜索    ref_or_null     与ref类似，但包括NULL    index_merge     表示出现了索引合并优化(包括交集，并集以及交集之间的并集)，但不包括跨表和全文索引。                    这个比较复杂，目前的理解是合并单表的范围索引扫描（如果成本估算比普通的range要更优的话）    unique_subquery 在in子查询中，就是value in (select…)把形如“select unique_key_column”的子查询替换。                    PS：所以不一定in子句中使用子查询就是低效的！    index_subquery  同上，但把形如”select non_unique_key_column“的子查询替换    range           常数值的范围    index           a.当查询是索引覆盖的，即所有数据均可从索引树获取的时候（Extra中有Using Index）；                    b.以索引顺序从索引中查找数据行的全表扫描（无 Using Index）；                    c.如果Extra中Using Index与Using Where同时出现的话，则是利用索引查找键值的意思；                    d.如单独出现，则是用读索引来代替读行，但不用于查找    all             全表扫描 possible_keys：    指出MySQL能使用哪个索引在表中找到行。    查询涉及到的字段上若存在索引则该索引将被列出，但不一定被查询使用。    如果改列为NULL，说明该查询不会使用到当前表上的相关索引，考虑是否有必要添加索引key    显示MySQL在查询中实际使用的索引，若没有使用索引，显示为NULL    也可能存在key不等于possible_keys的情形，即possible_keys不适合提取所需的行    而查询所选择的列在使用其他索引时更高效    TIPS：查询中若使用了覆盖索引，则该索引仅出现在key列表中 key_len    表示索引中使用的字节数，可通过该列计算查询中使用的索引的长度 ref    表示上述表的连接匹配条件，即哪些列或常量被用于查找索引列上的值rows    表示MySQL根据表统计信息及索引选用情况，估算的找到所需的记录所需要读取的行数    对于InnoDB，该值为预估，不一定精确 Extra    包含不适合在其他列中显示但十分重要的额外信息 三、使用EXPLAIN EXTENDED 示例 (root@localhost) [sakila]&gt; explain extended select <em> from city where country_id in    -&gt; ( select country_id from country where country=’China’) and 1=1 \G<strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong>           id: 1  select_type: SIMPLE        table: country         type: ALLpossible_keys: PRIMARY          key: NULL      key_len: NULL          ref: NULL         rows: 109     filtered: 100.00        Extra: Using where<strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 2. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong>           id: 1  select_type: SIMPLE        table: city         type: refpossible_keys: idx_fk_country_id          key: idx_fk_country_id      key_len: 2          ref: sakila.country.country_id         rows: 1     filtered: 100.00        Extra: NULL2 rows in set, 1 warning (0.00 sec) (root@localhost) [sakila]&gt; show warnings\G<strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong>  Level: Note   Code: 1003Message: /<em> select#1 </em>/ select `city`.`city_id` AS `city_id`,`city`.`city` AS `city`,`city`.`country_id` AS `country_id`,`city`.`last_update` AS `last_update` from `sakila`.`country` join `sakila`.`city` where ((`city`.`country_id` = `country`.`country_id`) and (`country`.`country` = ‘China’))1 row in set (0.00 sec) – 从上面的extended使用可以看出，查询中多出了filtered列– 其次原来的SQL语句真正在执行的时候被改写，即原来的1=1的条件被去掉– 对于复杂的SQL语句我们可以通过该方式获得一个比较清晰的真正被执行的SQL语句 四、EXPLAIN PARTITIONS示例 (root@localhost) [sakila]&gt; CREATE TABLE `actor_part` (    -&gt;   `actor_id` smallint(5) unsigned NOT NULL AUTO_INCREMENT,    -&gt;   `first_name` varchar(45) NOT NULL,    -&gt;   `last_name` varchar(45) NOT NULL,    -&gt;   `last_update` timestamp NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP,    -&gt;   PRIMARY KEY (`actor_id`),    -&gt;   KEY `idx_actor_last_name` (`last_name`)    -&gt; ) partition by hash(actor_id) partitions 4;Query OK, 0 rows affected (0.11 sec) (root@localhost) [sakila]&gt; insert into actor_part select <em> from actor;Query OK, 200 rows affected (0.02 sec)Records: 200  Duplicates: 0  Warnings: 0(root@localhost) [sakila]&gt; explain select </em> from actor_part where actor_id=10;  – 未使用partitions时+—-+————-+————+——-+—————+———+———+——-+——+——-+| id | select_type | table      | type  | possible_keys | key     | key_len | ref   | rows | Extra |+—-+————-+————+——-+—————+———+———+——-+——+——-+|  1 | SIMPLE      | actor_part | const | PRIMARY       | PRIMARY | 2       | const |    1 | NULL  |+—-+————-+————+——-+—————+———+———+——-+——+——-+1 row in set (0.00 sec) (root@localhost) [sakila]&gt; explain partitions select * from actor_part where actor_id=10; – 使用partitions时+—-+————-+————+————+——-+—————+———+———+——-+——+——-+| id | select_type | table      | partitions | type  | possible_keys | key     | key_len | ref   | rows | Extra |+—-+————-+————+————+——-+—————+———+———+——-+——+——-+|  1 | SIMPLE      | actor_part | p2         | const | PRIMARY       | PRIMARY | 2       | const |    1 | NULL  |+—-+————-+————+————+——-+—————+———+———+——-+——+——-+1 row in set (0.00 sec)– 多出了partitions列</subqueryn></derivedn></p>

            
            <p class="more">
                <a href="/2015/10/12/2019030500112/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/10/12/2019030500112/" title="MySQL EXPLAIN SQL 输出信息描述">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/10/08/2019030500126/">
    		Oracle中查询、禁用、启用、删除表外键
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-10-08T09:57:21.000Z">2015-10-08</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a> / 
    
        <a href="/tags/外键/" title="外键">外键</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>1、查询所有表的外键：</p>
<p><strong>[sql]</strong></p>
<ol>
<li>select table_name, constraint_name from user_constraints where constraint_type = ‘R’;</li>
</ol>
<p>2、禁用所有外键约束, 使用下面的sql生成对应sql脚本:</p>
<p><strong>[sql]</strong></p>
<ol>
<li>select ‘alter table ‘ || table_name || ‘ disable constraint ‘ || constraint_name || ‘;’</li>
<li>from user_constraints</li>
<li>where constraint_type = ‘R’;</li>
</ol>
<p>生成的sql类似下面的语句：</p>
<p><strong>[sql]</strong></p>
<ol>
<li>alter table HRMIS_RELIC_DAMAGE disable constraint FK_HRMIS_RE_0927;</li>
<li>alter table HRMIS_RELIC_BASE disable constraint FK_HRMIS_RE_0922;</li>
</ol>
<p>3、启用所有外键约束, 使用下面的sql生成对应sql脚本:</p>
<p><strong>[sql]</strong></p>
<ol>
<li>select ‘alter table ‘ || table_name || ‘ enable constraint ‘ ||  constraint_name || ‘;’</li>
<li>from user_constraints</li>
<li>where constraint_type = ‘R’;</li>
</ol>
<p>生成的sql类似下面的语句：</p>
<p><strong>[sql]</strong></p>
<ol>
<li>alter table HRMIS_RELIC_DAMAGE enable constraint FK_HRMIS_RE_0927;</li>
<li>alter table HRMIS_RELIC_BASE enable constraint FK_HRMIS_RE_0922;</li>
</ol>
<p>4、删除所有外键约束, 使用下面的sql生成对应sql脚本:</p>
<p><strong>[sql]</strong></p>
<ol>
<li>select ‘alter table ‘ || table_name || ‘ drop constraint ‘ || constraint_name || ‘;’</li>
<li>from user_constraints</li>
<li>where constraint_type = ‘R’;</li>
</ol>
<p>生成的sql类似下面的语句：</p>
<p><strong>[sql]</strong></p>
<ol>
<li>alter table HRMIS_RELIC_DAMAGE drop constraint FK_HRMIS_RE_0927;</li>
<li>alter table HRMIS_RELIC_BASE drop constraint FK_HRMIS_RE_0922;</li>
</ol>

            
            <p class="more">
                <a href="/2015/10/08/2019030500126/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/10/08/2019030500126/" title="Oracle中查询、禁用、启用、删除表外键">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/8.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/22/2019030500009/">
    		使用消息系统避免分布式事务
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-22T02:17:09.000Z">2015-09-22</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/事务/" title="事务">事务</a> / 
    
        <a href="/tags/分布式/" title="分布式">分布式</a> / 
    
        <a href="/tags/消息/" title="消息">消息</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>首先举个例子：比如通过支付宝向余额宝转账1000元，这样一种生活中很平凡的事情，却可以引出很多问题：如果系统宕机挂掉，交易没有完成？那么数据就出现了不一致。等等类似的事情，在各类系统中都能找到类似情形。那么也可以换句专业的说法：当一个表update之后，如何保证另外一个与之关联的表也能完成update。 1、本地事务： 支付宝账户表：A  id uid amount 余额宝账户表：B  id uid amount 用户id：uid = 100 执行上面的过程分两部分： 1、支付宝账户表-1000：update A set amount=amount - 1000 where uid = 100； 2、余额宝账户表+1000：update B set amount=amount + 1000 where uid = 100； 如何保证两部分都能够完成，保证两部分“收支平衡” 对数据库熟悉的同学会那么我们使用transaction（事务）不就解决了 BEGIN TRANSACTION update A set amount=amount - 1000 where uid = 100； update B set amount=amount + 1000 where uid = 100； END TRANSACTION COMMIT; OK,上面的操作是没有问题的 那么对spring熟悉的同学也知道 其实在spring只需要使用注解就OK了 @Transactional(rollbackFor=Exception.class) public void updateAmount(){ updateA(); updateB(); } 是的，没有错的。能够完成。但是这些情况只是针对系统规模小，数据表在一个数据库实例上的；那么系统规模大，对应的数据表分布在不同的数据库实例上，分布在不同的物理节点上，前面采用的本地事务的方式就无用武之地了。 2、分布式事务（两阶段提交协议） 两阶段提交协议经常用来实现分布式事务;一般需要两个角色：协调器C和若干个事务执行者Si；那么事务执行者多半是具体的数据库，同时协调器和事务执行器可在一台机器上。 1、应用程序application发起一个请求到TC（事务协调器） 2、TC(事务协调器)将消息写到本地日志，再向所有的SI（事务执行者）的发送消息。 3、Si（事务执行者）接受到消息之后，执行本地事务但是不commit，如果成功返回yes否则no；同样返回      之前仍要进行日志记录。 4、Tc（事务协调器）接受到所有执行器返回的结果，如果所有的执行全部返回yes，那么发送commit消息给各个执行器，本地事务执行commit；若是有一个返回no，那么tc就会发送abort消息给各个执行器 注：tc和si把发送和接收到的消息存放到本地日志里，主要为了故障恢复复用，如若某一个si从故障中恢复后，先检查本地日志的内容，如果已接收到commit则本地事务执行器commit；若是abort，则回滚； 若是yes则在tc询问，确定下一步；若是什么都没有则可能前面执行已经崩溃，需要回滚。 熟悉java的同学可以看：<a href="http://acen-chen.iteye.com/blog/1055481" target="_blank" rel="noopener">http://acen-chen.iteye.com/blog/1055481</a> 采用分布式事务，也满足了我们前面的需求，同时新的问题随之而来 1、两阶段提交涉及多个节点的网络通信，通信时间如果过长 2、事务的相对时间长了，那么锁定资源的时间也就长了 那么在高并发的服务中，就会存在严重的性能问题。 3、消息队列 在高并发的环境中，我们一般会采用消息队列来避免分布式事务的执行 这和实际生活中，我们去饭店吃饭很类似，首先点单，这时服务员给你一张小票，等待服务器给你端上你的饭菜。 在使用消息队列我们需要做到可靠凭证的保存(分布式事务的消息)，有如下两种方式 方式1、支付宝完成扣钱的动作时，并记录消息数据，消息数据和业务数据在同一个数据库实例 BEGIN TRANSACTION update A set amount=amount - 1000 where uid = 100； INSERT INTO MESSAGE(UID，AMOUNT,STATUS) VALUES(1，1000，1) END TRANSACTION COMMIT; 那么我们可以将支付宝完成扣钱操作的消息通过及时服务发给余额宝，余额宝完成处理返回成功消息，支付宝收到消息，清除消息表中对应的消息记录，即完成本次扣钱操作。 方式2、 1）支付宝在扣款事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消       息数据，而不真正发送，只有消息发送成功后才会提交事务； 2）当支付宝扣款事务被提交成功后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才真正发送该消息； 3）当支付宝扣款事务提交失败回滚后，向实时消息服务取消发送。在得到取消发送指令后，该消息将不会被发送； 4）对于那些未确认的消息或者取消的消息，需要有一个消息状态确认系统定时去支付宝系统查询这个消息的状态并进行更新。为什么需要这一步骤，举个例子：假设在第2步支付宝扣款事务被成功提交后，系统挂了，此时消息状态并未被更新为“确认发送”，从而导致消息不能被发送。 优点：消息数据独立存储，降低业务系统与消息系统间的耦合； 缺点：一次消息发送需要两次请求；业务处理服务需要实现消息状态回查接口 ———————————————————————————————————————————— 那么如上的消息队列也就解决了我们实际业务中的高并发情况下分布式事务处理性能低下的问题 在使用消息队列防止重复投递消息 解决方法很简单，增加消息应用状态表（message_apply），通俗来说就是个账本，用于记录消息的消费情况，每次来一个消息，在真正执行之前，先去消息应用状态表中查询一遍，如果找到说明是重复消息，丢弃即可，如果没找到才执行，同时插入到消息应用状态表（同一事务）。 for each msg in queue Begin transaction select count(*) as cnt from message_apply where msg_id=msg.msg_id; if cnt==0 then update B set amount=amount+10000 where userId=1; insert into message_apply(msg_id) values(msg.msg_id); End transaction commit;</p>

            
            <p class="more">
                <a href="/2015/09/22/2019030500009/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/22/2019030500009/" title="使用消息系统避免分布式事务">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/21/2019030500075/">
    		mysql启动的四种方式
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-21T08:30:04.000Z">2015-09-21</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>在创建库的时候指定字符集 GBK: create database  database_name  DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci; UTF8: CREATE DATABASE `test2` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; 在创建表的时候你可以通过添加一个ENGINE 或TYPE 选项到CREATE TABLE语句来告诉MySQL你要创建什么类表并指定表的存储引擎： CREATE TABLE t (i INT) ENGINE = INNODB; CREATE TABLE t (i INT) TYPE = MEMORY; 要把一个表从一个类型转到另一个类型，可使用ALTER TABLE语句，这个语句指明新的类型： ALTER TABLE t ENGINE = MYISAM; ALTER TABLE t TYPE = BDB mysql 建表字符集 1.列出MYSQL支持的所有字符集： SHOW CHARACTER SET; 2.当前MYSQL服务器字符集设置 SHOW VARIABLES LIKE ‘character_set_%’; 3.当前MYSQL服务器字符集校验设置 SHOW VARIABLES LIKE ‘collation_%’; 4.显示某数据库字符集设置 show create database 数据库名; 5.显示某数据表字符集设置 show create table 表名; 6.修改数据库字符集 alter database 数据库名 default character set ‘utf8’; 7.修改数据表字符集 alter table 表名 default character set ‘utf8’; 8.建库时指定字符集 create database 数据库名 character set gbk collate gbk_chinese_ci; 9.建表时指定字符集 CREATE TABLE `mysqlcode` ( `id` TINYINT( 255 ) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY , `content` VARCHAR( 255 ) NOT NULL  <a href="http://www.2cto.com" target="_blank" rel="noopener">www.2cto.com</a> ) TYPE = MYISAM CHARACTER SET gbk COLLATE gbk_chinese_ci; 库字符集，在my.cnf中缺少了如下代码： [client] default-character-set=utf8 [mysqld] default-character-set=utf8 10.修改数据库的字符集 mysql&gt;use mydb mysql&gt;alter database mydb character set utf-8; 创建数据库指定数据库的字符集 mysql&gt;create database mydb character set utf-8; 通过配置文件修改: 修改/var/lib/mysql/mydb/db.opt default-character-set=latin1 default-collation=latin1_swedish_ci 为  <a href="http://www.2cto.com" target="_blank" rel="noopener">www.2cto.com</a> default-character-set=utf8 default-collation=utf8_general_ci 11.MySQL服务器能够支持多种字符集。可以使用SHOW CHARACTER SET语句列出可用的字符集： mysql&gt; SHOW CHARACTER SET; 如果不加以上代码，那么即便MYSQL编译安装时指定的编码是UTF8，那么在建库时其默认编码仍是LATIN1，而由于字符集的继承性，库中的表也是LATIN1的了。mysql的四种启动方式: 1、mysqld 启动mysql服务器:./mysqld –defaults-file=/etc/my.cnf –user=root 客户端连接: mysql –defaults-file=/etc/my.cnf or mysql -S /tmp/mysql.sock 2、mysqld_safe 启动mysql服务器:./mysqld_safe –defaults-file=/etc/my.cnf –user=root &amp; 客户端连接: mysql –defaults-file=/etc/my.cnf or mysql -S /tm/mysql.sock 3、mysql.server cp -v /usr/local/mysql/support-files/mysql.server /etc/init.d/ chkconfig –add mysql.server 启动mysql服务器:service mysql.server {start|stop|restart|reload|force-reload|status} 客户端连接:同1、2 4、mysqld_multi mkdir $MYSQL_BASE/data2 cat &lt;<-eof>&gt; /etc/my.cnf [mysqld_multi] mysqld    = /usr/local/mysql/bin/mysqld_safe mysqladmin = /user/local/mysql/bin/mysqladmin user = mysqladmin password = mysqladmin [mysqld3306] port            = 3306 socket          = /tmp/mysql3306.sock pid-file    = /tmp/mysql3306.pid skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M basedir        = /usr/local/mysql datadir        = /usr/local/mysql/data [mysqld3307] port            = 3307 socket          = /tmp/mysql3307.sock pid-file    = /tmp/mysql3307.pid skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M basedir        = /usr/local/mysql datadir        = /usr/local/mysql/data2 EOF #mysql -S /tmp/mysql3306.sock mysql&gt;GRANT SHUTDOWN ON <em>.</em> TO ‘mysqladmin‘@’localhost’ identified by ‘mysqladmin’ with grant option; #mysql -S /tmp/mysql3307.sock mysql&gt;GRANT SHUTDOWN ON <em>.</em> TO ‘mysqladmin‘@’localhost’ identified by ‘mysqladmin’ with grant option; 启动mysql服务器:./mysqld_multi –defaults-file=/etc/my.cnf start 3306-3307 关闭mysql服务器:mysqladmin shutdown</-eof></p>

            
            <p class="more">
                <a href="/2015/09/21/2019030500075/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/21/2019030500075/" title="mysql启动的四种方式">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/21/2019030500037/">
    		死锁的预防和解除
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-21T08:26:38.000Z">2015-09-21</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/死锁/" title="死锁">死锁</a> / 
    
        <a href="/tags/解除/" title="解除">解除</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>产生死锁的原因主要是： （1）系统资源不足。 （2） 进程运行推进的顺序不合适。 （3）资源分配不当等。 如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。 产生死锁的四个必要条件： （1） 互斥条件：一个资源每次只能被一个进程使用。 （2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 （3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 （4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 死锁的预防和解除： 理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源,在系统运行过程中，对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，若分配后系统可能发生死锁，则不予分配，否则予以分配 。因此，对资源的分配要给予合理的规划。 如何将死锁减至最少 虽然不能完全避免死锁，但可以使死锁的数量减至最少。将死锁减至最少可以增加事务的吞吐量并减少系统开销，因为只有很少的事务回滚，而回滚会取消事务执行的所有工作。由于死锁时回滚而由应用程序重新提交。 下列方法有助于最大限度地降低死锁： （1）按同一顺序访问对象。 （2）避免事务中的用户交互。 （3）保持事务简短并在一个批处理中。 （4）使用低隔离级别。 （5）使用绑定连接。 按同一顺序访问对象 如果所有并发事务按同一顺序访问对象，则发生死锁的可能性会降低。例如，如果两个并发事务获得 Supplier 表上的锁，然后获得 Part 表上的锁，则在其中一个事务完成之前，另一个事务被阻塞在 Supplier 表上。第一个事务提交或回滚后，第二个事务继续进行。不发生死锁。将存储过程用于所有的数据修改可以标准化访问对象的顺序。 避免事务中的用户交互 避免编写包含用户交互的事务，因为运行没有用户交互的批处理的速度要远远快于用户手动响应查询的速度，例如答复应用程序请求参数的提示。例如，如果事务正在等待用户输入，而用户去吃午餐了或者甚至回家过周末了，则用户将此事务挂起使之不能完成。这样将降低系统的吞吐量，因为事务持有的任何锁只有在事务提交或回滚时才会释放。即使不出现死锁的情况，访问同一资源的其它事务也会被阻塞，等待该事务完成。 保持事务简短并在一个批处理中 在同一数据库中并发执行多个需要长时间运行的事务时通常发生死锁。事务运行时间越长，其持有排它锁或更新锁的时间也就越长，从而堵塞了其它活动并可能导致死锁。 保持事务在一个批处理中，可以最小化事务的网络通信往返量，减少完成事务可能的延迟并释放锁。 使用低隔离级别 确定事务是否能在更低的隔离级别上运行。执行提交读允许事务读取另一个事务已读取（未修改）的数据，而不必等待第一个事务完成。使用较低的隔离级别（例如提交读）而不使用较高的隔离级别（例如可串行读）可以缩短持有共享锁的时间，从而降低了锁定争夺。 使用绑定连接 使用绑定连接使同一应用程序所打开的两个或多个连接可以相互合作。次级连接所获得的任何锁可以象由主连接获得的锁那样持有，反之亦然，因此不会相互阻塞。 用存储过程查出引起死锁的进程和SQL语句 假如发生了死锁，我们怎么去检测具体发生死锁的是哪条SQL语句或存储过程？此时我们可以使用以下存储过程来检测，就可以查出引起死锁的进程和SQL语句。</p>

            
            <p class="more">
                <a href="/2015/09/21/2019030500037/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/21/2019030500037/" title="死锁的预防和解除">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <a class="extend prev" rel="prev" href="/archives/2015/page/4/">前一页</a><a class="page-number" href="/archives/2015/">1</a><span class="space">&hellip;</span><a class="page-number" href="/archives/2015/page/3/">3</a><a class="page-number" href="/archives/2015/page/4/">4</a><span class="page-number current">5</span><a class="page-number" href="/archives/2015/page/6/">6</a><a class="page-number" href="/archives/2015/page/7/">7</a><span class="space">&hellip;</span><a class="page-number" href="/archives/2015/page/14/">14</a><a class="extend next" rel="next" href="/archives/2015/page/6/">后一页</a>
    </nav>
    


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/MySQL/">MySQL</a>
        <span class="badge">(92)</span>
    </li>
    
    <li>
        <a href="/categories/Oracle/">Oracle</a>
        <span class="badge">(40)</span>
    </li>
    
    <li>
        <a href="/categories/开发语言/">开发语言</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/">NOSQL</a>
        <span class="badge">(17)</span>
    </li>
    
    <li>
        <a href="/categories/其他数据库/">其他数据库</a>
        <span class="badge">(4)</span>
    </li>
    
    <li>
        <a href="/categories/SQL-Server/">SQL Server</a>
        <span class="badge">(13)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/">Oracle</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/SQL-Server/">SQL Server</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/开发语言/">开发语言</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/MySQL/" title="MySQL">MySQL (71)</a>
  
    <a class="tag-item" href="/tags/位运算/" title="位运算">位运算 (0)</a>
  
    <a class="tag-item" href="/tags/sqlplus/" title="sqlplus">sqlplus (1)</a>
  
    <a class="tag-item" href="/tags/allow/" title="allow">allow (1)</a>
  
    <a class="tag-item" href="/tags/Apache/" title="Apache">Apache (1)</a>
  
    <a class="tag-item" href="/tags/deny/" title="deny">deny (1)</a>
  
    <a class="tag-item" href="/tags/CentOS/" title="CentOS">CentOS (2)</a>
  
    <a class="tag-item" href="/tags/druid/" title="druid">druid (1)</a>
  
    <a class="tag-item" href="/tags/心跳/" title="心跳">心跳 (1)</a>
  
    <a class="tag-item" href="/tags/事务/" title="事务">事务 (5)</a>
  
    <a class="tag-item" href="/tags/分布式/" title="分布式">分布式 (1)</a>
  
    <a class="tag-item" href="/tags/消息/" title="消息">消息 (1)</a>
  
    <a class="tag-item" href="/tags/redis/" title="redis">redis (6)</a>
  
    <a class="tag-item" href="/tags/KeepAlived/" title="KeepAlived">KeepAlived (1)</a>
  
    <a class="tag-item" href="/tags/Oracle/" title="Oracle">Oracle (30)</a>
  
    <a class="tag-item" href="/tags/schedule-job/" title="schedule job">schedule job (1)</a>
  
    <a class="tag-item" href="/tags/分库/" title="分库">分库 (1)</a>
  
    <a class="tag-item" href="/tags/分库分表/" title="分库分表">分库分表 (1)</a>
  
    <a class="tag-item" href="/tags/分表/" title="分表">分表 (1)</a>
  
    <a class="tag-item" href="/tags/SQL/" title="SQL">SQL (17)</a>
  
    <a class="tag-item" href="/tags/批量/" title="批量">批量 (1)</a>
  
    <a class="tag-item" href="/tags/数据库/" title="数据库">数据库 (7)</a>
  
    <a class="tag-item" href="/tags/结构同步/" title="结构同步">结构同步 (1)</a>
  
    <a class="tag-item" href="/tags/truncate/" title="truncate">truncate (1)</a>
  
    <a class="tag-item" href="/tags/Excel/" title="Excel">Excel (1)</a>
  
    <a class="tag-item" href="/tags/Sqlite/" title="Sqlite">Sqlite (1)</a>
  
    <a class="tag-item" href="/tags/Hash索引/" title="Hash索引">Hash索引 (1)</a>
  
    <a class="tag-item" href="/tags/InnoDB/" title="InnoDB">InnoDB (3)</a>
  
    <a class="tag-item" href="/tags/MyISAM/" title="MyISAM">MyISAM (3)</a>
  
    <a class="tag-item" href="/tags/索引优化/" title="索引优化">索引优化 (1)</a>
  
    <a class="tag-item" href="/tags/Linux/" title="Linux">Linux (2)</a>
  
    <a class="tag-item" href="/tags/FineReport/" title="FineReport">FineReport (1)</a>
  
    <a class="tag-item" href="/tags/报表/" title="报表">报表 (1)</a>
  
    <a class="tag-item" href="/tags/数据集/" title="数据集">数据集 (1)</a>
  
    <a class="tag-item" href="/tags/rowid/" title="rowid">rowid (2)</a>
  
    <a class="tag-item" href="/tags/重复/" title="重复">重复 (1)</a>
  
    <a class="tag-item" href="/tags/Character-set/" title="Character set">Character set (1)</a>
  
    <a class="tag-item" href="/tags/NLS-LANG/" title="NLS_LANG">NLS_LANG (1)</a>
  
    <a class="tag-item" href="/tags/mysqldump/" title="mysqldump">mysqldump (2)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="http://www.devba.com" target="_blank" title="软件开发吧">软件开发吧</a>
        </li>
    
        <li>
            <a href="https://www.sqlyun.cn" target="_blank" title="SQL云笔记">SQL云</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>