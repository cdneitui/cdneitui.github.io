<!doctype html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8">
    <meta name="baidu-site-verification" content="dIcXMeY8Ya">
    
    <title>文章归档: 2015 | 软件开发吧</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="keywords" content="SQL云,SQL云开发,SQL笔记,SQL开发,云开发,MySQL,Oralce,数据库,数据库云,数据库开发,数据库云开发,SQL教程,数据库教程,开发笔记,MySQL笔记,MySQL教程">
    <meta name="description" content="为满足广大程序猿兄弟对日常工作中学习数据库、使用使用数据库资料查询需求，SQL云开发免费将自己整理的各种数据库技术资料分享出来，并希望与广大猿兄一起讨论学习与进步,致力于一起更方便、快捷资料学习查询,实现更安全、高效的数据存储.">

    
    <link rel="alternative" href="/atom.xml" title="软件开发吧" type="application/atom+xml">
    
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
</html>
<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">软件开发吧</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/archives/2015/page/8/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/archives/2015/page/8/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/archives/2015/page/8/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/archives/2015/page/8/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/cdneitui" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.github.com/" target="_blank">Hosted by GitHub Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon">
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 文章归档 -->

    <h3 class="widget-hd">
        <strong>
            
                文章归档
                <!-- 文章归档，可以根据日期分类 -->
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/08/24/2019030500160/">
    		SQL-PL/SQL基础操作知识
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-08-24T04:58:11.000Z">2015-08-24</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/SQL/" title="SQL">SQL</a> / 
    
        <a href="/tags/SQL-PL/" title="SQL-PL">SQL-PL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>SQL的4GL，对流程控制的支持不够，Oracle的PL/SQL是3GL，添加了流程控制、变量等支持可以在数据库层面上进行程序的设计。</p>
<ul>
<li>PL/SQL的特点 1.支持事务控制和SQL. 2.数据类型在SQL的基础上进行了扩展。 3.PL/SQL可存储在Oracle数据库上。 4.可以对PL/SQL进行权限控制。</li>
<li>PL/SQL的优势 1.可以提高横向的运行性能。 2.可以使程序模块化。 3.可以采用逻辑控制语句来控制程序的结构。 4.利用运行时的错误信息，做日志记录。 5.良好的移植性。</li>
<li><p>PL/SQL的结构 pl/sql的基本单位是块，分为三部分：声明部分，执行部分和异常处理部分。 以declare作为开始标记，执行部分用begin作为标志，异常处理部分以exception作为标志，其中执行部分是必须有的。</p>
<p>[declare]<br>….<br>begin</p>
<pre><code>...
</code></pre><p>[exception]</p>
<pre><code>...
</code></pre><p>end;</p>
</li>
</ul>
<p>例如： 只包含执行体</p>
<pre><code>begin
    dbms.output.put_lin(&apos;执行体...&apos;);
end;
</code></pre><p>注意，在使用dbms_output之前要打开控制器输出开关:set serveroutput on; 包含声明和执行体两部分：</p>
<pre><code>declare
     v_result number(8,2);
begin
     v_result = 100 / 6;
     dbms_output.put_line(&apos;结果是：&apos;||v_result);
end;
</code></pre><p>包含声明、执行体和异常处理三部分</p>
<pre><code>declare
     v_ename varchar2(20);
begin
     select ename into v_ename from emp where empno=7369;
     dbms_output.put_line(&apos;姓名：&apos;||v_ename);
exception
     when no_data_found then
          dbms_output.put_line(&apos;没有该员工&apos;);
     when too_many_rows_exeption then
          dbms_output.put_line(&apos;数据过多&apos;);
end；
</code></pre><ul>
<li><p>PL/SQL中变量的使用 1.声明变量的语法结构</p>
<p>variable_name datatype[ [not null] {:=|default} expression];</p>
</li>
</ul>
<p>2.常量声明</p>
<pre><code>constant_name constant datatype
[not null]
{:=default} expression;
</code></pre><p>常量的datatype有以下三种： 1）标量类型：单一类型，不存在组合 2）复合类型：由几种单一类型组成 3）引用类型：使用其他数据项的引用 标量类型： 数值 number(pression,scade) binary_integer pls_integer simple_integer 字符 char varchar2 nvarchar long 布尔类型 true/false/null 日期类型 date/datestamp 复合类型（先定义后声明变量） 记录类型声明语法</p>
<pre><code>type type_name is recode
(
     field_name datatype
     [ [not null] {:=|default} expression]
     [,field_name datatype
       [not null]
       {:=|default} expression
     ]
);
</code></pre><p>VARRAY变长数组：它是一个存储有序元素的集合，适合较少的数据使用。 声明语法：</p>
<pre><code>type type_name is {varray} (size_limit) of element_type [not null]
</code></pre><ul>
<li>PL/SQL中的结构控制语句</li>
</ul>
<p>1.IF条件语句 ①</p>
<pre><code>IF condition THEN
     statement;
END IF;
</code></pre><p>②</p>
<pre><code>IF condition THEN
    statement;
ELSE
    statement;
ENDF IF;
</code></pre><p>③</p>
<pre><code>IF condition THEN
     statement;
ELSE IF condition THEN
     statement;
ELSE
     statement;
END IF;
</code></pre><p>2.CASE语句 ①简单case</p>
<pre><code>[&lt;&lt;label_name&gt;&gt;]

CASE case_operate
WHEN condition THEN
     statement;
[WHEN condition THEN
     statement;]
[ELSE 
     statement;]     

END CASE[&lt;&lt;label_name&gt;&gt;]
</code></pre><p>②搜索case</p>
<pre><code>[&lt;&lt;label_name&gt;&gt;]
CASE
  WHEN boolean_exp THEN statement;
  [WHEN boolean_exp THEN statement;]
  ...
  [ELSE statement;]

END CASE[&lt;&lt;label_name&gt;&gt;]
</code></pre><ul>
<li><p>LOOP循环控制语句 1.基本LOOP</p>
<p>[&lt;&lt;label_name&gt;&gt;]<br>LOOP</p>
<pre><code>statement;
</code></pre><p>END LOOP [&lt;&lt;label_name&gt;&gt;];</p>
</li>
</ul>
<p>基本loop语句通常和exit连用，否则会出现死循环</p>
<pre><code>[&lt;&lt;label_name&gt;&gt;]
loop
     ....
     exit when ...
     | if ... exit;
</code></pre><p>2.WHILE..LOOP</p>
<pre><code>[&lt;&lt;label_name&gt;&gt;]
when boolean_exp
loop
     statement;
end loop[&lt;&lt;label_name&gt;&gt;]
</code></pre><p>3.FOR…LOOP</p>
<pre><code>[&lt;&lt;label_name&gt;&gt;]
for index_name in 
[REVERSE]  //反向
lower_bound, upper_bound
loop
    statement;
end loop[&lt;&lt;label_name&gt;&gt;]
</code></pre>
            
            <p class="more">
                <a href="/2015/08/24/2019030500160/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/08/24/2019030500160/" title="SQL-PL/SQL基础操作知识">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/4.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/开发语言/">开发语言</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/08/20/2019030500041/">
    		精通Hibernate——Session的保存、更新、删除和查询
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-08-20T11:34:47.000Z">2015-08-20</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/hibernate/" title="hibernate">hibernate</a> / 
    
        <a href="/tags/session/" title="session">session</a> / 
    
        <a href="/tags/方法/" title="方法">方法</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>session的save方法 使一个临时对象变为持久化对象。 session的save方法完成以下操作： 1、把customer对象加入到缓存中，使他变为持久化对象 2、选用映射文件指定的标识符生成器为持久化对象分配唯一的OID。Customer.hbm.xml文件中id元素的 子元素指定标识符生成器： <generator> <id name="id" column="ID"> <generator class="increment"> </generator></id> 在配置文件配置了id自增后，在程序中在setId();是无效的。 3、计划执行一个insert语句，把customer对象当前的属性组装到insert语句中，save方法并不会立即执行sql语句。只有当清理缓存时才会执行insert语句。如果在save方法之后又修改了持久化对象的属性，这会使得Session在清理缓存的时候额外执行Sql 的update语句。以下两段代码尽管都能完成相同功能，第一段代码仅执行了一条insert语句，而右边执行了一条insert语句和一条update语句。第一段代码减少了数据库访问次数，具有更好的性能。 Customer customer = new Customer(); // 先设置customer属性再保存 customer.setName(“Tom”); session.save(customer); tx.commit(); Customer customer = new Customer(); session.save(customer); // 先保存再设置customer属性 customer.setName(“Tom”); tx.commit(); Hibernate通过持久化对象的OID来维持他和数据库相关记录的对应关系。当Customer对象处于持久化状态时，不允许随意修改他的OID。 session的update方法 使一个游离对象转变为持久化对象 session的update方法完成以下操作： 1、把Customer对象重新加入到Session缓存中，使他变为持久化对象 2、计划执行一个update语句。值得注意的是session只在清理缓存的时候执行update 只要通过update方法使游离对象被一个Session关联，即使没有修改Customer对象的任何属性，Session在清理缓存时也会执行由update方法计划的update语句。 如果希望session仅仅当修改了Customer对象的属性时才执行update语句，可以把映射文件中class元素的select-before-update设为true，默认为false； <class name="mypack.Customers" table="CUSTOMERS" select-before-update="true"> 当update方法关联一个游离对象时，如果在session缓存中已经存在相同的OID的持久化对象，会抛出异常。 session的saveOrUpdate方法 saveOrUpdate方法同时包含了save与update方法，如果传入的参数是临时对象，就调用save方法，如果传入的是游离对象就调用update方法，如果传入的是持久化对象就直接返回。那么Hibernate如何判断对象的状态呢？ 下面看看临时对象的判断条件： 1、Java对象的OID取值为null 2、Java对象具有version属性并且取值为null 3、在映射文件中为id元素设置了unsaved-value属性，并且OID取值与unsaved-value属性值匹配 4、在映射文件中为version属性设置了unsaved-value属性，并且OID取值与unsaved-value属性值匹配 5、自定义了Hibernate的Interceptor实现类，并且Interceptor的isUnsaved方法返回true session的load和get方法 Session的load和get方法都能根据OID从数据库中加载一个持久化对象，区别在于：当数据库中没有与之对应的记录时load方法会抛出ObjectNotFoundException异常，get方法返回null。 get方法会在调用之后立即向数据库发出sql语句（不考虑缓存的情况下），返回持久化对象；而load方法会在调用后返回一个代理对象，该代理对象只保存了实体对象的id，直到使用对象的非主键属性时才会发出sql语句 Session的delete方法 delete方法用于从数据库中删除与Java对象对应的记录，如果传入的参数是持久化对象，session就计划执行一个delete语句，如果传入的是游离对象，先使游离对象被session关联，使他变为持久化对象，然后计划执行一个delete语句。Session只有在清理缓存的时候才会执行delete语句，只有调用session.close才会从session缓存中删除对象。</class></generator></p>

            
            <p class="more">
                <a href="/2015/08/20/2019030500041/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/08/20/2019030500041/" title="精通Hibernate——Session的保存、更新、删除和查询">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/0.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/08/18/2019030500118/">
    		Mysql5.7.8安装文档（二进制安装）
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-08-18T06:23:32.000Z">2015-08-18</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>Mysql5.7.8安装文档（二进制安装） 5.7的二进制安装方法与5.6大概差不多，但有些地方不太一样，比如说，初始化命令的该变，5.7之后的小版本初始化命令也不相同。现在使用的是开发版的5.7.8. 第一步，下载解压二进制文件，加压，进入解压出来的文件 [root@mysql47 mysql33333]# ll total 160 drwxr-xr-x 2 7161 wheel 4096 Jul 20 20:54 bin -rw-r–r– 1 7161 wheel 17987 Jul 20 20:25 COPYING drwxr-xr-x 2 7161 wheel 4096 Jul 20 20:54 docs drwxr-xr-x 3 7161 wheel 4096 Jul 20 20:54 include -rw-r–r– 1 7161 wheel 106739 Jul 20 20:25 INSTALL-BINARY drwxr-xr-x 4 7161 wheel 4096 Jul 20 20:54 lib drwxr-xr-x 4 7161 wheel 4096 Jul 20 20:54 man -rw-r–r– 1 7161 wheel 2478 Jul 20 20:25 README drwxr-xr-x 28 7161 wheel 4096 Jul 20 20:54 share drwxr-xr-x 2 7161 wheel 4096 Jul 20 20:54 support-files [root@mysql47 mysql33333]# 会发现没有data目录。没有之前mysql5.6的scripts文件夹。 我是重命名了一下，mysql33333 第二步，在mysql33333下建立data目录 第三步，更改文件夹mysql33333的文件所属用户 [root@mysql47 local]# chown -R mysql:mysql mysql33333 [root@mysql47 mysql33333]# ll total 164 drwxr-xr-x 2 mysql mysql 4096 Jul 20 20:54 bin -rw-r–r– 1 mysql mysql 17987 Jul 20 20:25 COPYING drwxr-xr-x 2 mysql mysql 4096 Aug 18 11:07 data drwxr-xr-x 2 mysql mysql 4096 Jul 20 20:54 docs drwxr-xr-x 3 mysql mysql 4096 Jul 20 20:54 include -rw-r–r– 1 mysql mysql 106739 Jul 20 20:25 INSTALL-BINARY drwxr-xr-x 4 mysql mysql 4096 Jul 20 20:54 lib drwxr-xr-x 4 mysql mysql 4096 Jul 20 20:54 man -rw-r–r– 1 mysql mysql 2478 Jul 20 20:25 README drwxr-xr-x 28 mysql mysql 4096 Jul 20 20:54 share drwxr-xr-x 2 mysql mysql 4096 Jul 20 20:54 support-files [root@mysql47 mysql33333]# 第四步，初始化数据库 由于我的版本是5.6.8.所以根据官档的说明，进行安装。以下是官档的相关说明。 shell&gt; ln -s full-path-to-mysql-VERSION-OS mysql shell&gt; cd mysql shell&gt; mkdir mysql-files shell&gt; chmod 770 mysql-files shell&gt; chown -R mysql . shell&gt; chgrp -R mysql . shell&gt; bin/mysql_install_db –user=mysql # Before MySQL 5.7.6 shell&gt; bin/mysqld –initialize –user=mysql # MySQL 5.7.6 and up shell&gt; bin/mysql_ssl_rsa_setup # MySQL 5.7.6 and up shell&gt; chown -R root . shell&gt; chown -R mysql data mysql-files shell&gt; bin/mysqld_safe –user=mysql &amp;</p>
<h1 id="Next-command-is-optional"><a href="#Next-command-is-optional" class="headerlink" title="Next command is optional"></a>Next command is optional</h1><p>shell&gt; cp support-files/mysql.server /etc/init.d/mysql.server 命令如下： [root@mysql47 bin]# ./mysqld –initialize –basedir=/usr/local/mysql33333 –datadir=/usr/local/mysql33333/data &amp; 会报warning提示信息，可以看一下。显示给出一个root的临时密码，但是后来登录使用的时候不能用。 第五步，./mysql_ssl_rsa_setup –datadir=/usr/local/mysql33333/data 第六步：在mysql33333文件夹下，并配置相关参数，简单配置一下就好。 cp ./support-files/my-default.cnf ./my.cnf 第六步，更改mysql33333文件夹所属。 Chown -R mysql:mysql /usr/local/mysql33333 第七步：利用–skip-grant-tables的方式登录启动数据库服务器 之所以通过这种方式启动，是因为，虽然在初始化的时候，warning里面已经给出了root的临时密码，但是我尝试了一下，正常启动mysql服务器之后，用那个密码登不进去。 第八步,登录服务器，并且修改root密码。 先看版本号： mysql&gt; select version(); +———–+ | version() | +———–+ | 5.7.8-rc | +———–+ 1 row in set (0.00 sec) 看mysql.user表 mysql&gt; select <em> from mysql.user\G <strong>_</strong>\</em>****************<strong>_</strong> 1. row <strong>_</strong>*****************<strong>_</strong> Host: localhost User: root Select_priv: Y Insert_priv: Y Update_priv: Y Delete_priv: Y Create_priv: Y Drop_priv: Y Reload_priv: Y Shutdown_priv: Y Process_priv: Y File_priv: Y Grant_priv: Y References_priv: Y Index_priv: Y Alter_priv: Y Show_db_priv: Y Super_priv: Y Create_tmp_table_priv: Y Lock_tables_priv: Y Execute_priv: Y Repl_slave_priv: Y Repl_client_priv: Y Create_view_priv: Y Show_view_priv: Y Create_routine_priv: Y Alter_routine_priv: Y Create_user_priv: Y Event_priv: Y Trigger_priv: Y Create_tablespace_priv: Y ssl_type: ssl_cipher: x509_issuer: x509_subject: max_questions: 0 max_updates: 0 max_connections: 0 max_user_connections: 0 plugin: mysql_native_password authentication_string: *D5F86FA8F536F9E81C12E8A993EF5292A90259FB password_expired: Y password_last_changed: 2015-08-18 11:11:39 password_lifetime: NULL account_locked: N 1 row in set (0.00 sec) 只有一个root帐号，并且密码已经过期了。 在这里修改密码的时候，要考虑到pasword_expied,设置成N，才可以用。 修改密码： mysql&gt; update mysql.user set authentication_string=password(‘redhat’), password_expired=’N’ where user=’root’; Query OK, 1 row affected, 1 warning (0.00 sec) Rows matched: 1 Changed: 1 Warnings: 1 mysql&gt; flush privileges; Query OK, 0 rows affected (0.00 sec) 可能感觉这个方法有点怪异，为什么不直接set password=password(); 看一下 mysql&gt; set password=password(‘123’); ERROR 1131 (42000): You are using MySQL as an anonymous user and anonymous users are not allowed to change passwords 答案是不可以，因为mysql.user表已经没有这个字段了。 修改完成之后，用root登录。 mysql&gt; select current_user(); +—————-+ | current_user() | +—————-+ | root@localhost | +—————-+ 1 row in set (0.00 sec) 登录ok。</p>

            
            <p class="more">
                <a href="/2015/08/18/2019030500118/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/08/18/2019030500118/" title="Mysql5.7.8安装文档（二进制安装）">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/8.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/08/04/2019030500110/">
    		MYSQL问题解决方案：Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password:YES)
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-08-04T04:34:13.000Z">2015-08-04</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>这两天在MyEclipse中开发Web项目时，连接MYSQL数据库，出现问题：<em>Access denied for user ‘root‘@’localhost’</em> (using password:YES)。 经查找资料发现是root帐户默认不开放远程访问权限，所以需要修改一下相关权限。</p>
<pre><code>解决方案：
</code></pre><ol>
<li>打开MySQL目录下的my.ini文件，在文件的最后添加一行“skip-grant-tables”，保存并关闭文件。（WIN7默认安装，my.ini在C:\ProgramData\MySQL\MySQL Server 5.6）</li>
<li>重启MySQL服务。</li>
<li>通过命令行进入MySQL的BIN目录，输入“mysql -u root -p”(不输入密码)，回车即可进入数据库。（WIN7默认安装，BIN目录为：C:\Program Files\MySQL\MySQL Server 5.6\bin）</li>
<li>执行“use mysql;”，使用mysql数据库。</li>
<li>执行“update user set password=PASSWORD(“123456”) where user=’root’;”（修改root的密码）</li>
<li>打开MySQL目录下的my.ini文件，删除最后一行的“skip-grant-tables”，保存并关闭文件。</li>
<li>重启MySQL服务。</li>
<li>在命令行中输入“mysql -u root -p 123456”，即可成功连接数据库。</li>
</ol>
<p>完成以上步骤，MyEclipse也可成功连接MySQL了。</p>

            
            <p class="more">
                <a href="/2015/08/04/2019030500110/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/08/04/2019030500110/" title="MYSQL问题解决方案：Access denied for user &#39;root&#39;@&#39;localhost&#39; (using password:YES)">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/4.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/29/2019030500148/">
    		oracle11g exp导出问题：部分表导不出来
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-29T04:35:48.000Z">2015-07-29</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/exp/" title="exp">exp</a> / 
    
        <a href="/tags/oracle11g/" title="oracle11g">oracle11g</a> / 
    
        <a href="/tags/导出/" title="导出">导出</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>在oracle导出表的命令exp时候发现一个问题，就是部分表完全的导不出来，经检查发现只要是表为空的都会导不出来。 在如下表中发现segment_created都为NO的是导不出来的，经查询后，将语句提取出来执行即可。 select ‘alter table ‘|| table_name ||’ allocate extent;’ from user_tables where segment_created=’NO’; alter table table allocate extent; 备注：在11g中有一个特性就是参数deferred_segment_creation，默认是true的，表示段延迟创建。当创建一个新的表，并且该表还没有数据的情况</p>
<p>下，该表是不会分配extent的，所以说该表不占数据空间，此时没有分配segment，导致exp导不出来。因此，根据上述方法，查询user_tables表，如果segment_created为NO的，说明该表没有分配segment，查询出来执行下即可。</p>

            
            <p class="more">
                <a href="/2015/07/29/2019030500148/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/29/2019030500148/" title="oracle11g exp导出问题：部分表导不出来">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/9.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/28/2019030500157/">
    		sql 事务-事务是一种机制、是一种操作序列
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-28T07:00:38.000Z">2015-07-28</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/事务/" title="事务">事务</a> / 
    
        <a href="/tags/SQL/" title="SQL">SQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>事务是一种机制、是一种操作序列，它包含了一组数据库操作命令，这组命令要么全部执行，要么全部不执行. 事务的四大属性： 1   原子性(Atomicity):事务是一个完整的操作。 2   一致性（Consistency）：当事务完成时，数据必须处于一致状态。 3   隔离性(Isolation):对数据进行修改的所有并发事务是彼此隔离的。 4   持久性(Durability):事务完成后，它对于系统的影响是永久性的。 三、创建事务 T-SQL中管理事务的语句： 1 开始事务:begin transaction 2 提交事务：committransaction 3 回滚事务:rollback transaction 事务分类: 1 显式事务:用begin transaction明确指定事务的开始。 2 隐性事务：打开隐性事务：set implicit_transactions on，当以隐性事务模式操作时，SQL Servler将在提交或回滚事务后自动启动新事务。无法描述事务的开始，只需要提交或回滚事务。 3 自动提交事务：SQLServer的默认模式，它将每条单独的T-SQL语句视为一个事务。如果成功执行，则自动提交，否则回滚。 示例：张三转800元到李四帐户上。 use stuDB go –创建帐户表bank– if exists(select<em> from sysobjects where name=’bank’) drop table bank create table bank ( customerName char(10),    –顾客姓名 currentMoney money       –当前余额 ) go /**//</em>–添加约束，帐户不能少于元–<em>/ alter table bank add constraint CK_currentMoneycheck(currentMoney&gt;=1) /**//</em>–插入测试数据–<em>/ insert into bank(customerName,currentMoney) select ‘张三’,1000union select ‘李四’,1 select </em> from bank go /<strong>//<em>–使用事务–</em>/ use stuDB go –恢复原来的数据 –update bank set currentMoney=currentMoney-1000 where customerName=’李’ set nocount on    –不显示受影响的行数 print ‘查看转帐事务前的余额’ select * from bank go /</strong>//<em>–开始事务–</em>/ begin transaction declare @errorSum int    –定义变量，用于累计事务执行过程中的错误 /<strong>//<em>–转帐–</em>/ update bank set currentMoney=currentMoney-800 where customerName=’张三’ set @errorSum=@errorSum+@@error    –累计是否有错误 update bank set currentMoney=currentMoney+800 where customerName=’李四’ set @errorSum=@errorSum+@@error –累计是否有错误 print ‘查看转帐事务过程中的余额’ select * from bank /</strong>//<em>–根据是否有错误，确定事务是提交还是回滚–</em>/ if @errorSum&gt;0 begin print ‘交易失败，回滚事务.’ rollback transaction end else begin print ‘交易成功，提交事务，写入硬盘，永久保存！’ commit transaction end go print ‘查看转帐后的余额’ select * from bank go</p>

            
            <p class="more">
                <a href="/2015/07/28/2019030500157/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/28/2019030500157/" title="sql 事务-事务是一种机制、是一种操作序列">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/8.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/23/2019030500105/">
    		mysql 设置远程登陆以及新增用户
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-23T09:55:45.000Z">2015-07-23</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p><strong>mysql 简单的管理命令：</strong> 启动mysql sudo start mysql 停止mysql sudo stop mysql <strong>允许远程访问的设置：</strong></p>
<pre><code>sudo vi /etc/mysql/my.cnf
注释掉  bind-address = 127.0.0.1
</code></pre><p>增加新用户：</p>
<pre><code>GRANT ALL PRIVILEGES ON *.* TO gino@&apos;%&apos; IDENTIFIED BY  &quot;123456&quot;;

GRANT命令说明：
    ALL PRIVILEGES 是表示所有权限，你也可以使用select、update等权限。

    ON 用来指定权限针对哪些库和表。

    *.* 中前面的*号用来指定数据库名，后面的*号用来指定表名。

    TO 表示将权限赋予某个用户。

    jack@&apos;localhost&apos; 表示jack用户，@后面接限制的主机，可以是IP、IP段、域名以及%，%表示任何地方。注意：这里%有的版本不包括本地，以前碰到过给某个用户设置了%允许任何地方登录，但是在本地登录不了，这个和版本有关系，遇到这个问题再加一个localhost的用户就可以了。

    IDENTIFIED BY 指定用户的登录密码。

    WITH GRANT OPTION 这个选项表示该用户可以将自己拥有的权限授权给别人。注意：经常有人在创建操作用户的时候不指定WITH GRANT OPTION选项导致后来该用户不能使用GRANT命令创建用户或者给其它用户授权。

备注：可以使用GRANT重复给用户添加权限，权限叠加，比如你先给用户添加一个select权限，然后又给用户添加一个insert权限，那么该用户就同时拥有了select和insert权限。

使用这个命令使权限生效，尤其是你对那些权限表user、db、host等做了update或者delete更新的时候。以前遇到过使用grant后权限没有更新的情况，只要对权限做了更改就使用FLUSH PRIVILEGES命令来刷新权限。

flush privileges;
</code></pre>
            
            <p class="more">
                <a href="/2015/07/23/2019030500105/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/23/2019030500105/" title="mysql 设置远程登陆以及新增用户">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/3.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/21/2019030500149/">
    		PL/SQL Developer各个Window的功能
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-21T07:28:52.000Z">2015-07-21</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/PL-SQL/" title="PL/SQL">PL/SQL</a> / 
    
        <a href="/tags/Developer/" title="Developer">Developer</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>了解每个窗口的功能是正确使用PL/SQL Developer的首要条件，下边简要说明了PL/SQL Developer各个窗口的功能，希望能够理解： -<strong>程序窗口(program window) ：</strong>可以执行 sql,sqlplus 相关的语句，例如存储过程，方法，一般用来开发程序用的. 测试窗口(test window)：一般是用来测试存储过程等的debug。 -<strong>SQL窗口(sql window)：</strong>执行的是dml,ddl语句,主要用户语句的查询和显示（应用最多的一个窗口）。 -<strong>报告窗口(report window)：</strong>就是可以方便用于展示有聚合查询的用图表形式展示的窗口，例如sum(),count()等，有x,y轴的。 -<strong>命令窗口(command window)：</strong>除了可以执行sql, sqlplus 相关的命令，还可以执行更多的命令，例如call 等。 -<strong>解释计划窗口(plan window)：</strong>就是解释执行计划的，调优时，经常用到。 -<strong>图表窗口(diagram)：</strong>没有用过，不知道如何画图表的。</p>

            
            <p class="more">
                <a href="/2015/07/21/2019030500149/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/21/2019030500149/" title="PL/SQL Developer各个Window的功能">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/其他数据库/">其他数据库</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/14/2019030500003/">
    		Android ORMLite数据库简介
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-14T07:35:23.000Z">2015-07-14</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/数据库/" title="数据库">数据库</a> / 
    
        <a href="/tags/Android/" title="Android">Android</a> / 
    
        <a href="/tags/ORMLite/" title="ORMLite">ORMLite</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>一般的项目中，Android自身提供的SQLite数据库，可以满足轻量级的数据存储应用，但是，只要是存储模型稍微复杂的项目，以及数据结构模型复杂的应用，就很难再用SQLite支撑整个项目的数据存储。何况，使用SQLite编写的代码，代码后续维护和管理不容易，所以，上规模的项目中，很有必要引入一种更好用、对开发者更友好的第三方ORM数据库框架：ORMlite。 ORMLite官方的简介说：“Object Relational Mapping Lite (ORM Lite) provides some simple, lightweight functionality for persisting Java objects to SQL databases while avoiding the complexity and overhead of more standard ORM packages.”。 ORMLite是对象关系映射（Object Relational Mapping）数据库的一种轻量级SQL数据库的开发包（packages）。提供简单易用的DAO。 ORMLite官方主页：<a href="http://ormlite.com/" target="_blank" rel="noopener">http://ormlite.com</a> Java语言编写，支持Java，Android平台，本文重点介绍如何在Android平台的应用开发中使用ORMLite。 在Android应用开发中使用ORMLite，首先要下载ORMLite的开发jar包，jar资源包下载主页：<a href="http://ormlite.com/releases" target="_blank" rel="noopener">http://ormlite.com/releases</a> 具体到Android，需要在 <a href="http://ormlite.com/releases" target="_blank" rel="noopener">http://ormlite.com/releases</a> 页面下载两个jar 包（本文基于ORMLite的版本是：ormlite 4.49-SNAPSHOT）： （1）core列表下的jar包； （2）android列表下的jar包。 如图所示： <img src="http://img.blog.csdn.net/20150714145643701?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> 将上面的两个jar包下载后放到Android工程项目中的libs包中，如图所示： <img src="http://img.blog.csdn.net/20150714145710073?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt> 以上完成后，ORMLite开发环境搭建就完成了，接下来就可以使用了。 首先需要创建和定义一张ORMLite用以存储的数据库表，这个表，用Java的一个类实现，例如User.java：</p>
<p><strong>[java]</strong></p>
<ol>
<li><p>package zhangphil.ormlitetest.database;</p>
</li>
<li><p>import com.j256.ormlite.field.DatabaseField;</p>
</li>
<li><p>import com.j256.ormlite.table.DatabaseTable;</p>
</li>
<li><p>@DatabaseTable(tableName = “users”)</p>
</li>
<li><p>public class User {</p>
</li>
<li><p>public final static String USER_ID = “user_id”;</p>
</li>
<li>public final static String NAME = “name”;</li>
<li><p>public final static String AGE = “age”;</p>
</li>
<li><p>public User() {</p>
</li>
<li><p>}</p>
</li>
<li><p>public User(String name, int age) {</p>
</li>
<li>this.name = name;</li>
<li>this.age = age;</li>
<li><p>}</p>
</li>
<li><p>// @DatabaseField(generatedId = true)</p>
</li>
<li><p>// public int id;</p>
</li>
<li><p>@DatabaseField(id = true, columnName = USER_ID)</p>
</li>
<li><p>public int user_id;</p>
</li>
<li><p>@DatabaseField(columnName = NAME)</p>
</li>
<li><p>public String name;</p>
</li>
<li><p>@DatabaseField(columnName = AGE)</p>
</li>
<li><p>public int age;</p>
</li>
<li><p>public int getUserId() {</p>
</li>
<li>return user_id;</li>
<li><p>}</p>
</li>
<li><p>public void setUserId(int uid) {</p>
</li>
<li>this.user_id = uid;</li>
<li><p>}</p>
</li>
<li><p>public String getName() {</p>
</li>
<li>return name;</li>
<li><p>}</p>
</li>
<li><p>public void setName(String name) {</p>
</li>
<li>this.name = name;</li>
<li><p>}</p>
</li>
<li><p>public int getAge() {</p>
</li>
<li>return age;</li>
<li><p>}</p>
</li>
<li><p>public void setAge(int age) {</p>
</li>
<li>this.age = age;</li>
<li><p>}</p>
</li>
<li><p>@Override</p>
</li>
<li>public String toString() {</li>
<li>return “user_id:” + user_id + “ 姓名:” + name + “ 年龄:” + age;</li>
<li>}</li>
<li>}</li>
</ol>
<p>上面的这个Java类User中开始一段代码：</p>
<p><strong>[java]</strong></p>
<ol>
<li>@DatabaseTable(tableName = “users”)</li>
</ol>
<p>此代码声明了User类中定义的数据模型，将存储在数据库表“users”中。换句话说，数据库表users中，存储的数据单元也即是类User中定义的数据模型。 其中： @DatabaseField(columnName = “xxx”) xxx 表示此数据字段在数据库表中的列名。 DatabaseField中，若设定id=true，则声明此id为主键。 ORMLite的数据库表定义可设置的参数比较多，这点可以参考官方文档。剩余的就是创建ORMLite数据库，和SQLite类似。ORMLite查插删改主要通过DAO。 现在给出一个简单的代码加以说： 定义一个ORMLite数据库表User.java，假设该User表存储用户的id、名字、年龄信息：</p>
<p><strong>[java]</strong></p>
<ol>
<li><p>package zhangphil.ormlitetest.database;</p>
</li>
<li><p>import com.j256.ormlite.field.DatabaseField;</p>
</li>
<li><p>import com.j256.ormlite.table.DatabaseTable;</p>
</li>
<li><p>@DatabaseTable(tableName = “users”)</p>
</li>
<li><p>public class User {</p>
</li>
<li><p>public final static String USER_ID = “user_id”;</p>
</li>
<li>public final static String NAME = “name”;</li>
<li><p>public final static String AGE = “age”;</p>
</li>
<li><p>public User() {</p>
</li>
<li><p>}</p>
</li>
<li><p>public User(String name, int age) {</p>
</li>
<li>this.name = name;</li>
<li>this.age = age;</li>
<li><p>}</p>
</li>
<li><p>// @DatabaseField(generatedId = true)</p>
</li>
<li><p>// public int id;</p>
</li>
<li><p>@DatabaseField(id = true, columnName = USER_ID)</p>
</li>
<li><p>public int user_id;</p>
</li>
<li><p>@DatabaseField(columnName = NAME)</p>
</li>
<li><p>public String name;</p>
</li>
<li><p>@DatabaseField(columnName = AGE)</p>
</li>
<li><p>public int age;</p>
</li>
<li><p>public int getUserId() {</p>
</li>
<li>return user_id;</li>
<li><p>}</p>
</li>
<li><p>public void setUserId(int uid) {</p>
</li>
<li>this.user_id = uid;</li>
<li><p>}</p>
</li>
<li><p>public String getName() {</p>
</li>
<li>return name;</li>
<li><p>}</p>
</li>
<li><p>public void setName(String name) {</p>
</li>
<li>this.name = name;</li>
<li><p>}</p>
</li>
<li><p>public int getAge() {</p>
</li>
<li>return age;</li>
<li><p>}</p>
</li>
<li><p>public void setAge(int age) {</p>
</li>
<li>this.age = age;</li>
<li><p>}</p>
</li>
<li><p>@Override</p>
</li>
<li>public String toString() {</li>
<li>return “user_id:” + user_id + “ 姓名:” + name + “ 年龄:” + age;</li>
<li>}</li>
<li><p>}</p>
<p>创建ORMLite数据库管理工具类ORMLiteDatabaseHelper.java：</p>
</li>
</ol>
<p><strong>[java]</strong></p>
<ol>
<li><p>package zhangphil.ormlitetest.database;</p>
</li>
<li><p>import java.sql.SQLException;</p>
</li>
<li><p>import android.content.Context;</p>
</li>
<li>import android.database.sqlite.SQLiteDatabase;</li>
<li>import android.database.sqlite.SQLiteDatabase.CursorFactory;</li>
<li><p>import android.util.Log;</p>
</li>
<li><p>import com.j256.ormlite.android.apptools.OrmLiteSqliteOpenHelper;</p>
</li>
<li>import com.j256.ormlite.dao.Dao;</li>
<li>import com.j256.ormlite.support.ConnectionSource;</li>
<li><p>import com.j256.ormlite.table.TableUtils;</p>
</li>
<li><p>public class ORMLiteDatabaseHelper extends OrmLiteSqliteOpenHelper {</p>
</li>
<li><p>private static ORMLiteDatabaseHelper mDatabaseHelper = null;</p>
</li>
<li><p>private Dao&lt;User, Integer&gt; mUserDao = null;</p>
</li>
<li><p>private final static String DataBase_NAME = “ormlite.db”;</p>
</li>
<li><p>private final static int DataBase_VERSION = 1;</p>
</li>
<li><p>public ORMLiteDatabaseHelper(Context context, String databaseName,</p>
</li>
<li>CursorFactory factory, int databaseVersion) {</li>
<li>super(context, DataBase_NAME, factory, DataBase_VERSION);</li>
<li><p>}</p>
</li>
<li><p>public static ORMLiteDatabaseHelper getInstance(Context context) {</p>
</li>
<li>if (mDatabaseHelper == null) {</li>
<li>mDatabaseHelper = new ORMLiteDatabaseHelper(context, DataBase_NAME,</li>
<li>null, DataBase_VERSION);</li>
<li><p>}</p>
</li>
<li><p>return mDatabaseHelper;</p>
</li>
<li><p>}</p>
</li>
<li><p>@Override</p>
</li>
<li><p>public void onCreate(SQLiteDatabase arg0, ConnectionSource connectionSource) {</p>
</li>
<li><p>Log.d(this.getClass().getName(), “ORMLite数据库 -&gt; onCreate”);</p>
</li>
<li><p>try {</p>
</li>
<li>TableUtils.createTableIfNotExists(connectionSource, User.class);</li>
<li>} catch (Exception e) {</li>
<li>e.printStackTrace();</li>
<li>}</li>
<li><p>}</p>
</li>
<li><p>@Override</p>
</li>
<li>public void onUpgrade(SQLiteDatabase database, ConnectionSource arg1,</li>
<li><p>int arg2, int arg3) {</p>
</li>
<li><p>Log.i(this.getClass().getName(), “数据库 -&gt; onUpgrade”);</p>
</li>
<li><p>try {</p>
</li>
<li>// 删除旧的数据库表。</li>
<li><p>TableUtils.dropTable(connectionSource, User.class, true);</p>
</li>
<li><p>// 重新创建新版的数据库。</p>
</li>
<li>onCreate(database, connectionSource);</li>
<li>} catch (SQLException e) {</li>
<li>e.printStackTrace();</li>
<li>}</li>
<li><p>}</p>
</li>
<li><p>/**</p>
</li>
<li><ul>
<li>每一个数据库中的表，要有一个获得Dao的方法。 可以使用一种更通用的模板方法如：</li>
</ul>
</li>
<li>* </li>
<li><ul>
<li>public Dao&lt;Class, Integer&gt; getORMLiteDao(Class cls) throws SQLException {</li>
</ul>
</li>
<li><ul>
<li>if (dao == null) { dao = getDao(cls); }</li>
</ul>
</li>
<li>* </li>
<li><ul>
<li>return dao; }</li>
</ul>
</li>
<li>*/</li>
<li>public Dao&lt;User, Integer&gt; getUserDao() {</li>
<li>if (mUserDao == null) {</li>
<li>try {</li>
<li>mUserDao = getDao(User.class);</li>
<li>} catch (java.sql.SQLException e) {</li>
<li>e.printStackTrace();</li>
<li>}</li>
<li><p>}</p>
</li>
<li><p>return mUserDao;</p>
</li>
<li><p>}</p>
</li>
<li><p>@Override</p>
</li>
<li>public void close() {</li>
<li>super.close();</li>
<li>mUserDao = null;</li>
<li>}</li>
<li><p>}</p>
<p>然后就可以在自己的应用中直接使用：</p>
</li>
</ol>
<p><strong>[java]</strong></p>
<ol>
<li><p>package zhangphil.ormlitetest;</p>
</li>
<li><p>import java.sql.SQLException;</p>
</li>
<li>import java.util.List;</li>
<li><p>import java.util.Random;</p>
</li>
<li><p>import com.j256.ormlite.dao.Dao;</p>
</li>
<li><p>import zhangphil.ormlitetest.database.ORMLiteDatabaseHelper;</p>
</li>
<li>import zhangphil.ormlitetest.database.User;</li>
<li>import android.support.v7.app.ActionBarActivity;</li>
<li>import android.widget.Toast;</li>
<li><p>import android.os.Bundle;</p>
</li>
<li><p>public class MainActivity extends ActionBarActivity {</p>
</li>
<li><p>private Dao&lt;User, Integer&gt; mUserDao;</p>
</li>
<li><p>@Override</p>
</li>
<li>protected void onCreate(Bundle savedInstanceState) {</li>
<li><p>super.onCreate(savedInstanceState);</p>
</li>
<li><p>ORMLiteDatabaseHelper mDatabaseHelper = ORMLiteDatabaseHelper</p>
</li>
<li>.getInstance(this);</li>
<li><p>mUserDao = mDatabaseHelper.getUserDao();</p>
</li>
<li><p>Random rand = new Random();</p>
</li>
<li>for (int i = 0; i &lt; 3; i++) {</li>
<li>User user = new User();</li>
<li>user.setUserId(i);</li>
<li>user.setName(“name” + i);</li>
<li>// 生成随机测试的年龄。</li>
<li><p>user.setAge(rand.nextInt(100));</p>
</li>
<li><p>try {</p>
</li>
<li>mUserDao.createOrUpdate(user);</li>
<li>} catch (SQLException e) {</li>
<li>e.printStackTrace();</li>
<li>}</li>
<li>}</li>
<li><p>}</p>
</li>
<li><p>@Override</p>
</li>
<li>public void onStart() {</li>
<li><p>super.onStart();</p>
</li>
<li><p>// 全局查询</p>
</li>
<li>try {</li>
<li><p>List<user> users = mUserDao.queryForAll();</user></p>
</li>
<li><p>for (User u : users) {</p>
</li>
<li>Toast.makeText(this, u.toString(), Toast.LENGTH_SHORT).show();</li>
<li>}</li>
<li>} catch (SQLException e) {</li>
<li>e.printStackTrace();</li>
<li><p>}</p>
</li>
<li><p>// 条件查询QueryBuilder</p>
</li>
<li>// 假设我们给定一个用户的id=1</li>
<li>int uid = 1;</li>
<li>try {</li>
<li>List<user> users = mUserDao.queryBuilder().where()</user></li>
<li><p>.eq(User.USER_ID, uid).query();</p>
</li>
<li><p>for (User u : users) {</p>
</li>
<li>Toast.makeText(this, “查询结果 : “ + u.toString(),</li>
<li>Toast.LENGTH_SHORT).show();</li>
<li>}</li>
<li>} catch (SQLException e) {</li>
<li>e.printStackTrace();</li>
<li>}</li>
<li>}</li>
<li>}</li>
</ol>

            
            <p class="more">
                <a href="/2015/07/14/2019030500003/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/14/2019030500003/" title="Android ORMLite数据库简介">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/4.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/07/09/2019030500069/">
    		MySQL优化之——安全地关闭MySQL实例
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-07-09T05:42:18.000Z">2015-07-09</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<h4 id="关闭过程："><a href="#关闭过程：" class="headerlink" title="关闭过程："></a>关闭过程：</h4><ul>
<li>1、发起shutdown，发出  SIGTERM信号</li>
<li>2、有必要的话，新建一个关闭线程(shutdown thread)</li>
</ul>
<p>如果是客户端发起的关闭，则会新建一个专用的关闭线程 如果是直接收到 SIGTERM 信号进行关闭的话，专门负责信号处理的线程就会负责关闭工作，或者新建一个独立的线程负责这个事 当无法创建独立的关闭线程时（例如内存不足），MySQL Server会发出类似下面的告警信息： Error: Can’t create thread to kill server</p>
<ul>
<li>3、MySQL Server不再响应新的连接请求</li>
</ul>
<p>关闭TCP/IP网络监听，关闭Unix Socket等渠道</p>
<ul>
<li>4、逐渐关闭当前的连接、事务</li>
</ul>
<p>空闲连接，将立刻被终止； 当前还有事务、SQL活动的连接，会将其标识为 killed，并定期检查其状态，以便下次检查时将其关闭；（参考 KILL 语法） 当前有活跃事务的，该事物会被回滚，如果该事务中还修改了非事务表，则已经修改的数据无法回滚，可能只会完成部分变更； 如果是Master/Slave复制场景里的Master，则对复制线程的处理过程和普通线程也是一样的； 如果是Master/Slave复制场景里的Slave，则会依次关闭IO、SQL线程，如果这2个线程当前是活跃的，则也会加上 killed 标识，然后再关闭； Slave服务器上，SQL线程是允许直接停止当前的SQL操作的（为了避免复制问题），然后再关闭该线程； 在MySQl 5.0.80及以前的版本里，如果SQL线程当时正好执行一个事务到中间，该事务会回滚；从5.0.81开始，则会等待所有的操作结束，除非用户发起KILL操作。 当Slave的SQL线程对非事务表执行操作时被强制 KILL了，可能会导致Master、Slave数据不一致；</p>
<ul>
<li>5、MySQL Server进程关闭所有线程，关闭所有存储引擎；</li>
</ul>
<p>刷新所有表cache，关闭所有打开的表； 每个存储引擎各自负责相关的关闭操作，例如MyISAM会刷新所有等待写入的操作；InnoDB会将buffer pool刷新到磁盘中（从MySQL 5.0.5开始，如果innodb_fast_shutdown不设置为 2 的话），把当前的LSN记录到表空间中，然后关闭所有的内部线程。</p>
<ul>
<li>6、MySQL Server进程退出</li>
</ul>
<h4 id="关于KILL指令"><a href="#关于KILL指令" class="headerlink" title="关于KILL指令"></a>关于KILL指令</h4><p>从5.0开始，KILL 支持指定  CONNECTION | QUERY两种可选项：</p>
<ul>
<li>KILL CONNECTION和原来的一样，停止回滚事务，关闭该线程连接，释放相关资源；</li>
<li>KILL QUERY则只停止线程当前提交执行的操作，其他的保持不变；</li>
</ul>
<p>提交KILL操作后，该线程上会设置一个特殊的 kill标记位。通常需要一段时间后才能真正关闭线程，因为kill标记位只在特定的情况下才检查：</p>
<ul>
<li>1、执行SELECT查询时，在ORDER BY或GROUP BY循环中，每次读完一些行记录块后会检查 kill标记位，如果发现存在，该语句会终止；</li>
<li>2、执行ALTER TABLE时，在从原始表中每读取一些行记录块后会检查 kill 标记位，如果发现存在，该语句会终止，删除临时表；</li>
<li>3、执行UPDATE和DELETE时，每读取一些行记录块并且更新或删除后会检查 kill 标记位，如果发现存在，该语句会终止，回滚事务，若是在非事务表上的操作，则已发生变更的数据不会回滚；</li>
<li>4、GET_LOCK() 函数返回NULL；</li>
<li>5、INSERT DELAY线程会迅速内存中的新增记录，然后终止；</li>
<li>6、如果当前线程持有表级锁，则会释放，并终止；</li>
<li>7、如果线程的写操作调用在等待释放磁盘空间，则会直接抛出“磁盘空间满”错误，然后终止；</li>
<li>8、当MyISAM表在执行REPAIR TABLE 或 OPTIMIZE TABLE 时被 KILL的话，会导致该表损坏不可用，指导再次修复完成。</li>
</ul>
<h4 id="安全关闭MySQL几点建议"><a href="#安全关闭MySQL几点建议" class="headerlink" title="安全关闭MySQL几点建议"></a>安全关闭MySQL几点建议</h4><p>想要安全关闭 mysqld 服务进程，建议按照下面的步骤来进行：</p>
<ul>
<li>0、用具有SUPER、ALL等最高权限的账号连接MySQL，最好是用 unix socket 方式连接；</li>
<li>1、在5.0及以上版本，设置innodb_fast_shutdown = 1，允许快速关闭InnoDB（不进行full purge、insert buffer merge），如果是为了升级或者降级MySQL版本，则不要设置；</li>
<li>2、设置innodb_max_dirty_pages_pct = 0，让InnoDB把所有脏页都刷新到磁盘中去；</li>
<li>3、设置max_connections和max_user_connections为1，也就最后除了自己当前的连接外，不允许再有新的连接创建；</li>
<li>4、关闭所有不活跃的线程，也就是状态为Sleep  且 Time 大于 1 的线程ID；</li>
<li>5、执行 SHOW PROCESSLIST  确认是否还有活跃的线程，尤其是会产生表锁的线程，例如有大数据集的SELECT，或者大范围的UPDATE，或者执行DDL，都是要特别谨慎的；</li>
<li>6、执行 SHOW ENGINE INNODB STATUS 确认History list length的值较低（一般要低于500），也就是未PURGE的事务很少，并且确认Log sequence number、Log flushed up to、Last checkpoint at三个状态的值一样，也就是所有的LSN都已经做过检查点了；</li>
<li>7、然后执行FLUSH LOCKAL TABLES 操作，刷新所有 table cache，关闭已打开的表（LOCAL的作用是该操作不记录BINLOG）；</li>
<li>8、如果是SLAVE服务器，最好是先关闭 IO_THREAD，等待所有RELAY LOG都应用完后，再关闭 SQL_THREAD，避免 SQL_THREAD 在执行大事务被终止，耐心待其全部应用完毕，如果非要强制关闭的话，最好也等待大事务结束后再关闭SQL_THREAD；</li>
<li>9、最后再执行 mysqladmin shutdown。</li>
<li>10、紧急情况下，可以设置innodb_fast_shutdown = 1，然后直接执行 mysqladmin shutdown 即可，甚至直接在操作系统层调用 kill 或者 kill -9 杀掉 mysqld 进程（在innodb_flush_log_at_trx_commit = 0 的时候可能会丢失部分事务），不过mysqld进程再次启动时，会进行CRASH RECOVERY工作，需要有所权衡。</li>
</ul>
<p>以上说了那么多，其实正常情况下执行 mysqladmin shutdown 就够了，如果发生阻塞，再参考上面的内容进行分析和解决吧。</p>
</blockquote>

            
            <p class="more">
                <a href="/2015/07/09/2019030500069/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/07/09/2019030500069/" title="MySQL优化之——安全地关闭MySQL实例">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/9.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <a class="extend prev" rel="prev" href="/archives/2015/page/7/">前一页</a><a class="page-number" href="/archives/2015/">1</a><span class="space">&hellip;</span><a class="page-number" href="/archives/2015/page/6/">6</a><a class="page-number" href="/archives/2015/page/7/">7</a><span class="page-number current">8</span><a class="page-number" href="/archives/2015/page/9/">9</a><a class="page-number" href="/archives/2015/page/10/">10</a><span class="space">&hellip;</span><a class="page-number" href="/archives/2015/page/14/">14</a><a class="extend next" rel="next" href="/archives/2015/page/9/">后一页</a>
    </nav>
    


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/MySQL/">MySQL</a>
        <span class="badge">(92)</span>
    </li>
    
    <li>
        <a href="/categories/Oracle/">Oracle</a>
        <span class="badge">(40)</span>
    </li>
    
    <li>
        <a href="/categories/开发语言/">开发语言</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/">NOSQL</a>
        <span class="badge">(17)</span>
    </li>
    
    <li>
        <a href="/categories/其他数据库/">其他数据库</a>
        <span class="badge">(4)</span>
    </li>
    
    <li>
        <a href="/categories/SQL-Server/">SQL Server</a>
        <span class="badge">(13)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/">Oracle</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/SQL-Server/">SQL Server</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/开发语言/">开发语言</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/MySQL/" title="MySQL">MySQL (71)</a>
  
    <a class="tag-item" href="/tags/位运算/" title="位运算">位运算 (0)</a>
  
    <a class="tag-item" href="/tags/sqlplus/" title="sqlplus">sqlplus (1)</a>
  
    <a class="tag-item" href="/tags/allow/" title="allow">allow (1)</a>
  
    <a class="tag-item" href="/tags/Apache/" title="Apache">Apache (1)</a>
  
    <a class="tag-item" href="/tags/deny/" title="deny">deny (1)</a>
  
    <a class="tag-item" href="/tags/CentOS/" title="CentOS">CentOS (2)</a>
  
    <a class="tag-item" href="/tags/druid/" title="druid">druid (1)</a>
  
    <a class="tag-item" href="/tags/心跳/" title="心跳">心跳 (1)</a>
  
    <a class="tag-item" href="/tags/事务/" title="事务">事务 (5)</a>
  
    <a class="tag-item" href="/tags/分布式/" title="分布式">分布式 (1)</a>
  
    <a class="tag-item" href="/tags/消息/" title="消息">消息 (1)</a>
  
    <a class="tag-item" href="/tags/redis/" title="redis">redis (6)</a>
  
    <a class="tag-item" href="/tags/KeepAlived/" title="KeepAlived">KeepAlived (1)</a>
  
    <a class="tag-item" href="/tags/Oracle/" title="Oracle">Oracle (30)</a>
  
    <a class="tag-item" href="/tags/schedule-job/" title="schedule job">schedule job (1)</a>
  
    <a class="tag-item" href="/tags/分库/" title="分库">分库 (1)</a>
  
    <a class="tag-item" href="/tags/分库分表/" title="分库分表">分库分表 (1)</a>
  
    <a class="tag-item" href="/tags/分表/" title="分表">分表 (1)</a>
  
    <a class="tag-item" href="/tags/SQL/" title="SQL">SQL (17)</a>
  
    <a class="tag-item" href="/tags/批量/" title="批量">批量 (1)</a>
  
    <a class="tag-item" href="/tags/数据库/" title="数据库">数据库 (7)</a>
  
    <a class="tag-item" href="/tags/结构同步/" title="结构同步">结构同步 (1)</a>
  
    <a class="tag-item" href="/tags/truncate/" title="truncate">truncate (1)</a>
  
    <a class="tag-item" href="/tags/Excel/" title="Excel">Excel (1)</a>
  
    <a class="tag-item" href="/tags/Sqlite/" title="Sqlite">Sqlite (1)</a>
  
    <a class="tag-item" href="/tags/Hash索引/" title="Hash索引">Hash索引 (1)</a>
  
    <a class="tag-item" href="/tags/InnoDB/" title="InnoDB">InnoDB (3)</a>
  
    <a class="tag-item" href="/tags/MyISAM/" title="MyISAM">MyISAM (3)</a>
  
    <a class="tag-item" href="/tags/索引优化/" title="索引优化">索引优化 (1)</a>
  
    <a class="tag-item" href="/tags/Linux/" title="Linux">Linux (2)</a>
  
    <a class="tag-item" href="/tags/FineReport/" title="FineReport">FineReport (1)</a>
  
    <a class="tag-item" href="/tags/报表/" title="报表">报表 (1)</a>
  
    <a class="tag-item" href="/tags/数据集/" title="数据集">数据集 (1)</a>
  
    <a class="tag-item" href="/tags/rowid/" title="rowid">rowid (2)</a>
  
    <a class="tag-item" href="/tags/重复/" title="重复">重复 (1)</a>
  
    <a class="tag-item" href="/tags/Character-set/" title="Character set">Character set (1)</a>
  
    <a class="tag-item" href="/tags/NLS-LANG/" title="NLS_LANG">NLS_LANG (1)</a>
  
    <a class="tag-item" href="/tags/mysqldump/" title="mysqldump">mysqldump (2)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="http://www.devba.com" target="_blank" title="软件开发吧">软件开发吧</a>
        </li>
    
        <li>
            <a href="https://www.sqlyun.cn" target="_blank" title="SQL云笔记">SQL云</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>