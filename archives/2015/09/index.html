<!doctype html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8">
    <meta name="baidu-site-verification" content="dIcXMeY8Ya">
    
    <title>文章归档: 2015/9 | 软件开发吧</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="keywords" content="SQL云,SQL云开发,SQL笔记,SQL开发,云开发,MySQL,Oralce,数据库,数据库云,数据库开发,数据库云开发,SQL教程,数据库教程,开发笔记,MySQL笔记,MySQL教程">
    <meta name="description" content="为满足广大程序猿兄弟对日常工作中学习数据库、使用使用数据库资料查询需求，SQL云开发免费将自己整理的各种数据库技术资料分享出来，并希望与广大猿兄一起讨论学习与进步,致力于一起更方便、快捷资料学习查询,实现更安全、高效的数据存储.">

    
    <link rel="alternative" href="/atom.xml" title="软件开发吧" type="application/atom+xml">
    
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
</html>
<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">软件开发吧</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/archives/2015/09/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/archives/2015/09/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/archives/2015/09/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/archives/2015/09/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/cdneitui" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.github.com/" target="_blank">Hosted by GitHub Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon">
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 文章归档 -->

    <h3 class="widget-hd">
        <strong>
            
                文章归档
                <!-- 文章归档，可以根据日期分类 -->
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/22/2019030500009/">
    		使用消息系统避免分布式事务
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-22T02:17:09.000Z">2015-09-22</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/事务/" title="事务">事务</a> / 
    
        <a href="/tags/分布式/" title="分布式">分布式</a> / 
    
        <a href="/tags/消息/" title="消息">消息</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>首先举个例子：比如通过支付宝向余额宝转账1000元，这样一种生活中很平凡的事情，却可以引出很多问题：如果系统宕机挂掉，交易没有完成？那么数据就出现了不一致。等等类似的事情，在各类系统中都能找到类似情形。那么也可以换句专业的说法：当一个表update之后，如何保证另外一个与之关联的表也能完成update。 1、本地事务： 支付宝账户表：A  id uid amount 余额宝账户表：B  id uid amount 用户id：uid = 100 执行上面的过程分两部分： 1、支付宝账户表-1000：update A set amount=amount - 1000 where uid = 100； 2、余额宝账户表+1000：update B set amount=amount + 1000 where uid = 100； 如何保证两部分都能够完成，保证两部分“收支平衡” 对数据库熟悉的同学会那么我们使用transaction（事务）不就解决了 BEGIN TRANSACTION update A set amount=amount - 1000 where uid = 100； update B set amount=amount + 1000 where uid = 100； END TRANSACTION COMMIT; OK,上面的操作是没有问题的 那么对spring熟悉的同学也知道 其实在spring只需要使用注解就OK了 @Transactional(rollbackFor=Exception.class) public void updateAmount(){ updateA(); updateB(); } 是的，没有错的。能够完成。但是这些情况只是针对系统规模小，数据表在一个数据库实例上的；那么系统规模大，对应的数据表分布在不同的数据库实例上，分布在不同的物理节点上，前面采用的本地事务的方式就无用武之地了。 2、分布式事务（两阶段提交协议） 两阶段提交协议经常用来实现分布式事务;一般需要两个角色：协调器C和若干个事务执行者Si；那么事务执行者多半是具体的数据库，同时协调器和事务执行器可在一台机器上。 1、应用程序application发起一个请求到TC（事务协调器） 2、TC(事务协调器)将消息写到本地日志，再向所有的SI（事务执行者）的发送消息。 3、Si（事务执行者）接受到消息之后，执行本地事务但是不commit，如果成功返回yes否则no；同样返回      之前仍要进行日志记录。 4、Tc（事务协调器）接受到所有执行器返回的结果，如果所有的执行全部返回yes，那么发送commit消息给各个执行器，本地事务执行commit；若是有一个返回no，那么tc就会发送abort消息给各个执行器 注：tc和si把发送和接收到的消息存放到本地日志里，主要为了故障恢复复用，如若某一个si从故障中恢复后，先检查本地日志的内容，如果已接收到commit则本地事务执行器commit；若是abort，则回滚； 若是yes则在tc询问，确定下一步；若是什么都没有则可能前面执行已经崩溃，需要回滚。 熟悉java的同学可以看：<a href="http://acen-chen.iteye.com/blog/1055481" target="_blank" rel="noopener">http://acen-chen.iteye.com/blog/1055481</a> 采用分布式事务，也满足了我们前面的需求，同时新的问题随之而来 1、两阶段提交涉及多个节点的网络通信，通信时间如果过长 2、事务的相对时间长了，那么锁定资源的时间也就长了 那么在高并发的服务中，就会存在严重的性能问题。 3、消息队列 在高并发的环境中，我们一般会采用消息队列来避免分布式事务的执行 这和实际生活中，我们去饭店吃饭很类似，首先点单，这时服务员给你一张小票，等待服务器给你端上你的饭菜。 在使用消息队列我们需要做到可靠凭证的保存(分布式事务的消息)，有如下两种方式 方式1、支付宝完成扣钱的动作时，并记录消息数据，消息数据和业务数据在同一个数据库实例 BEGIN TRANSACTION update A set amount=amount - 1000 where uid = 100； INSERT INTO MESSAGE(UID，AMOUNT,STATUS) VALUES(1，1000，1) END TRANSACTION COMMIT; 那么我们可以将支付宝完成扣钱操作的消息通过及时服务发给余额宝，余额宝完成处理返回成功消息，支付宝收到消息，清除消息表中对应的消息记录，即完成本次扣钱操作。 方式2、 1）支付宝在扣款事务提交之前，向实时消息服务请求发送消息，实时消息服务只记录消       息数据，而不真正发送，只有消息发送成功后才会提交事务； 2）当支付宝扣款事务被提交成功后，向实时消息服务确认发送。只有在得到确认发送指令后，实时消息服务才真正发送该消息； 3）当支付宝扣款事务提交失败回滚后，向实时消息服务取消发送。在得到取消发送指令后，该消息将不会被发送； 4）对于那些未确认的消息或者取消的消息，需要有一个消息状态确认系统定时去支付宝系统查询这个消息的状态并进行更新。为什么需要这一步骤，举个例子：假设在第2步支付宝扣款事务被成功提交后，系统挂了，此时消息状态并未被更新为“确认发送”，从而导致消息不能被发送。 优点：消息数据独立存储，降低业务系统与消息系统间的耦合； 缺点：一次消息发送需要两次请求；业务处理服务需要实现消息状态回查接口 ———————————————————————————————————————————— 那么如上的消息队列也就解决了我们实际业务中的高并发情况下分布式事务处理性能低下的问题 在使用消息队列防止重复投递消息 解决方法很简单，增加消息应用状态表（message_apply），通俗来说就是个账本，用于记录消息的消费情况，每次来一个消息，在真正执行之前，先去消息应用状态表中查询一遍，如果找到说明是重复消息，丢弃即可，如果没找到才执行，同时插入到消息应用状态表（同一事务）。 for each msg in queue Begin transaction select count(*) as cnt from message_apply where msg_id=msg.msg_id; if cnt==0 then update B set amount=amount+10000 where userId=1; insert into message_apply(msg_id) values(msg.msg_id); End transaction commit;</p>

            
            <p class="more">
                <a href="/2015/09/22/2019030500009/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/22/2019030500009/" title="使用消息系统避免分布式事务">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/2.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/21/2019030500075/">
    		mysql启动的四种方式
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-21T08:30:04.000Z">2015-09-21</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>在创建库的时候指定字符集 GBK: create database  database_name  DEFAULT CHARACTER SET gbk COLLATE gbk_chinese_ci; UTF8: CREATE DATABASE `test2` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci; 在创建表的时候你可以通过添加一个ENGINE 或TYPE 选项到CREATE TABLE语句来告诉MySQL你要创建什么类表并指定表的存储引擎： CREATE TABLE t (i INT) ENGINE = INNODB; CREATE TABLE t (i INT) TYPE = MEMORY; 要把一个表从一个类型转到另一个类型，可使用ALTER TABLE语句，这个语句指明新的类型： ALTER TABLE t ENGINE = MYISAM; ALTER TABLE t TYPE = BDB mysql 建表字符集 1.列出MYSQL支持的所有字符集： SHOW CHARACTER SET; 2.当前MYSQL服务器字符集设置 SHOW VARIABLES LIKE ‘character_set_%’; 3.当前MYSQL服务器字符集校验设置 SHOW VARIABLES LIKE ‘collation_%’; 4.显示某数据库字符集设置 show create database 数据库名; 5.显示某数据表字符集设置 show create table 表名; 6.修改数据库字符集 alter database 数据库名 default character set ‘utf8’; 7.修改数据表字符集 alter table 表名 default character set ‘utf8’; 8.建库时指定字符集 create database 数据库名 character set gbk collate gbk_chinese_ci; 9.建表时指定字符集 CREATE TABLE `mysqlcode` ( `id` TINYINT( 255 ) UNSIGNED NOT NULL AUTO_INCREMENT PRIMARY KEY , `content` VARCHAR( 255 ) NOT NULL  <a href="http://www.2cto.com" target="_blank" rel="noopener">www.2cto.com</a> ) TYPE = MYISAM CHARACTER SET gbk COLLATE gbk_chinese_ci; 库字符集，在my.cnf中缺少了如下代码： [client] default-character-set=utf8 [mysqld] default-character-set=utf8 10.修改数据库的字符集 mysql&gt;use mydb mysql&gt;alter database mydb character set utf-8; 创建数据库指定数据库的字符集 mysql&gt;create database mydb character set utf-8; 通过配置文件修改: 修改/var/lib/mysql/mydb/db.opt default-character-set=latin1 default-collation=latin1_swedish_ci 为  <a href="http://www.2cto.com" target="_blank" rel="noopener">www.2cto.com</a> default-character-set=utf8 default-collation=utf8_general_ci 11.MySQL服务器能够支持多种字符集。可以使用SHOW CHARACTER SET语句列出可用的字符集： mysql&gt; SHOW CHARACTER SET; 如果不加以上代码，那么即便MYSQL编译安装时指定的编码是UTF8，那么在建库时其默认编码仍是LATIN1，而由于字符集的继承性，库中的表也是LATIN1的了。mysql的四种启动方式: 1、mysqld 启动mysql服务器:./mysqld –defaults-file=/etc/my.cnf –user=root 客户端连接: mysql –defaults-file=/etc/my.cnf or mysql -S /tmp/mysql.sock 2、mysqld_safe 启动mysql服务器:./mysqld_safe –defaults-file=/etc/my.cnf –user=root &amp; 客户端连接: mysql –defaults-file=/etc/my.cnf or mysql -S /tm/mysql.sock 3、mysql.server cp -v /usr/local/mysql/support-files/mysql.server /etc/init.d/ chkconfig –add mysql.server 启动mysql服务器:service mysql.server {start|stop|restart|reload|force-reload|status} 客户端连接:同1、2 4、mysqld_multi mkdir $MYSQL_BASE/data2 cat &lt;<-eof>&gt; /etc/my.cnf [mysqld_multi] mysqld    = /usr/local/mysql/bin/mysqld_safe mysqladmin = /user/local/mysql/bin/mysqladmin user = mysqladmin password = mysqladmin [mysqld3306] port            = 3306 socket          = /tmp/mysql3306.sock pid-file    = /tmp/mysql3306.pid skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M basedir        = /usr/local/mysql datadir        = /usr/local/mysql/data [mysqld3307] port            = 3307 socket          = /tmp/mysql3307.sock pid-file    = /tmp/mysql3307.pid skip-external-locking key_buffer_size = 16M max_allowed_packet = 1M table_open_cache = 64 sort_buffer_size = 512K net_buffer_length = 8K read_buffer_size = 256K read_rnd_buffer_size = 512K myisam_sort_buffer_size = 8M basedir        = /usr/local/mysql datadir        = /usr/local/mysql/data2 EOF #mysql -S /tmp/mysql3306.sock mysql&gt;GRANT SHUTDOWN ON <em>.</em> TO ‘mysqladmin‘@’localhost’ identified by ‘mysqladmin’ with grant option; #mysql -S /tmp/mysql3307.sock mysql&gt;GRANT SHUTDOWN ON <em>.</em> TO ‘mysqladmin‘@’localhost’ identified by ‘mysqladmin’ with grant option; 启动mysql服务器:./mysqld_multi –defaults-file=/etc/my.cnf start 3306-3307 关闭mysql服务器:mysqladmin shutdown</-eof></p>

            
            <p class="more">
                <a href="/2015/09/21/2019030500075/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/21/2019030500075/" title="mysql启动的四种方式">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/21/2019030500037/">
    		死锁的预防和解除
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-21T08:26:38.000Z">2015-09-21</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/死锁/" title="死锁">死锁</a> / 
    
        <a href="/tags/解除/" title="解除">解除</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>产生死锁的原因主要是： （1）系统资源不足。 （2） 进程运行推进的顺序不合适。 （3）资源分配不当等。 如果系统资源充足，进程的资源请求都能够得到满足，死锁出现的可能性就很低，否则就会因争夺有限的资源而陷入死锁。其次，进程运行推进顺序与速度不同，也可能产生死锁。 产生死锁的四个必要条件： （1） 互斥条件：一个资源每次只能被一个进程使用。 （2） 请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放。 （3） 不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺。 （4） 循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系。 这四个条件是死锁的必要条件，只要系统发生死锁，这些条件必然成立，而只要上述条件之一不满足，就不会发生死锁。 死锁的预防和解除： 理解了死锁的原因，尤其是产生死锁的四个必要条件，就可以最大可能地避免、预防和解除死锁。所以，在系统设计、进程调度等方面注意如何不让这四个必要条件成立，如何确定资源的合理分配算法，避免进程永久占据系统资源。此外，也要防止进程在处于等待状态的情况下占用资源,在系统运行过程中，对进程发出的每一个系统能够满足的资源申请进行动态检查，并根据检查结果决定是否分配资源，若分配后系统可能发生死锁，则不予分配，否则予以分配 。因此，对资源的分配要给予合理的规划。 如何将死锁减至最少 虽然不能完全避免死锁，但可以使死锁的数量减至最少。将死锁减至最少可以增加事务的吞吐量并减少系统开销，因为只有很少的事务回滚，而回滚会取消事务执行的所有工作。由于死锁时回滚而由应用程序重新提交。 下列方法有助于最大限度地降低死锁： （1）按同一顺序访问对象。 （2）避免事务中的用户交互。 （3）保持事务简短并在一个批处理中。 （4）使用低隔离级别。 （5）使用绑定连接。 按同一顺序访问对象 如果所有并发事务按同一顺序访问对象，则发生死锁的可能性会降低。例如，如果两个并发事务获得 Supplier 表上的锁，然后获得 Part 表上的锁，则在其中一个事务完成之前，另一个事务被阻塞在 Supplier 表上。第一个事务提交或回滚后，第二个事务继续进行。不发生死锁。将存储过程用于所有的数据修改可以标准化访问对象的顺序。 避免事务中的用户交互 避免编写包含用户交互的事务，因为运行没有用户交互的批处理的速度要远远快于用户手动响应查询的速度，例如答复应用程序请求参数的提示。例如，如果事务正在等待用户输入，而用户去吃午餐了或者甚至回家过周末了，则用户将此事务挂起使之不能完成。这样将降低系统的吞吐量，因为事务持有的任何锁只有在事务提交或回滚时才会释放。即使不出现死锁的情况，访问同一资源的其它事务也会被阻塞，等待该事务完成。 保持事务简短并在一个批处理中 在同一数据库中并发执行多个需要长时间运行的事务时通常发生死锁。事务运行时间越长，其持有排它锁或更新锁的时间也就越长，从而堵塞了其它活动并可能导致死锁。 保持事务在一个批处理中，可以最小化事务的网络通信往返量，减少完成事务可能的延迟并释放锁。 使用低隔离级别 确定事务是否能在更低的隔离级别上运行。执行提交读允许事务读取另一个事务已读取（未修改）的数据，而不必等待第一个事务完成。使用较低的隔离级别（例如提交读）而不使用较高的隔离级别（例如可串行读）可以缩短持有共享锁的时间，从而降低了锁定争夺。 使用绑定连接 使用绑定连接使同一应用程序所打开的两个或多个连接可以相互合作。次级连接所获得的任何锁可以象由主连接获得的锁那样持有，反之亦然，因此不会相互阻塞。 用存储过程查出引起死锁的进程和SQL语句 假如发生了死锁，我们怎么去检测具体发生死锁的是哪条SQL语句或存储过程？此时我们可以使用以下存储过程来检测，就可以查出引起死锁的进程和SQL语句。</p>

            
            <p class="more">
                <a href="/2015/09/21/2019030500037/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/21/2019030500037/" title="死锁的预防和解除">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/21/2019030500038/">
    		浅谈事务隔离级别
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-21T08:25:01.000Z">2015-09-21</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/事务/" title="事务">事务</a> / 
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>一、对于同时运行的多个事务, 当这些事务访问数据库中相同的数据时, 如果没有采取必要的隔离机制, 就会导致各种并发问题: 脏读: 对于两个事务 T1, T2, T1 读取了已经被 T2 更新但还没有被提交的字段. 之后, 若 T2 回滚, T1读取的内容就是临时且无效的. 不可重复读: 对于两个事务T1, T2, T1 读取了一个字段, 然后 T2 更新了该字段. 之后, T1再次读取同一个字段, 值就不同了. 幻读: 对于两个事务T1, T2, T1 从一个表中读取了一个字段, 然后 T2 在该表中插入了一些新的行. 之后, 如果 T1 再次读取同一个表, 就会多出几行. 二、数据库事务的隔离性: 数据库系统必须具有隔离并发运行各个事务的能力, 使它们不会相互影响, 避免各种并发问题. 三、一个事务与其他事务隔离的程度称为隔离级别. 数据库规定了多种事务隔离级别, 不同隔离级别对应不同的干扰程度, 隔离级别越高, 数据一致性就越好, 但并发性越弱. 四、数据库提供的 4 种事务隔离级别: ●READ UNCOMMITTED(读未提交数据)：允许事物读取未被其他事物提交的变更、脏读、不可重复读和幻读的问题都会出现。 ●READ COMMITED(读已提交数据)：只允许事物读取已经被其他事物提交的变更，可以避免脏读，但不可重复读和幻读问题仍然可能出现。 ●REPEATABLE READ(可重复读)：确保一个事物可以多次从一个字段中读取相同的值，在合格事物持续期间，禁止其他事物岁这个字段进行更新，可以避免脏读和不可重复读，但幻读问题仍然存在。 ●SERIALIZABLE(串行化)：确保事物可以从一个表中读取相同的行，在这个事物持续期间，禁止其他事物对该表执行插入、更新和删除操作。所有并发问题都可以避免，但性能十分低下。 五、Oracle 支持的 2 种事务隔离级别：READ COMMITED, SERIALIZABLE。 Oracle 默认的事务隔离级别为: READ COMMITED 六、Mysql 支持 4 种事务隔离级别. Mysql 默认的事务隔离级别为: REPEATABLE READ</p>

            
            <p class="more">
                <a href="/2015/09/21/2019030500038/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/21/2019030500038/" title="浅谈事务隔离级别">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/17/2019030500039/">
    		用plsql连接数据库创建视图
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-17T09:00:26.000Z">2015-09-17</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/数据库/" title="数据库">数据库</a> / 
    
        <a href="/tags/PL-SQL/" title="PL/SQL">PL/SQL</a> / 
    
        <a href="/tags/视图/" title="视图">视图</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>1 视图介绍 视图是一个逻辑表，也是一个非常重要的方案对象。实际上，视图是查看表的一种方式。视图是对根据预定义的选择标准由一个或多个行的集合建立起来的动态表的静态定义。视图可以用来定义来自一个或多个表的行和列的多种连接。通过视图，可以查看到表中的数据。 视图是查看数据库表中的数据的一种方法。视图提供了存储预定义的查询语句作为数据库中的对象以备以后使用的能力。视图只是一种逻辑对象，是一种虚拟表，并不是物理对象，因为视图不占物理存储空间。在视图中被查询的表称为视图的基表。 通常通过它就像使用表一样访问数据。要记住通过视图引用的数据通常来自它后面的基表。视图应该使用一致的命名约定。例如，给所有的视图增加一个前缀，如每一个视图都以v_、view_或vw_开头。这样，可以使用户在看到名称时就立即知道它代表的对象是视图。 2 视图好处 使用视图的优点，如集中用户使用的数据、掩码数据的复杂性、简化权限管理以及为向其他应用程序输出而重新组织数据等。 集中用户使用的数据： 视图创建了一种可以控制的环境，即表中的一部分数据允许访问，而另外一部分数据则不允许访问。那些没有必要的，敏感的或不适合的数据都从视图中排除掉了。 掩盖数据库的复杂性： 视图把数据库设计的复杂性与用户屏蔽分开。这样就为数据库开发人员提供了一种改变数据库的设计而不影响用户使用的能力。用户只需要查询视图就可以得到所需的数据，而不用编写复杂的查询语句或者执行脚本。 简化用户权限的管理：   数据库所有者可以把视图的权限授予需要查询的用户，而不必将基表中某些列的查询权限授予用户。 3 视图创建 可以使用3种方法创建视图，一种方法是使用create view 语句，另一种方法是使用DBA studio 图形工具，还可以使用创建视图向导来创建。 使用create view 语句创建视图 create [or replace][force | noforce] view [user.] viewName (column [,column2]…) as query [with check option[Constraint constraint]] [with read only] or replace 表示如果同名的视图存在，则使用新视图替代已有的视图。 force 强制创建视图，不考虑基表是否存在，是否具有使用基表数据的权限。 noforce 只有基表存在且具有权限，才可以创建视图。 user    表示创建视图的用户名。 viewName  表示将要在数据库上创建的视图名称。 column  指定视图中的列名。 query 表示生成视图的select语句。 with check option 指定强制检查通过视图修改数据的操作。 constraint  表示指定的约束名称。 with read only： 表示创建的视图只能检索数据，不能修改数据。   <img src="/uploads/2015/09/0_1315294657xlxy.bmp" alt>   4 视图和表的关系 视图和表是两种不同的数据库对象，其中的区别之一是在修改数据方面。修改表中的数据是直接修改数据，而修改视图中的数据是间接修改数据。因为视图本身并不包含数据，修改视图中的数据就是通过视图修改表中的数据。因此，修改视图中的数据有许多特殊的限制。 <img src="/uploads/2015/09/0_1315294856I5t5.bmp" alt></p>

            
            <p class="more">
                <a href="/2015/09/17/2019030500039/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/17/2019030500039/" title="用plsql连接数据库创建视图">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/7.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/16/2019030500150/">
    		PL/SQL Developer配置使用说明
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-16T07:26:42.000Z">2015-09-16</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a> / 
    
        <a href="/tags/PL-SQL/" title="PL/SQL">PL/SQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>PL/SQL Developer是一个集成开发环境，专门面向Oracle数据库存储程序单元的开发。如今，有越来越多的商业逻辑和应用逻辑转向了Oracle Server，因此，PL/SQL编程也成了整个开发过程的一个重要组成部分。PL/SQL Developer侧重于易用性、代码品质和生产力，充分发挥Oracle应用程序开发过程中的主要优势。 <strong>以下测试环境为 windows 7 32位。</strong> PL/SQL Developer绿色版 下载链接：<a href="http://pan.baidu.com/s/1hqwDToo" target="_blank" rel="noopener">http://pan.baidu.com/s/1hqwDToo</a> Oracle9i客户端精简版下载链接：<a href="http://pan.baidu.com/s/1mgL8pXu" target="_blank" rel="noopener">http://pan.baidu.com/s/1mgL8pXu</a> <strong>详细配置说明：</strong> 1）解压 PLSQLDeveloper.zip，此为绿色包，解压即可用： <img src="http://img.blog.csdn.net/20150914215145422" alt> 2）进入解压后的文件夹，plsqldev.exe 即为其可执行程序，暂时不能使用，还得相应配置，请看后面介绍： <img src="http://img.blog.csdn.net/20150914215245113" alt> 3）解压 Oracle9i客户端精简版.rar ： <img src="http://img.blog.csdn.net/20150914215437897" alt> 4）解压后，双击安装其中的安装包，默认只能安装在 C 盘： <img src="http://img.blog.csdn.net/20150914215631435" alt> 5）安装成功，C 盘多出一个Oracle文件夹： <img src="http://img.blog.csdn.net/20150914215824988" alt> 6）给 oracle 客户端设置 Path 环境变量： a)先拷贝需要设置环境变量的那个路径： <img src="http://img.blog.csdn.net/20150914220149021" alt> b)右击电脑 -&gt; 属性 -&gt; 高级系统设置 -&gt; 高级 -&gt; 环境变量： <img src="http://img.blog.csdn.net/20150914220356736" alt> <img src="http://img.blog.csdn.net/20150914220443731" alt> <img src="http://img.blog.csdn.net/20150914220537246" alt> <img src="http://img.blog.csdn.net/20150914220629589" alt> Path 开头添加如下路径，路径和路径之间以分号分割： <img src="http://img.blog.csdn.net/20150914220847220" alt> 7)配置 PL/SQL Developer，打开时会跳出一个登陆窗口，取消即可，然后跳进一个 Developer 界面（没有登录）： <img src="http://img.blog.csdn.net/20150914221600770" alt> <img src="http://img.blog.csdn.net/20150914221657105" alt> 8）工具 -&gt; 首选项：</p>
<blockquote>
<blockquote>
<p>Oracle 主目录名 -&gt; C:\Oracle\ora90\BIN</p>
</blockquote>
<blockquote>
<p>OCI 库 -&gt; C:\Oracle\ora90\BIN\oci.dll</p>
</blockquote>
</blockquote>
<p><img src="http://img.blog.csdn.net/20150914221939746" alt> <img src="http://img.blog.csdn.net/20150914222054689" alt> 9）应用 -&gt; 确定 -&gt; 重新运行软件，发现比之前的登录界面多了一个选项“连接为”： <img src="http://img.blog.csdn.net/20150914222432701" alt> 10）添加数据库服务器信息，在 tnsnames.ora 配置文件，添加服务器信息： <img src="http://img.blog.csdn.net/20150914222647347" alt> 11）本示例中，在 tnsnames.ora 的最后添加如下内容：</p>
<p><strong>[plain]</strong></p>
<ol>
<li>ORA90 =</li>
<li>(DESCRIPTION =</li>
<li>(ADDRESS_LIST =</li>
<li>(ADDRESS = (PROTOCOL = TCP)(HOST = 192.168.161.90)(PORT = 1521))</li>
<li>)</li>
<li>(CONNECT_DATA =</li>
<li>(SERVICE_NAME = ora11)</li>
<li>)</li>
<li>)</li>
</ol>
<p><img src="http://img.blog.csdn.net/20150914222848472" alt> 12）登录数据库服务器，填写登录信息： <img src="http://img.blog.csdn.net/20150914222940988" alt> 13）成功登录后的操作界面： <img src="http://img.blog.csdn.net/20150914223251032" alt> <img src="http://img.blog.csdn.net/20150914223359442" alt></p>

            
            <p class="more">
                <a href="/2015/09/16/2019030500150/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/16/2019030500150/" title="PL/SQL Developer配置使用说明">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/6.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/SQL-Server/">SQL Server</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/16/2019030500032/">
    		数据库连接字符串的困惑
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-16T07:25:03.000Z">2015-09-16</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/CentOS6-5/" title="CentOS6.5">CentOS6.5</a> / 
    
        <a href="/tags/Hello-World/" title="Hello World">Hello World</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <h1 id="程序员方阵"><a href="#程序员方阵" class="headerlink" title="程序员方阵"></a>程序员方阵</h1><p>说起Hello World，不由得想起最近的抗战胜利70周年阅兵；网络中走来的程序员方阵。 现在向我们走来的是程序员方阵！ 他们穿着拖鞋，披着毛巾， 左手拿着键盘，右手举着鼠标， 腋下夹着USB转换器。 他们因睡眠不足而显得精神不振， 喊着微弱的口号走过主席台。 主席问候：程序员们辛苦了! 程序员方队异口同声地答道：Hello World！ 习大大的讲话很给力：让我们共同铭记历史所启示的伟大真理：正义必胜！和平必胜！人民必胜！</p>
<h1 id="数据库连接字符串的困惑"><a href="#数据库连接字符串的困惑" class="headerlink" title="数据库连接字符串的困惑"></a>数据库连接字符串的困惑</h1><p>通常来说，第一个Hello World程序是无压力的，个别开发环境安装、配置起来可能比较吃力，就像前段时间Visual Studio推出Linux版本，我基于CentOS6.5安装，结果需要升级GCC的版本，研究了半天也没搞定！ 我最初学习的是VB.NET，学习网页后台开发，照着书中的例子学习的也还算顺利；但到学习数据库的时候就卡住了，当时是连接的ACCESS数据库，具体遇到的错误已经不记得了，只大概的记得这问题搞了一两个月也没搞出来！当时是2003年左右，网络上能找到的东西也非常有限，不像现在一搜一大把的资料源码之类的；当时应该有一些知名的论坛了，不过那时候人比较傻，也不知道去找论坛发帖；当时访问Google还不用翻墙呢，不过英文也不好，也没想到去外面看看！ 实在研究不通了，就放下了，先去研究点别的；过了大概一个多月吧，又回过头来研究，结果很快搞通过了，连接数据库成功了，突然觉得豁然开朗！</p>
<h1 id="数据库连接字符串的组成"><a href="#数据库连接字符串的组成" class="headerlink" title="数据库连接字符串的组成"></a>数据库连接字符串的组成</h1><p>连接字符串的是一个以分号为界，划分键值参数对的列表。</p>
<h2 id="驱动程序"><a href="#驱动程序" class="headerlink" title="驱动程序"></a>驱动程序</h2><p>之所以可以通过一个字符串连接并操作数据库，是因为有驱动程序的支持。 <strong>常见的驱动程序如下：</strong></p>
<h3 id="ODBC"><a href="#ODBC" class="headerlink" title="ODBC"></a>ODBC</h3><p>ODBC(Open Database Connectivity，开放数据库互连)是微软公司开放服务结构(WOSA,Windows Open Services Architecture)中有关数据库的一个组成部分，它建立了一组规范，并提供了一组对数据库访问的标准API（应用程序编程接口）。这些API利用SQL来完成其大部分任务。ODBC本身也提供了对SQL语言的支持，用户可以直接将SQL语句送给ODBC。</p>
<h3 id="OLE-DB"><a href="#OLE-DB" class="headerlink" title="OLE DB"></a>OLE DB</h3><p>OLE DB 是 Microsoft 的一个战略性系统级编程接口，用于管理整个组织内的数据。OLE DB 是建立在 ODBC 功能之上的一个开放规范。ODBC 是为访问关系型数据库而专门开发的，OLE DB 则用于访问关系型和非关系型信息源，例如主机 ISAM/VSAM 和层次数据库，电子邮件和文件系统存储，文本、图形和地理数据以及自定义业务对象。OLE DB 定义了一组 COM 接口，对各种数据库管理系统服务进行封装，并允许创建软件组件，实现这些服务。OLE DB 组件包括数据提供程序（包含和表现数据）、数据使用者（使用数据）和服务组件（处理和传送数据，例如，查询处理器和游标引擎）。OLE DB 接口有助于平滑地集成组件，这样，OLE DB 组件厂商就可以快速地向市场提供高质量 OLE DB 组件。此外，OLE DB 包含了一个连接 ODBC 的“桥梁”，对现用的各种 ODBC 关系型数据库驱动程序提供一贯的支持。</p>
<h3 id="JDBC"><a href="#JDBC" class="headerlink" title="JDBC"></a>JDBC</h3><p>JDBC（Java Data Base Connectivity,java数据库连接）是一种用于执行SQL语句的Java API，可以为多种关系数据库提供统一访问，它由一组用Java语言编写的类和接口组成。JDBC提供了一种基准，据此可以构建更高级的工具和接口，使数据库开发人员能够编写数据库应用程序，同时，JDBC也是个商标名。</p>
<h2 id="比较"><a href="#比较" class="headerlink" title="比较"></a>比较</h2><p>目前，Microsoft 的 ODBC API 可能是使用最广的、用于访问关系数据库的编程接口。它能在几乎所有平台上连接几乎所有的数据库。为什么 Java 不使用 ODBC？对这个问题的回答是：Java 可以使用 ODBC，但最好是在 JDBC 的帮助下以JDBC-ODBC桥的形式使用，这一点我们稍后再说。现在的问题已变成：”为什么需要 JDBC”？答案是显然的：ODBC 不适合直接在 Java 中使用，因为它使用 C 语言接口。从Java 调用本地 C代码在安全性、实现、坚固性和程序的自动移植性方面都有许多缺点。从 ODBC C API 到 Java API 的字面翻译是不可取的。例如，Java 没有指针，而 ODBC 却对指针用得很广泛（包括很容易出错的指针”void *”）。您可以将 JDBC 想象成被转换为面向对象接口的 ODBC，而面向对象的接口对 Java程序员来说较易于接受。 ODBC 很难学。它把简单和高级功能混在一起，而且即使对于简单的查询，其选项也极为复杂。相反，JDBC 尽量保证简单功能的简便性，而同时在必要时允许使用高级功能。启用”纯 Java “机制需要象 JDBC 这样的 Java API。如果使用ODBC，就必须手动地将 ODBC 驱动程序管理器和驱动程序安装在每台客户机上。如果完全用 Java 编写 JDBC 驱动程序则 JDBC代码在所有 Java 平台上（从网络计算机到大型机）都可以自 动安装、移植并保证安全性。 总之，JDBC API 对于基本的 SQL 抽象和概念是一种自然的 Java 接口。它建立在 ODBC 上而不是从零开始。因此，熟悉 ODBC 的程序员将发现 JDBC 很容易使用。JDBC 保留了 ODBC 的基本设计特征；事实上，两种接口都基于 X/Open SQL CLI（调用级接口）。它们之间最大的区别在于：JDBC 以 Java 风格与优点为基础并进行优化，因此更加易于使用。 目前，Microsoft 又引进了 ODBC 之外的新 API： RDO、 ADO 和OLE DB。这些设计在许多方面与 JDBC 是相同的，即它们都是面向对象的数据库接口且基于可在 ODBC 上实现的类。但在这些接口中，我们未看见有特别的功能使我们要转而选择它们来替代 ODBC，尤其是在 ODBC 驱动程序已建立起较为完善的市场的情况下。它们最多也就是在 ODBC 上加了一种装饰而已。</p>
<h1 id="数据库链接字符串大全"><a href="#数据库链接字符串大全" class="headerlink" title="数据库链接字符串大全"></a>数据库链接字符串大全</h1><h2 id="SQL-Server-2005"><a href="#SQL-Server-2005" class="headerlink" title="SQL Server 2005"></a>SQL Server 2005</h2><h3 id="SQL-Native-Client-ODBC-Driver"><a href="#SQL-Native-Client-ODBC-Driver" class="headerlink" title="SQL Native Client ODBC Driver"></a>SQL Native Client ODBC Driver</h3><p>标准安全连接 Driver={SQL Native Client};Server=myServerAddress; Database=myDataBase;Uid=myUsername;Pwd=myPassword; 受信的连接 Driver={SQL Native Client}; Server=myServerAddress;Database=myDataBase;Trusted_Connection=yes; “Integrated Security=SSPI” 与 “Trusted_Connection=yes” 是相同的。 连接到一个SQL Server实例 指定服务器实例的表达式和其他SQL Server的连接字符串相同。 Driver={SQL Native Client};Server=myServerName/theInstanceName;Database=myDataBase; Trusted_Connection=yes; 指定用户名和密码 oConn.Properties(“Prompt”) = adPromptAlways Driver={SQL Native Client}; Server=myServerAddress;Database=myDataBase; 使用MARS (multiple active result sets) Driver={SQL Native Client};Server=myServerAddress;Database=myDataBase; Trusted_Connection=yes;MARS_Connection=yes; “MultipleActiveResultSets=true”与MARS_Connection=yes”是相同的。 使用ADO.NET 2.0作为MARS的模块。 MARS不支持ADO.NET 1.0和ADO.NET 1.1。 验证网络数据 Driver={SQL Native Client}; Server=myServerAddress;Database=myDataBase; Trusted_Connection=yes;Encrypt=yes; 使用附加本地数据库文件的方式连接到本地SQL Server Express实例 Driver={SQL Native Client};Server=./SQLExpress; AttachDbFilename=c:/asd/qwe/mydbfile.mdf; Database=dbname;Trusted_Connection=Yes; 为何要使用Database参数？如果同名的数据库已经被附加，那么SQL Server将不会重新附加。 使用附加本地数据文件夹中的数据库文件的方式连接到本地SQL Server Express实例 Driver={SQL Native Client};Server=./SQLExpress; AttachDbFilename=|DataDirectory|mydbfile.mdf; Database=dbname; Trusted_Connection=Yes; 为何要使用Database参数？如果同名的数据库已经被附加，那么SQL Server将不会重新附加。 数据库镜像 Data Source=myServerAddress; Failover Partner=myMirrorServer;Initial Catalog=myDataBase;Integrated Security=True;</p>
<h3 id="SQL-Native-Client-OLE-DB-Provider"><a href="#SQL-Native-Client-OLE-DB-Provider" class="headerlink" title="SQL Native Client OLE DB Provider"></a>SQL Native Client OLE DB Provider</h3><p>标准连接 Provider=SQLNCLI;Server=myServerAddress; Database=myDataBase;Uid=myUsername;Pwd=myPassword; 受信的连接 Provider=SQLNCLI;Server=myServerAddress; Database=myDataBase;Trusted_Connection=yes; 连接到SQL Server实例 指定服务器实例的表达式和其他SQL Server的连接字符串相同。 Provider=SQLNCLI;Server=myServerName/theInstanceName; Database=myDataBase;Trusted_Connection=yes; 使用帐号和密码 oConn.Properties(“Prompt”) = adPromptAlways oConn.Open “Provider=SQLNCLI;Server=myServerAddress;DataBase=myDataBase; 使用MARS (multiple active result sets) Provider=SQLNCLI;Server=myServerAddress;Database=myDataBase;Trusted_Connection=yes;MarsConn=yes; “MultipleActiveResultSets=true”和”MARS_Connection=yes”是相同的。 使用ADO.NET 2.0作为MARS的模块。 MARS不支持ADO.NET 1.0和ADO.NET 1.1。 验证网络数据 Provider=SQLNCLI;Server=myServerAddress; Database=myDataBase;Trusted_Connection=yes;Encrypt=yes; 使用附加本地数据库文件的方式连接到本地SQL Server Express实例 Provider=SQLNCLI;Server=./SQLExpress;AttachDbFilename=c:/asd/qwe/mydbfile.mdf; Database=dbname;Trusted_Connection=Yes; 使用附加本地数据文件夹中的数据库文件的方式连接到本地SQL Server Express实例 Provider=SQLNCLI;Server=./SQLExpress; AttachDbFilename=|DataDirectory|mydbfile.mdf; Database=dbname;Trusted_Connection=Yes; 数据库镜像 Data Source=myServerAddress;Failover Partner=myMirrorServer; Initial Catalog=myDataBase;Integrated Security=True;</p>
<h3 id="SqlConnection-NET"><a href="#SqlConnection-NET" class="headerlink" title="SqlConnection (.NET)"></a>SqlConnection (.NET)</h3><p>标准连接 Data Source=myServerAddress; Initial Catalog=myDataBase;User Id=myUsername;Password=myPassword; Standard Security alternative syntax Server=myServerAddress;Database=myDataBase;User ID=myUsername;Password=myPassword;Trusted_Connection=False; 受信任的连接 Data Source=myServerAddress;Initial Catalog=myDataBase;Integrated Security=SSPI; Trusted Connection alternative syntax Server=myServerAddress;Database=myDataBase;Trusted_Connection=True; 连接到一个SQL Server的实例 指定服务器实例的表达式和其他SQL Server的连接字符串相同。 Server=myServerName/theInstanceName;Database=myDataBase;Trusted_Connection=True; 来自WinCE设备的安全连接 Data Source=myServerAddress; Initial Catalog=myDataBase; Integrated Security=SSPI;User ID=myDomain/myUsername;Password=myPassword; 仅能用于CE设备。 带有IP地址的连接 Data Source=190.190.200.100,1433;Network Library=DBMSSOCN;Initial Catalog=myDataBase;User ID=myUsername;Password=myPassword; 使用MARS (multiple active result sets) Server=myServerAddress;Database=myDataBase;Trusted_Connection=True; MultipleActiveResultSets=true; 使用ADO.NET 2.0作为MARS的模块。 MARS不支持ADO.NET 1.0和ADO.NET 1.1。 使用附加本地数据库文件的方式连接到本地SQL Server Express实例 Server=./SQLExpress;AttachDbFilename=c:/asd/qwe/mydbfile.mdf; Database=dbname;Trusted_Connection=Yes; 使用附加本地数据文件夹中的数据库文件的方式连接到本地SQL Server Express实例 Server=./SQLExpress;AttachDbFilename=|DataDirectory|mydbfile.mdf; Database=dbname;Trusted_Connection=Yes; 使用在SQL Server Express实例上的用户实例 Data Source=./SQLExpress;Integrated Security=true;AttachDbFilename=|DataDirectory|/mydb.mdf;User Instance=true; 数据库镜像 Data Source=myServerAddress;Failover Partner=myMirrorServer;Initial Catalog=myDataBase;Integrated Security=True; Asynchronous processing Server=myServerAddress; Database=myDataBase; Integrated Security=True; Asynchronous Processing=True;</p>
<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h3 id="MyODBC"><a href="#MyODBC" class="headerlink" title="MyODBC"></a>MyODBC</h3><p>MyODBC 2.50 本地数据库 Driver={mySQL};Server=localhost;Option=16834;Database=myDataBase; MyODBC 2.50 远程数据库 Driver={mySQL}; Server=myServerAddress;Port=3306; Option=131072;Stmt=; Database=myDataBase; Uid=myUsername; Pwd=myPassword; MyODBC 3.51 本地数据库 Driver={MySQL ODBC 3.51 Driver};Server=localhost;Database=myDataBase; User=myUsername;Password=myPassword;Option=3; MyODBC 3.51 远程数据库 Driver={MySQL ODBC 3.51 Driver};Server=data.domain.com;Port=3306; Database=myDataBase; User=myUsername; Password=myPassword;Option=3;</p>
<h3 id="OLE-DB-OleDbConnection-NET"><a href="#OLE-DB-OleDbConnection-NET" class="headerlink" title="OLE DB, OleDbConnection (.NET)"></a>OLE DB, OleDbConnection (.NET)</h3><p>标准 Provider=MySQLProv; Data Source=mydb; User Id=myUsername; Password=myPassword; Connector/Net 1.0 (.NET) 标准 Server=myServerAddress; Database=myDataBase; Uid=myUsername;Pwd=myPassword; 默认端口号是3306 指定端口号 Server=myServerAddress; Port=1234;Database=myDataBase; Uid=myUsername; Pwd=myPassword; 命名管道 Server=myServerAddress; Port=-1;Database=myDataBase; Uid=myUsername;Pwd=myPassword; 如果端口是-1，意思是告诉驱动程序使用命名管道网络协议来连接数据库。</p>
<h3 id="MySqlConnection-NET"><a href="#MySqlConnection-NET" class="headerlink" title="MySqlConnection (.NET)"></a>MySqlConnection (.NET)</h3><p>eInfoDesigns.dbProvider Data Source=myServerAddress; Database=myDataBase;User ID=myUsername; Password=myPassword; Command Logging=false; SevenObjects MySqlClient (.NET) 标准 Host=myServerAddress; UserName=myUsername; Password=myPassword; Database=myDataBase; Core Labs MySQLDirect (.NET) 标准 User ID=root;Password=myPassword;Host=localhost;Port=3306;Database=myDataBase; Direct=true;Protocol=TCP;Compress=false;Pooling=true;Min Pool Size=0;Max Pool Size=100;Connection Lifetime=0; MySQLDriverCS (.NET) 标准 Location=myServerAddress; Data Source=myDataBase; UserID=myUsername; Password=myPassword; Port=3306;Extended Properties=”“”“;</p>
<h2 id="Oracle"><a href="#Oracle" class="headerlink" title="Oracle"></a>Oracle</h2><h3 id="ODBC-1"><a href="#ODBC-1" class="headerlink" title="ODBC"></a>ODBC</h3><p>新版本 Driver={Microsoft ODBC for Oracle}; Server=myServerAddress; Uid=myUsername;Pwd=myPassword; 旧版本 Driver={Microsoft ODBC Driver for Oracle}; ConnectString=OracleServer.world; Uid=myUsername; Pwd=myPassword;</p>
<h3 id="OLE-DB-OleDbConnection-NET-1"><a href="#OLE-DB-OleDbConnection-NET-1" class="headerlink" title="OLE DB, OleDbConnection (.NET)"></a>OLE DB, OleDbConnection (.NET)</h3><p>标准连接 此连接字符串适用了微软的驱动。 Provider=msdaora;Data Source=MyOracleDB; User Id=myUsername; Password=myPassword; 受信连接 Provider=msdaora; Data Source=MyOracleDB; Persist Security Info=False; Integrated Security=Yes; 标准连接 由Oracle提供的驱动。 Provider=OraOLEDB. Oracle;Data Source=MyOracleDB; User Id=myUsername; Password=myPassword; 受信连接 Provider=OraOLEDB.Oracle;Data Source=MyOracleDB;OSAuthent=1; Oracle.DataAccess.Client.OracleConnection 标准 Data Source=TORCL;User Id=myUsername; Password=myPassword; 标准安全连接 Data Source=TORCL;Integrated Security=SSPI; 使用ODP.NET而不使用tnsnames.ora Data Source=(DESCRIPTION=(ADDRESS_LIST=(ADDRESS=(PROTOCOL=TCP)(HOST=MyHost) (PORT=MyPort)))(CONNECT_DATA=(SERVER=DEDICATED)(SERVICE_NAME=MyOracleSID))); User Id=myUsername;Password=myPassword; OracleConnection, Oracle Data Provider, ODP.NET. System.Data.OracleClient.OracleConnection. 标准 用于8i RC3及以后的版本 Data Source=MyOracleDB;Integrated Security=yes; 指定用户名和密码 用于8i RC3及以后的版本 Data Source=MyOracleDB; User Id=myUsername; Password=myPassword; Integrated Security=no; 忽略tnsnames.ora 另一种不需要使用DSN的连接方式 SERVER=(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=MyHost) (PORT=MyPort))(CONNECT_DATA=(SERVICE_NAME=MyOracleSID))); uid=myUsername;pwd=myPassword; 使用上面的连接字符串可能会导致Visual Studio报告错误。 如果您在使用中出现了这些问题，请使用下面的这种连接方式。 Data Source=(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=MyHost)(PORT=MyPort)) (CONNECT_DATA=(SERVICE_NAME=MyOracleSID))); User Id=myUsername; Password=myPassword; 使用连接池 如果连接池服务程序找不到已经存在的连接池，它将根据连接字符串创建一个新的池。 否则将循环使用池中已存在的连接。 Data Source=myOracleDB; User Id=myUsername; Password=myPassword;Min Pool Size=10;Connection Lifetime=120; Connection Timeout=60;Incr Pool Size=5;Decr Pool Size=2; Windows身份验证 Data Source=myOracleDB;User Id=/; 特权连接 使用SYSDBA Data Source=myOracleDB;User Id=SYS;Password=SYS; DBA Privilege=SYSDBA; 特权连接 使用SYSOPER Data Source=myOracleDB;User Id=SYS;Password=SYS;DBA Privilege=SYSOPER; 密码过期处理过程 当使用一个连接字符串连接数据库后，出现”密码已过期”的错误时。 请执行OpenWithNewPassword命令来提供新密码。 Data Source=myOracleDB;User Id=myUsername;Password=myPassword; oConn.OpenWithNewPassword(sTheNewPassword); Proxy验证 Data Source=myOracleDB; User Id=myUsername; Password=myPassword;Proxy User Id=pUserId; Proxy Password=pPassword; Core Labs OraDirect (.NET) Standard User ID=myUsername; Password=myPassword; Host=ora;Pooling=true; Min Pool Size=0;Max Pool Size=100;Connection Lifetime=0; Data Shape MS Data Shape Provider=MSDataShape.1;Persist Security Info=False;Data Provider=MSDAORA; Data Source=orac;User Id=myUsername; Password=myPassword;</p>
<h2 id="AS-400-iSeries"><a href="#AS-400-iSeries" class="headerlink" title="AS/400 (iSeries)"></a>AS/400 (iSeries)</h2><p>IBM .Net Data Provider 您需要使用 IBM.Data.DB2.iSeries 命名空间 DataSource=myServerAddress;UserID=myUsername; Password=myPassword;DataCompression=True; OLE DB, OleDbConnection (.NET) IBM Client Access OLE DB 适配器 Provider=IBMDA400;Data Source=MY_SYSTEM_NAME;User Id=myUsername; Password=myPassword; MY_SYSTEM_NAME是在OperationsNavigator中的系统连接名称。 IBM Client Access OLE DB 适配器 Provider=IBMDA400;Data Source=MY_SYSTEM_NAME;User Id=myUsername; Password=myPassword;Default Collection=MY_LIBRARY; MY_SYSTEM_NAME是系统连接的名称，MY_LIBRARY是iSeries Navigator中library的名称。 ODBC IBM Client Access ODBC 驱动 Driver={Client Access ODBC Driver (32-bit)};System=my_system_name; Uid=myUsername; Pwd=myPassword; IBM iSeries Access ODBC 驱动 这个驱动需要比IBM Client Access ODBC的驱动更新。 Driver={iSeries Access ODBC Driver};System=my_system_name; Uid=myUsername; Pwd=myPassword;</p>
<h2 id="Cache"><a href="#Cache" class="headerlink" title="Caché"></a>Caché</h2><p>ODBC 标准 DRIVER={InterSystems ODBC};SERVER=myServerAddress; DATABASE=myDataBase; UID=myUsername;PWD=myPassword; 特定端口 DRIVER={InterSystems ODBC};SERVER=myServerAddress;PORT=12345; DATABASE=myDataBase; UID=myUsername;PWD=myPassword; 特定协议 DRIVER={InterSystems ODBC};SERVER=myServerAddress;PORT=12345; DATABASE=myDataBase; PROTOCOL=TCP;STATIC CURSORS=1;UID=myUsername;PWD=myPassword;</p>
<h2 id="IBM-DB2"><a href="#IBM-DB2" class="headerlink" title="IBM DB2"></a>IBM DB2</h2><p>OLE DB, OleDbConnection (.NET) TCP/IP Provider=DB2OLEDB;Network Transport Library=TCPIP;Network Address=XXX.XXX.XXX.XXX; Initial Catalog=MyCtlg;Package Collection=MyPkgCol;Default Schema=Schema;User ID=myUsername; Password=myPassword; APPC Provider=DB2OLEDB;APPC Local LU Alias=MyAlias;APPC Remote LU Alias=MyRemote; Initial Catalog=MyCtlg;Package Collection=MyPkgCol; Default Schema=Schema;User ID=myUsername;Password=myPassword; IBM提供的OLE DB适配器 TCP/IP Provider=IBMDADB2;Database=myDataBase; Hostname=myServerAddress; Protocol=TCPIP;Port=50000; Uid=myUsername;Pwd=myPassword; ODBC 标准 Driver={IBM DB2 ODBC DRIVER}; Database=myDataBase;Hostname=myServerAddress; Port=1234;Protocol=TCPIP;Uid=myUsername;Pwd=myPassword;</p>
<h2 id="Firebird"><a href="#Firebird" class="headerlink" title="Firebird"></a>Firebird</h2><p>ODBC - IBPhoenix Open Source 标准 Driver=Firebird/InterBase(r) driver;Uid=SYSDBA; Pwd=masterkey; DbName=D:/FIREBIRD/examples/TEST.FDB; .NET - Firebird .Net Data Provider 标准 User=SYSDBA;Password=masterkey;Database=SampleDatabase.fdb; DataSource=localhost;Port=3050;Dialect=3; Charset=NONE;Role=; Connection lifetime=15;Pooling=true;MinPoolSize=0;MaxPoolSize=50;Packet Size=8192;ServerType=0;</p>
<h2 id="Informix"><a href="#Informix" class="headerlink" title="Informix"></a>Informix</h2><p>ODBC Informix 3.30 Dsn=;Driver={INFORMIX 3.30 32 BIT};Host=hostname;Server=myServerAddress; Service=service-name; Protocol=olsoctcp; Database=myDataBase;Uid=myUsername;Pwd=myPassword; Informix-CLI 2.5: Driver={Informix-CLI 2.5 (32 Bit)};Server=myServerAddress; Database=myDataBase; Uid=myUsername;Pwd=myPassword; OLE DB IBM Informix OLE DB Provider Provider=Ifxoledbc.2;Password=myPassword; User ID=myUsername; Data Source=dbName@serverName;Persist Security Info=true; IBM Informix .NET Provider IBM.Data.Informix.IfxConnection(命名空间) Database=myDataBase;Host=192.168.10.10; Server=db_engine_tcp; Service=1492; Protocol=onsoctcp;UID=myUsername;Password=myPassword; ##Ingres ODBC DSN-less Provider=MSDASQL.1;DRIVER=Ingres;SRVR=xxxxx;DB=xxxxx;Persist SecurityInfo=False;Uid=myUsername;Pwd=myPassword; SELECTLOOPS=N; ExtendedProperties=”SERVER=xxxxx;DATABASE=xxxxx;SERVERTYPE=INGRES”;</p>
<h2 id="Interbase"><a href="#Interbase" class="headerlink" title="Interbase"></a>Interbase</h2><p>ODBC, Easysoft 本地计算机 Driver={Easysoft IB6 ODBC}; Server=localhost ;Database=localhost:C:/mydatabase.gdb; Uid=myUsername; Pwd=myPassword; 远程计算机 Driver={Easysoft IB6 ODBC}; Server=myServerAddress; Database=ComputerName: C:/mydatabase.gdb; Uid=myUsername;Pwd=myPassword; ODBC, Intersolv 本地计算机 Driver={INTERSOLV InterBase ODBC Driver (<em>.gdb)}; Server=localhost; Database=localhost: C:/mydatabase.gdb; Uid=myUsername; Pwd=myPassword; 远程计算机 Driver={INTERSOLV InterBase ODBC Driver (</em>.gdb)}; Server=myServerAddress; Database=ComputerName: C:/mydatabase.gdb;Uid=myUsername; Pwd=myPassword; OLE DB, SIBPROvider 标准 provider=sibprovider;location=localhost:;data source=c:/databases/gdbs/mygdb.gdb; user id=SYSDBA; Password=masterkey; 版本 2.x Provider=SIBPROvider.2; Data Source=localhost:c:/databases/gdbs/mygdb.gdb; Persist Security Info=False; 指定字符集 provider=sibprovider;location=localhost:;data source=c:/databases/gdbs/mygdb.gdb; user id=SYSDBA; Password=masterkey; character set=ISO8859_1; 指定角色 provider=sibprovider;location=localhost:; data source=c:/databases/gdbs/mygdb.gdb;user id=SYSDBA; Password=masterkey; role=DIGITADORES; Lightbase 标准连接 标准 User=myUsername;Password=myPassword;UDB=USERBASE;Server=myServerAddress; Paradox ODBC 5.X Driver={Microsoft Paradox Driver (*.db )}; DriverID=538;Fil=Paradox 5.X; DefaultDir=c:/pathToDb/;Dbq=c:/pathToDb/;CollatingSequence=ASCII; 7.X Provider=MSDASQL.1;Persist Security Info=False; Mode=Read;Extended Properties=DSN=Paradox; DBQ=C:/myDb;DefaultDir=C:/myDb;DriverId=538; FIL=Paradox 7.X; MaxBufferSize=2048;PageTimeout=600;;Initial Catalog=C:/myDb; 请注意：以上的方法仅能从数据库获取数据。 Intersolv 3.11 ODBC Driver 7.X DSN=MyDSN;AUT=1;CT=7;DQ=0;FOC=0;IS=1; PW=myPassword;USF=1;ULQ=1; 并不是所有参数都是必填的。大多数参数都能够在DSN中进行设置。 Parameters definition AUT - ApplicationUsingThreads CT - CreateType DB - Database DSN - DataSourceName DQ - DeferQueryEvaluation FOC - FileOpenCache IS - IntlSort ND - NetDir PW - Passwords USF - UltraSafeCommit ULQ - UseLongQualifiers OleDbConnection (.NET) 标准 Provider=Microsoft.Jet.OLEDB.4.0;Data Source=c:/myDb;Extended Properties=Paradox 5.x; 注意：您仅需要指定数据库存放的地址而无需指定数据库的名称。</p>
<h2 id="SQLBase"><a href="#SQLBase" class="headerlink" title="SQLBase"></a>SQLBase</h2><p>OLE DB 标准 Provider=SQLBaseOLEDB;Data source=myServerAddress; Location=myDataBase; User Id=myUsername; Password=myPassword; SQLBase .NET Data Provider 标准SQLBase连接 DataSource=myServerAddress; UserId=myUsername; Password=myPassword;Poolsize=5;Connection Lifetime=60; “Poolsize” 表示多少SQLBase连接被打开，不论它们是否被立即使用。默认值是5。 “Connection Lifetime” 表示连接存在多长时间(单位：秒)。默认是60秒。</p>
<h2 id="SQL-Serve"><a href="#SQL-Serve" class="headerlink" title="SQL Serve"></a>SQL Serve</h2><p>ODBC 标准连接 Driver={SQL Server};Server=myServerAddress; Database=myDataBase;Uid=myUsername;Pwd=myPassword; 受信的连接 Driver={SQL Server};Server=myServerAddress; Database=myDataBase;Trusted_Connection=Yes; 指定帐号和密码 oConn.Properties(“Prompt”) = adPromptAlways Driver={SQL Server}; Server=myServerAddress;Database=myDataBase; OLE DB, OleDbConnection (.NET) 标准连接 Provider=sqloledb;Data Source=myServerAddress;Initial Catalog=myDataBase;User Id=myUsername;Password=myPassword; 受信的连接 Provider=sqloledb;Data Source=myServerAddress;Initial Catalog=myDataBase;Integrated Security=SSPI; 使用serverName/instanceName作为数据源可以指定SQL Server实例。 连接到一个SQL Server的实例 指定服务器实例的表达式和其他SQL Server的连接字符串相同。 Provider=sqloledb; Data Source=myServerName/theInstanceName; Initial Catalog=myDataBase;Integrated Security=SSPI; 指定帐户和密码 oConn.Provider = “sqloledb” oConn.Properties(“Prompt”) = adPromptAlways Data Source=myServerAddress;Initial Catalog=myDataBase; 使用IP地址的连接 Provider=sqloledb;Data Source=190.190.200.100,1433; Network Library=DBMSSOCN;Initial Catalog=myDataBase; User ID=myUsername; Password=myPassword; SqlConnection (.NET) 标准连接 Data Source=myServerAddress;Initial Catalog=myDataBase; User Id=myUsername;Password=myPassword; Standard Security alternative syntax Server=myServerAddress;Database=myDataBase;User ID=myUsername;Password=myPassword;Trusted_Connection=False; 受信任的连接 Data Source=myServerAddress;Initial Catalog=myDataBase;Integrated Security=SSPI; Trusted Connection alternative syntax Server=myServerAddress;Database=myDataBase;Trusted_Connection=True; 连接到SQL Server实例 指定服务器实例的表达式和其他SQL Server的连接字符串相同。 Server=myServerName/theInstanceName;Database=myDataBase; Trusted_Connection=True; 仅能用于CE设备。 Data Source=myServerAddress;Initial Catalog=myDataBase;Integrated Security=SSPI;User ID=myDomain/myUsername;Password=myPassword; 带有IP地址的连接 Data Source=190.190.200.100,1433;Network Library=DBMSSOCN;Initial Catalog=myDataBase; User ID=myUsername;Password=myPassword; 指定包的大小 Server=myServerAddress;Database=myDataBase;User ID=myUsername;Password=myPassword; Trusted_Connection=False;Packet Size=4096; 默认的包大小为8192字节。 Data Shape MS Data Shape Provider=MSDataShape;Data Provider=SQLOLEDB;Data Source=myServerAddress; Initial Catalog=myDataBase;User ID=myUsername;Password=myPassword;</p>

            
            <p class="more">
                <a href="/2015/09/16/2019030500032/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/16/2019030500032/" title="数据库连接字符串的困惑">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/6.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/11/2019030500067/">
    		MYSQL主备复制结构搭建与切换
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-11T05:01:22.000Z">2015-09-11</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <blockquote>
<p><strong>1 选择两个服务器，分别作为主备数据库</strong> <strong>2 登陆到服务器，安装相同版本mysql</strong></p>
<p><strong>[sql]</strong></p>
<ol>
<li>yum install mysql ;</li>
<li>yum install mysql-server;</li>
</ol>
<p><strong>3 启动mysql服务器 </strong> service  mysqld start <strong>4 分别root登陆mysql 执行如下命令</strong> 增加复制用户并授权（主备都在192.168.119.*网段，为了方便主备切换，两边都建立）</p>
<p><strong>[sql]</strong></p>
<ol>
<li>GRANT  REPLICATION SLAVE,REPLICATION CLIENT on <em>.</em> to repl@’192.168.119.%’ identified by ‘1234’;</li>
</ol>
<p><strong>5 配置/etc/my.cnf</strong> 第一服务器（主）</p>
<p><strong>[sql]</strong></p>
<ol>
<li>log_bin=mysql-bin</li>
<li>server_id=1</li>
</ol>
<p>第二个服务器（备）</p>
<p><strong>[sql]</strong></p>
<ol>
<li>log_bin=mysql-bin</li>
<li>server_id=2</li>
<li>read_only=1</li>
</ol>
<p><strong>6 重启两个mysql服务器**</strong>7 登陆主（root）执行**</p>
<p><strong>[sql]</strong></p>
<ol>
<li>show master status\G;</li>
</ol>
<p>显示 File: mysql-bin.000001 Position: 106 <strong>8 登陆备(root) 执行</strong> 测试 mysql -urepl -h192.168.119.128 -p1234 是否能连接到主库，不能需要检查防火墙或者/etc/my.cnf是否有访问限制，修改配置 mysql -uroot登陆本地库执行：</p>
<p><strong>[sql]</strong></p>
<ol>
<li>CHANGE MASTER TO</li>
<li>MASTER_HOST=’192.168.119.128’,</li>
<li>MASTER_USER=’repl’,</li>
<li>MASTER_PASSWORD=’1234’,</li>
<li>MASTER_LOG_FILE=’mysql-bin.000001’,</li>
<li>MASTER_LOG_POS=106;</li>
</ol>
<p><strong>[sql]</strong></p>
<ol>
<li>start slave;</li>
<li>show slave status\G;</li>
</ol>
<p><strong>9，验证</strong> 主库上创建表，备库上查看，可以看到 备库上repl创建表，显示The MySQL server is running with the –read-only option so it cannot execute this statement 因为配置了备库为read_only <strong>10，后续关注</strong> 以后重启主备库，不用再配置change master。每重启一次主库会发现logfile 变成一个新的文件mysql-bin.000004 <strong>11 ,主从切换</strong> 11.1 修改配置文件/etc/my.cnf</p>
<p><strong>[sql]</strong></p>
<ol>
<li>read-only=1（主库）</li>
<li>#read-only=1（备库）</li>
</ol>
<p>11.2 从库上执行</p>
<p><strong>[sql]</strong></p>
<ol>
<li>STOP SLAVE IO_THREAD;</li>
<li>SHOW PROCESSLIST;</li>
</ol>
<p>system user 线程确保状态为：has read all relay log 或者消失 再执行</p>
<p><strong>[sql]</strong></p>
<ol>
<li>STOP SLAVE;</li>
<li>RESET MASTER;</li>
<li>RESET SLAVE;</li>
<li>show master status \G；</li>
</ol>
<p>结果 File: mysql-bin.000001 Position: 106 11.3 主库上执行</p>
<p><strong>[sql]</strong></p>
<ol>
<li>RESET MASTER;</li>
<li>RESET SLAVE;</li>
</ol>
<p><strong>[sql]</strong></p>
<ol>
<li>CHANGE MASTER TO</li>
<li>MASTER_HOST=’192.168.119.129’,</li>
<li>MASTER_USER=’repl’,</li>
<li>MASTER_PASSWORD=’1234’,</li>
<li>MASTER_LOG_FILE=’mysql-bin.000001’,</li>
<li>MASTER_LOG_POS=106;</li>
</ol>
<p><strong>[sql]</strong></p>
<ol>
<li>start slave</li>
</ol>
<p>11.4 重启主备库，注意先重启新的主库，再启动新的备库</p>
<p><strong>[sql]</strong></p>
<ol>
<li>service mysqld restart</li>
</ol>
<p>11.5 验证 原来的主库已经变成从库，从库变成主库。</p>
</blockquote>

            
            <p class="more">
                <a href="/2015/09/11/2019030500067/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/11/2019030500067/" title="MYSQL主备复制结构搭建与切换">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/11/2019030500011/">
    		加快mydumper与myloader导出导入
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-11T04:58:23.000Z">2015-09-11</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/SQL/" title="SQL">SQL</a> / 
    
        <a href="/tags/数据库/" title="数据库">数据库</a> / 
    
        <a href="/tags/Database/" title="Database">Database</a> / 
    
        <a href="/tags/dba/" title="dba">dba</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>mydumper与myloader是一个优秀的第三方mysql数据库逻辑备份恢复工具，使用多线程的导出与导入。弥补了mysqldump单线程的不足。本文描述的是如何加快mydumper与myloader的导出与导入供大家参考。 1、基于MyIsam引擎导出导入 a、表不分块导出及导入 [root@GZAPP tmp]# mydumper -u inno -p xxx -B bsom -T tb_access_log -o /backup/tmp/ [root@GZAPP tmp]# ls -hltr   ###导出的数据文件为单个文件，大小在2.6GB total 2.6G -rw-r–r– 1 root root 1.6K Jul 24 08:51 bsom.tb_access_log-schema.sql -rw-r–r– 1 root root  214 Jul 24 08:52 metadata -rw-r–r– 1 root root 2.6G Jul 24 08:52 bsom.tb_access_log.sql ###基于缺省线程数导入，且设定每个事务查询数为10000，此参数此时其实作用不大，因为表为myisam引擎 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -d /backup/tmp -v 3 -q 10000 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -d /backup/tmp -v 3 -q 10000 <strong> Message: 4 threads created </strong> Message: Creating table `tempdb`.`tb_access_log` <strong> Message: Thread 4 shutting down </strong> Message: Thread 1 restoring `bsom`.`tb_access_log` part 0 <strong> Message: Thread 3 shutting down </strong> Message: Thread 2 shutting down root@localhost[tempdb]&gt; show processlist; +———+———+———-+——–+———+——–+———+————————————————+ | Id      | User    | Host     | db     | Command | Time   | State   | Info                                           | +———+———+———-+——–+———+——–+———+————————————————+ | 4452079 | root    | localhost| tempdb | Query   |      0 | init    | show processlist                               | | 4453793 | inno    | localhost| tempdb | Sleep   |    420 |         | NULL                                           | | 4453794 | inno    | localhost| tempdb | Query   |      4 | update  | INSERT INTO `tb_access_log` VALUES (506873,”325| +———+———+———-+——–+———+——–+———+————————————————+ ###从上面的线程数可以看出只有一个单线程在执行insert操作 b、表分块导出及导入 ###下面的示例中使用500MB进行分块 [root@GZAPP tmp]# mydumper -u inno -p xxx -B bsom -T tb_access_log -F 500 -o /backup/tmp/ [root@GZAPP tmp]# ls -hltr total 2.6G -rw-r–r– 1 root root 1.6K Jul 24 08:21 bsom.tb_access_log-schema.sql -rw-r–r– 1 root root 478M Jul 24 08:21 bsom.tb_access_log.00001.sql -rw-r–r– 1 root root 478M Jul 24 08:21 bsom.tb_access_log.00002.sql -rw-r–r– 1 root root 478M Jul 24 08:21 bsom.tb_access_log.00003.sql -rw-r–r– 1 root root 478M Jul 24 08:21 bsom.tb_access_log.00004.sql -rw-r–r– 1 root root 478M Jul 24 08:22 bsom.tb_access_log.00005.sql -rw-r–r– 1 root root  214 Jul 24 08:22 metadata -rw-r–r– 1 root root 241M Jul 24 08:22 bsom.tb_access_log.00006.sql ###由上可知，大表tb_access_log按接近500M被分割成了多个文件 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -t 6 -d /backup/tmp -v 3 <strong> Message: 6 threads created </strong> Message: Creating database `tempdb` <strong> Message: Creating table `tempdb`.`tb_access_log` </strong> Message: Thread 1 restoring `bsom`.`tb_access_log` part 3 <strong> Message: Thread 2 restoring `bsom`.`tb_access_log` part 5 </strong> Message: Thread 5 restoring `bsom`.`tb_access_log` part 4 <strong> Message: Thread 3 restoring `bsom`.`tb_access_log` part 6 </strong> Message: Thread 4 restoring `bsom`.`tb_access_log` part 1 <strong> Message: Thread 6 restoring `bsom`.`tb_access_log` part 2 #在下面的processlist可以看到，存在表级锁等待 +———+——-+———–+———+———+——–+—————————–+————————————————+ | Id      | User  | Host      | db      | Command | Time   | State                       | Info                                           | +———+——-+———–+———+———+——–+—————————–+————————————————+ | 4452079 | root  | localhost | bsom    | Query   |      0 | init                        | show processlist                               | | 4452167 | inno  | localhost | tempdb  | Sleep   |    769 |                             | NULL                                           | | 4452168 | inno  | localhost | tempdb  | Query   |     36 | update                      | INSERT INTO `tb_access_log` VALUES (6367402,”0,| | 4452169 | inno  | localhost | tempdb  | Query   |     21 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (12593865,” | | 4452170 | inno  | localhost | tempdb  | Query   |     26 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (15643029,””| | 4452171 | inno  | localhost | tempdb  | Query   |      6 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (173947,”70 | | 4452172 | inno  | localhost | tempdb  | Query   |     15 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (9490507,”7 | | 4452173 | inno  | localhost | tempdb  | Query   |     30 | Waiting for table level lock| INSERT INTO `tb_access_log` VALUES (3271602,”4 | +———+———+———–+———+———+——–+—————————–+———————————————-+ c、调整myisam有关参数后导入 [root@GZ-APP-BAK01 tmp]# time myloader -u innobk -p InnoBK -B tempdb -t 6 -d /backup/tmp -v 3 </strong> Message: 6 threads created <strong> Message: Creating table `tempdb`.`tb_mobile_access_log` </strong> Message: Thread 1 restoring `blossom`.`tb_mobile_access_log` part 3 <strong> Message: Thread 6 restoring `blossom`.`tb_mobile_access_log` part 6 </strong> Message: Thread 2 restoring `blossom`.`tb_mobile_access_log` part 5 <strong> Message: Thread 3 restoring `blossom`.`tb_mobile_access_log` part 4 </strong> Message: Thread 4 restoring `blossom`.`tb_mobile_access_log` part 1 <strong> Message: Thread 5 restoring `blossom`.`tb_mobile_access_log` part 2 </strong> Message: Thread 6 shutting down <strong> Message: Thread 5 shutting down </strong> Message: Thread 1 shutting down <strong> Message: Thread 2 shutting down </strong> Message: Thread 4 shutting down <strong> Message: Thread 3 shutting down real    266m28.903s user    0m6.008s sys     0m1.681s ###调整以下相关参数，后尝试再次导入， concurrent_insert  AUTO 改成 ALWAYS bulk_insert_buffer_size 8388608 改成 256M myisam_sort_buffer_size 67108864 改成 128M [root@GZ-APP-BAK01 tmp]# time myloader -u innobk -p InnoBK -B tempdb -t 6 -o -d /backup/tmp -v 3 </strong> Message: 6 threads created <strong> Message: Dropping table (if exists) `tempdb`.`tb_mobile_access_log` </strong> Message: Creating table `tempdb`.`tb_mobile_access_log` <strong> Message: Thread 1 restoring `blossom`.`tb_mobile_access_log` part 3 </strong> Message: Thread 2 restoring `blossom`.`tb_mobile_access_log` part 6 <strong> Message: Thread 3 restoring `blossom`.`tb_mobile_access_log` part 5 </strong> Message: Thread 4 restoring `blossom`.`tb_mobile_access_log` part 4 <strong> Message: Thread 6 restoring `blossom`.`tb_mobile_access_log` part 1 </strong> Message: Thread 5 restoring `blossom`.`tb_mobile_access_log` part 2 <strong> Message: Thread 2 shutting down </strong> Message: Thread 1 shutting down <strong> Message: Thread 6 shutting down </strong> Message: Thread 5 shutting down <strong> Message: Thread 3 shutting down </strong> Message: Thread 4 shutting down real    253m42.460s   ###此时导入时间并无明显减少 user    0m5.924s sys     0m1.637s 2、基于innodb引擎的导出导入 a、表未分块导出，数据文件大小为3.9GB [root@GZAPP tmp]# ls -hltr total 3.9G -rw-r–r– 1 root root 1.8K Jul 24 00:09 bscom.tb_message-schema.sql -rw-r–r– 1 root root 3.9G Jul 24 00:25 bscom.tb_message.sql -rw-r–r– 1 root root  215 Jul 24 09:14 metadata ###下面使用6个线程导入，实际上可以看到，只有1个线程在工作，因为数据文件只有1个 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -t 6 -d /backup/tmp -v 3 <strong> Message: 6 threads created </strong> Message: Creating table `tempdb`.`tb_message` <strong> Message: Thread 1 restoring `bscom`.`tb_message` part 0 </strong> Message: Thread 5 shutting down <strong> Message: Thread 2 shutting down </strong> Message: Thread 6 shutting down <strong> Message: Thread 3 shutting down </strong> Message: Thread 4 shutting down b、表分块导出 [root@GZAPP tmp]# mydumper -u inno -p xxx -B bscom -T tb_message -F 500 -o /backup/tmp/ [root@GZAPP tmp]# ls -hltr total 3.9G -rw-r–r– 1 root root 1.8K Jul 24 09:55 bscom.tb_message-schema.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00001.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00002.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00003.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00004.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00005.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00006.sql -rw-r–r– 1 root root 478M Jul 24 09:55 bscom.tb_message.00007.sql -rw-r–r– 1 root root 481M Jul 24 09:55 bscom.tb_message.00008.sql -rw-r–r– 1 root root  135 Jul 24 09:55 metadata -rw-r–r– 1 root root  93M Jul 24 09:55 bscom.tb_message.00009.sql ###下面尝试使用6线程导入，可以看到有6个线程在并发导入 [root@GZAPP tmp]# myloader -u inno -p xxx -B tempdb -t 6 -d /backup/tmp/ -v 3 <strong> Message: 6 threads created </strong> Message: Creating database `tempdb` <strong> Message: Creating table `tempdb`.`tb_message` </strong> Message: Thread 2 restoring `bscom`.`tb_message` part 5 <strong> Message: Thread 1 restoring `bscom`.`tb_message` part 9 </strong> Message: Thread 3 restoring `bscom`.`tb_message` part 1 <strong> Message: Thread 4 restoring `bscom`.`tb_message` part 8 </strong> Message: Thread 5 restoring `bscom`.`tb_message` part 4 <strong> Message: Thread 6 restoring `bscom`.`tb_message` part 6 </strong> Message: Thread 1 restoring `bscom`.`tb_message` part 7 <strong> Message: Thread 6 restoring `bscom`.`tb_message` part 3 </strong> Message: Thread 2 restoring `bscom`.`tb_message` part 2 <strong> Message: Thread 3 shutting down </strong> Message: Thread 5 shutting down <strong> Message: Thread 4 shutting down </strong> Message: Thread 1 shutting down <strong> Message: Thread 2 shutting down </strong> Message: Thread 6 shutting down 3、小结 a、mydumper在导出的时候可以根据服务器可用资源来合理地设置线程数。 b、mydumper在导出的时候尽可能地指定chunk-filesize或者rows参数以分块导出。 c、myloader在针对myisam引擎时建议调整相关参数至合理值以提高无法提高性能，主要是表级锁的问题。 d、myloader在针对innodb引擎时建议调整参数至合理值以提高性能，如以下参数等： innodb_buffer_pool_size innodb_flush_log_at_trx_commit innodb_log_buffer_size e、通过使用分块导出与导入可以显著利用并发来加快inndbo表导入。 f、注意mydumper导出时不会导出存储过程，函数，触发器等。</p>

            
            <p class="more">
                <a href="/2015/09/11/2019030500011/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/11/2019030500011/" title="加快mydumper与myloader导出导入">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/1.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/09/07/2019030500076/">
    		Mysql复合主键中自增长字段
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-09-07T04:51:47.000Z">2015-09-07</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/复合主键/" title="复合主键">复合主键</a> / 
    
        <a href="/tags/自增长/" title="自增长">自增长</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>Google Analytics的ID一般形如：UA-18xxxxx-<strong>1</strong>，UA-18xxxxx-<strong>4</strong>, 我们可以将它分成两段来看：字段1：UA-18XXXXX是指帐户的ID；字段2：字段1后附加的1、4，刚分别是指该帐户名下的两个网站。有一段时间很 纠结这样的ID怎么去维护，直到最近查阅到Mysql手册才发现，原来Mysql原生就很好的支持了这种含自动增长字段的复合主键，所以字段2是存储引擎 自动计算出来的。计算方式：MAX(_auto_increment_column_) + 1 WHERE prefix=<em>given-prefix</em> <a href="https://xiaobin.net/200905/mysql-auto-increasement-and-multi-primary-key/#fn:mysql_manual" target="_blank" rel="noopener">[1]</a>。 不多说，直接看SQL：</p>
<p>mysql&gt; CREATE TABLE `_test` (<br>    -&gt; `c1` varchar(20) NOT NULL DEFAULT ‘’, – 主键一：varchar<br>    -&gt; `c2` int(11) NOT NULL AUTO_INCREMENT, – 主键二：自增序列<br>    -&gt; `c3` varchar(255) ,<br>    -&gt; PRIMARY KEY (`c1`,`c2`) – 注意这里的先后顺序<br>    -&gt; ) ENGINE=MyISAM DEFAULT CHARSET=latin1;<br>Query OK, 0 rows affected (0.04 sec)</p>
<p>mysql&gt;<br>mysql&gt; INSERT INTO `_test` (`c1`,`c3`) VALUES (‘AAA’,’Robin Home’),<br>    -&gt; (‘AAA’,’Robin Blog’),<br>    -&gt; (‘AAA’,’Robin Resume’),<br>    -&gt; (‘BBB’,’Lily Home’),<br>    -&gt; (‘BBB’,’Lily Blog’);<br>Query OK, 5 rows affected (0.00 sec)<br>Records: 5  Duplicates: 0  Warnings: 0</p>
<p>mysql&gt;<br>mysql&gt; SELECT * FROM `_test`;<br>+—–+—-+————–+<br>| c1  | c2 | c3           |<br>+—–+—-+————–+<br>| AAA |  1 | Robin Home   |<br>| AAA |  2 | Robin Blog   |<br>| AAA |  3 | Robin Resume |<br>| BBB |  1 | Lily Home    |<br>| BBB |  2 | Lily Blog    |<br>+—–+—-+————–+<br>5 rows in set (0.00 sec)</p>
<p>mysql&gt;</p>
<p>值得注意的是，MySQL的这种特性只适用于MyISAM和BDB引擎。</p>

            
            <p class="more">
                <a href="/2015/09/07/2019030500076/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/09/07/2019030500076/" title="Mysql复合主键中自增长字段">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/7.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <span class="page-number current">1</span><a class="page-number" href="/archives/2015/09/page/2/">2</a><a class="extend next" rel="next" href="/archives/2015/09/page/2/">后一页</a>
    </nav>
    


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/MySQL/">MySQL</a>
        <span class="badge">(92)</span>
    </li>
    
    <li>
        <a href="/categories/Oracle/">Oracle</a>
        <span class="badge">(40)</span>
    </li>
    
    <li>
        <a href="/categories/开发语言/">开发语言</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/">NOSQL</a>
        <span class="badge">(17)</span>
    </li>
    
    <li>
        <a href="/categories/其他数据库/">其他数据库</a>
        <span class="badge">(4)</span>
    </li>
    
    <li>
        <a href="/categories/SQL-Server/">SQL Server</a>
        <span class="badge">(13)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/">Oracle</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/SQL-Server/">SQL Server</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/开发语言/">开发语言</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/MySQL/" title="MySQL">MySQL (71)</a>
  
    <a class="tag-item" href="/tags/位运算/" title="位运算">位运算 (0)</a>
  
    <a class="tag-item" href="/tags/sqlplus/" title="sqlplus">sqlplus (1)</a>
  
    <a class="tag-item" href="/tags/allow/" title="allow">allow (1)</a>
  
    <a class="tag-item" href="/tags/Apache/" title="Apache">Apache (1)</a>
  
    <a class="tag-item" href="/tags/deny/" title="deny">deny (1)</a>
  
    <a class="tag-item" href="/tags/CentOS/" title="CentOS">CentOS (2)</a>
  
    <a class="tag-item" href="/tags/druid/" title="druid">druid (1)</a>
  
    <a class="tag-item" href="/tags/心跳/" title="心跳">心跳 (1)</a>
  
    <a class="tag-item" href="/tags/事务/" title="事务">事务 (5)</a>
  
    <a class="tag-item" href="/tags/分布式/" title="分布式">分布式 (1)</a>
  
    <a class="tag-item" href="/tags/消息/" title="消息">消息 (1)</a>
  
    <a class="tag-item" href="/tags/redis/" title="redis">redis (6)</a>
  
    <a class="tag-item" href="/tags/KeepAlived/" title="KeepAlived">KeepAlived (1)</a>
  
    <a class="tag-item" href="/tags/Oracle/" title="Oracle">Oracle (30)</a>
  
    <a class="tag-item" href="/tags/schedule-job/" title="schedule job">schedule job (1)</a>
  
    <a class="tag-item" href="/tags/分库/" title="分库">分库 (1)</a>
  
    <a class="tag-item" href="/tags/分库分表/" title="分库分表">分库分表 (1)</a>
  
    <a class="tag-item" href="/tags/分表/" title="分表">分表 (1)</a>
  
    <a class="tag-item" href="/tags/SQL/" title="SQL">SQL (17)</a>
  
    <a class="tag-item" href="/tags/批量/" title="批量">批量 (1)</a>
  
    <a class="tag-item" href="/tags/数据库/" title="数据库">数据库 (7)</a>
  
    <a class="tag-item" href="/tags/结构同步/" title="结构同步">结构同步 (1)</a>
  
    <a class="tag-item" href="/tags/truncate/" title="truncate">truncate (1)</a>
  
    <a class="tag-item" href="/tags/Excel/" title="Excel">Excel (1)</a>
  
    <a class="tag-item" href="/tags/Sqlite/" title="Sqlite">Sqlite (1)</a>
  
    <a class="tag-item" href="/tags/Hash索引/" title="Hash索引">Hash索引 (1)</a>
  
    <a class="tag-item" href="/tags/InnoDB/" title="InnoDB">InnoDB (3)</a>
  
    <a class="tag-item" href="/tags/MyISAM/" title="MyISAM">MyISAM (3)</a>
  
    <a class="tag-item" href="/tags/索引优化/" title="索引优化">索引优化 (1)</a>
  
    <a class="tag-item" href="/tags/Linux/" title="Linux">Linux (2)</a>
  
    <a class="tag-item" href="/tags/FineReport/" title="FineReport">FineReport (1)</a>
  
    <a class="tag-item" href="/tags/报表/" title="报表">报表 (1)</a>
  
    <a class="tag-item" href="/tags/数据集/" title="数据集">数据集 (1)</a>
  
    <a class="tag-item" href="/tags/rowid/" title="rowid">rowid (2)</a>
  
    <a class="tag-item" href="/tags/重复/" title="重复">重复 (1)</a>
  
    <a class="tag-item" href="/tags/Character-set/" title="Character set">Character set (1)</a>
  
    <a class="tag-item" href="/tags/NLS-LANG/" title="NLS_LANG">NLS_LANG (1)</a>
  
    <a class="tag-item" href="/tags/mysqldump/" title="mysqldump">mysqldump (2)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="http://www.devba.com" target="_blank" title="软件开发吧">软件开发吧</a>
        </li>
    
        <li>
            <a href="https://www.sqlyun.cn" target="_blank" title="SQL云笔记">SQL云</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>