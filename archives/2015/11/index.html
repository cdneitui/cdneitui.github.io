<!doctype html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=11,IE=10,IE=9,IE=8">
    <meta name="baidu-site-verification" content="dIcXMeY8Ya">
    
    <title>文章归档: 2015/11 | 软件开发吧</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=0">
    <meta name="keywords" content="SQL云,SQL云开发,SQL笔记,SQL开发,云开发,MySQL,Oralce,数据库,数据库云,数据库开发,数据库云开发,SQL教程,数据库教程,开发笔记,MySQL笔记,MySQL教程">
    <meta name="description" content="为满足广大程序猿兄弟对日常工作中学习数据库、使用使用数据库资料查询需求，SQL云开发免费将自己整理的各种数据库技术资料分享出来，并希望与广大猿兄一起讨论学习与进步,致力于一起更方便、快捷资料学习查询,实现更安全、高效的数据存储.">

    
    <link rel="alternative" href="/atom.xml" title="软件开发吧" type="application/atom+xml">
    
    
    <link rel="shortcut icon" href="/favicon.ico">
    
    <link rel="stylesheet" href="/css/style.css">
    <!--[if lt IE 9]>
    <script src="/js/html5.js"></script>
    <![endif]-->
    
<script>
    var _hmt = _hmt || [];
    (function() {
        var hm = document.createElement("script");
        hm.src = "//hm.baidu.com/hm.js?fd459238242776d173cdc64918fb32f2";
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(hm, s);
    })();
</script>


</head>
</html>
<body class="home">
    <!--[if lt IE 9]>
    <div class="browsehappy">
        当前网页 <strong>不支持</strong>
        你正在使用的浏览器. 为了正常的访问, 请 <a href="http://browsehappy.com/">升级你的浏览器</a>.
    </div>
    <![endif]-->

    <!-- 博客头部 -->
    <header class="header">
    <section class="container header-main">
        <div class="logo">
            <a href="/">
                <div class="cover">
                    <span class="name">软件开发吧</span>
                    <span class="description"></span>
                </div>
            </a>
        </div>
        <div class="dropnav icon-paragraph-justify" id="JELON__btnDropNav"></div>
        <ul class="menu hidden" id="JELON__menu">
            
            <li rel="/archives/2015/11/index.html" class="item ">
                <a href="/" title="首页" class="icon-home">&nbsp;首页</a>
            </li>
            
            <li rel="/archives/2015/11/index.html" class="item ">
                <a href="/lab/" title="实验室" class="icon-lab">&nbsp;实验室</a>
            </li>
            
            <li rel="/archives/2015/11/index.html" class="item ">
                <a href="/about/" title="关于" class="icon-about">&nbsp;关于</a>
            </li>
            
            <li rel="/archives/2015/11/index.html" class="item ">
                <a href="/comment/" title="留言" class="icon-comment">&nbsp;留言</a>
            </li>
            
        </ul>
        <div class="profile clearfix">
            <div class="feeds fl">
                
                
                <p class="links">
                    
                        <a href="https://github.com/sxyyhj" target="_blank">Github</a>
                        |
                    
                        <a href="https://pages.coding.me" target="_blank">Hosted by Coding Pages</a>
                        
                    
                </p>
                <p class="sns">
                    
                    <a href="javascript: void(0);" class="wechat">
                        <b>■</b>
                        公众号
                        <span class="popover">
                            <img src="/img/wechat_mp.jpg" width="120" height="120" alt="我的微信订阅号">
                            <i class="arrow"></i>
                        </span>
                    </a>
                </p>
                
            </div>
            <div class="avatar fr">
                <img src="/img/jelon.jpg" alt="avatar" title="Jelon">
            </div>
        </div>
    </section>
</header>


    <!-- 博客正文 -->
    <div class="container body clearfix">
        <section class="content">
            <div class="content-main widget">
                <!-- 文章归档 -->

    <h3 class="widget-hd">
        <strong>
            
                文章归档
                <!-- 文章归档，可以根据日期分类 -->
            
        </strong>
    </h3>
    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/11/30/2019030500103/">
    		mysql 用户管理和权限设置
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-11-30T05:37:20.000Z">2015-11-30</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a> / 
    
        <a href="/tags/权限/" title="权限">权限</a> / 
    
        <a href="/tags/用户/" title="用户">用户</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>用户管理</p>
<p>mysql&gt;use mysql;</p>
<p>查看</p>
<p>mysql&gt; select host,user,password from user ;</p>
<p>创建</p>
<p>mysql&gt; create user  zx_root   IDENTIFIED by ‘xxxxx’;   //identified by 会将纯文本密码加密作为散列值存储</p>
<p>修改</p>
<p>mysql&gt;rename   user  feng  to   newuser；//mysql 5之后可以使用，之前需要使用update 更新user表</p>
<p>删除</p>
<p>mysql&gt;drop user newuser;   //mysql5之前删除用户时必须先使用revoke 删除用户权限，然后删除用户，mysql5之后drop 命令可以删除用户的同时删除用户的相关权限</p>
<p>更改密码</p>
<p>mysql&gt; set password for zx_root =password(‘xxxxxx’);</p>
<p> mysql&gt; update  mysql.user  set  password=password(‘xxxx’)  where user=’otheruser’</p>
<p>查看用户权限</p>
<p>mysql&gt; show grants for zx_root;</p>
<p>赋予权限</p>
<p>mysql&gt; grant select on dmc_db.*  to zx_root;</p>
<p>回收权限</p>
<p>mysql&gt; revoke  select on dmc_db.*  from  zx_root;  //如果权限不存在会报错</p>
<p>上面的命令也可使用多个权限同时赋予和回收，权限之间使用逗号分隔</p>
<p>mysql&gt; grant select，update，delete  ，insert  on dmc_db.*  to  zx_root;</p>
<p>如果想立即看到结果使用</p>
<p>flush  privileges ;</p>
<p>命令更新</p>
<p>设置权限时必须给出一下信息</p>
<p>1，要授予的权限</p>
<p>2，被授予访问权限的数据库或表</p>
<p>3，用户名</p>
<p>grant和revoke可以在几个层次上控制访问权限</p>
<p>1，整个服务器，使用 grant ALL  和revoke  ALL</p>
<p>2，整个数据库，使用on  database.*</p>
<p>3，特点表，使用on  database.table</p>
<p>4，特定的列</p>
<p>5，特定的存储过程</p>
<p>user表中host列的值的意义</p>
<p>%              匹配所有主机</p>
<p>localhost    localhost不会被解析成IP地址，直接通过UNIXsocket连接</p>
<p>127.0.0.1      会通过TCP/IP协议连接，并且只能在本机访问；</p>
<p>::1                 ::1就是兼容支持ipv6的，表示同ipv4的127.0.0.1</p>
<p>grant 普通数据用户，查询、插入、更新、删除 数据库中所有表数据的权利。 grant select on testdb.<em> to common_user@’%’ grant insert on testdb.</em> to common_user@’%’ grant update on testdb.<em> to common_user@’%’ grant delete on testdb.</em> to common_user@’%’ 或者，用一条 MySQL 命令来替代： grant select, insert, update, delete on testdb.<em> to common_user@’%’ 9&gt;.grant 数据库开发人员，创建表、索引、视图、存储过程、函数。。。等权限。 grant 创建、修改、删除 MySQL 数据表结构权限。 grant create on testdb.</em> to developer@’192.168.0.%’; grant alter on testdb.<em> to developer@’192.168.0.%’; grant drop on testdb.</em> to developer@’192.168.0.%’; grant 操作 MySQL 外键权限。 grant references on testdb.<em> to developer@’192.168.0.%’; grant 操作 MySQL 临时表权限。 grant create temporary tables on testdb.</em> to developer@’192.168.0.%’; grant 操作 MySQL 索引权限。 grant index on testdb.<em> to developer@’192.168.0.%’; grant 操作 MySQL 视图、查看视图源代码 权限。 grant create view on testdb.</em> to developer@’192.168.0.%’; grant show view on testdb.<em> to developer@’192.168.0.%’; grant 操作 MySQL 存储过程、函数 权限。 grant create routine on testdb.</em> to developer@’192.168.0.%’; – now, can show procedure status grant alter routine on testdb.<em> to developer@’192.168.0.%’; – now, you can drop a procedure grant execute on testdb.</em> to developer@’192.168.0.%’; 10&gt;.grant 普通 DBA 管理某个 MySQL 数据库的权限。 grant all privileges on testdb to dba@’localhost’ 其中，关键字 “privileges” 可以省略。 11&gt;.grant 高级 DBA 管理 MySQL 中所有数据库的权限。 grant all on <em>.</em> to dba@’localhost’ 12&gt;.MySQL grant 权限，分别可以作用在多个层次上。 1. grant 作用在整个 MySQL 服务器上： grant select on <em>.</em> to dba@localhost; – dba 可以查询 MySQL 中所有数据库中的表。 grant all on <em>.</em> to dba@localhost; – dba 可以管理 MySQL 中的所有数据库 2. grant 作用在单个数据库上： grant select on testdb.* to dba@localhost; – dba 可以查询 testdb 中的表。 3. grant 作用在单个数据表上： grant select, insert, update, delete on testdb.orders to dba@localhost; 4. grant 作用在表中的列上： grant select(id, se, rank) on testdb.apache_log to dba@localhost; 5. grant 作用在存储过程、函数上： grant execute on procedure testdb.pr_add to ’dba’@’localhost’ grant execute on function testdb.fn_add to ’dba’@’localhost’ 注意：修改完权限以后 一定要刷新服务，或者重启服务，刷新服务用：FLUSH PRIVILEGES。</p>
<p>权限表</p>
<p>权限</p>
<p>说明</p>
<p>all</p>
<p>alter</p>
<p>alter routine</p>
<p>使用alter procedure 和drop procedure</p>
<p>create</p>
<p>create routine</p>
<p>使用create  procedure</p>
<p>create temporary tables</p>
<p>使用create temporary table</p>
<p>create  user</p>
<p>create view</p>
<p>delete</p>
<p>drop</p>
<p>execute</p>
<p>使用call和存储过程</p>
<p>file</p>
<p>使用select into outfile  和load data infile</p>
<p>grant option</p>
<p>可以使用grant和revoke</p>
<p>index</p>
<p>可以使用create index 和drop index</p>
<p>insert</p>
<p>lock tables</p>
<p>锁表</p>
<p>process</p>
<p>使用show full processlist</p>
<p>reload</p>
<p>   使用flush</p>
<p>replication client</p>
<p>服务器位置访问</p>
<p>replocation slave</p>
<p>由复制从属使用</p>
<p>select</p>
<p>show databases</p>
<p>show view</p>
<p>shutdown</p>
<p>使用mysqladmin shutdown 来关闭mysql</p>
<p>super</p>
<p>update</p>
<p>usage</p>
<p>无访问权限</p>

            
            <p class="more">
                <a href="/2015/11/30/2019030500103/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/11/30/2019030500103/" title="mysql 用户管理和权限设置">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/0.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/11/30/2019030500145/">
    		Oracle rownum rowid 区别
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-11-30T03:08:24.000Z">2015-11-30</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a> / 
    
        <a href="/tags/rowid/" title="rowid">rowid</a> / 
    
        <a href="/tags/rownum/" title="rownum">rownum</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>oracle中rownum和rowid的区别   . rownum和rowid都是伪列，但是两者的根本是不同的，rownum是根据sql查询出的结果给每行分配一个逻辑编号，所以你的sql不同也就会导致最终rownum不同，但是rowid是物理结构上的，在每条记录insert到数据库中时，都会有一个唯一的物理记录 ， 例如  AAAMgzAAEAAAAAgAAB 7499 ALLEN SALESMAN 7698 1981/2/20 1600.00 300.00 30 这里的AAAMgzAAEAAAAAgAAB物理位置对应了这条记录，这个记录是不会随着sql的改变而改变。 因此，这就导致了他们的使用场景不同了，通常在sql分页时或是查找某一范围内的记录时，我们会使用rownum。 1、rownum 例如： 查找2到10范围内的记录（这里包括2和10的记录） select <em> from (select rownum rn, a.</em> from emp a) t where t.rn between 2 and 10; 查找前三名的记录 select <em> from emp a where rownum &lt; 3；这里我们要注意，直接用rownum查找的范围必须要包含1；因为rownum是从1开始记录的，当然你可以把rownum查出来后放在一个虚表中作为这个虚表的字段再根据条件查询。 例如： select </em> from (select rownum rn, a.<em> from emp a) t where t.rn &gt; 2;这就可以了 2、rowid 我们在处理一张表中重复记录时经常用到他，当然你也可以用一个很原始的方法，就是将有重复记录的表中的数据导到另外一张表中，最后再倒回去。 SQL&gt;create table stu_tmp as select distinct</em> from stu; SQL&gt;truncate table sut;        //清空表记录 SQL&gt;insert into stu select * from stu_tmp;    //将临时表中的数据添加回原表但是要是stu的表数据是百万级或是更大的千万级的，那这样的方法显然是不明智的，因此我们可以根据rowid来处理，rowid具有唯一性，查询时效率是很高的， 例如，学生表中的姓名会有重复的情况，但是学生的学号是不会重复的，如果我们要删除学生表中姓名重复只留学号最大的学生的记录，怎么办呢？ delete from stu a where rowid not  in (select max(rowid) from stu b where a.name = b.name and a.stno &lt; b.stno); 这样就可以了。</p>

            
            <p class="more">
                <a href="/2015/11/30/2019030500145/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/11/30/2019030500145/" title="Oracle rownum rowid 区别">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/0.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/11/27/2019030500007/">
    		druid 心跳检测作用
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-11-27T04:36:55.000Z">2015-11-27</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/druid/" title="druid">druid</a> / 
    
        <a href="/tags/心跳/" title="心跳">心跳</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>数据库中连接时间设置：</p>
<ol>
<li>connect_timeout:  服务器关闭非交互连接之前等待活动的秒数</li>
<li>interactive_timeout:服务器关闭交互式连接前等待活动的秒数</li>
<li>这两个值默认都是288000（8小时），如果这两个值设置过大 或造成mysql产生大量的sleep进行，从而影响mysql的性能</li>
<li><p>MySQL服务器所支持的最大连接数是有上限的，因为每个连接的建立都会消耗内存，因此我们希望客户端在连接到MySQL Server处理完相应的操作后，应该断开连接并释放占用的内存。如果你的MySQL Server有大量的闲置连接，他们不仅会白白消耗内存，而且如果连接一直在累加而不断开，最终肯定会达到MySQL Server的连接上限数，这会报’too many connections’的错误。</p>
</li>
<li><p>在交互模式下，interactive_timeout取代wait_timeout。这样，如果有的客户端是交互模式方式连接mysql server。那么客户端的timeout受制于interactive_timeout。如果有的客户端是非交互模式，长连接mysql server。那么客户端的timeout受制于wait_timeout。(是否是交互模式的连接，由客户端决定)</p>
</li>
</ol>
<p>druid 规避  连接 异常：</p>
<ol>
<li>如果数据库连接超时 修改了的话，有可能为了提高数据库性能减小数据库压力，会将timeout设置的很小。那么 需要设置 druid的心跳检测来方式出现连接异常：</li>
<li>t;!– 配置间隔多久才进行一次检测，检测需要关闭的空闲连接，单位是毫秒 –&gt;</li>
<li><property name="timeBetweenEvictionRunsMillis" value="5000">

</property></li>
</ol>
<p><strong>注意：如果心跳检测的时间设置的大于数据库的timeout，那么心跳检测是不起作用的！！！！</strong></p>

            
            <p class="more">
                <a href="/2015/11/27/2019030500007/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/11/27/2019030500007/" title="druid 心跳检测作用">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/7.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/11/27/2019030500146/">
    		Oracle-SQL-排序操作
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-11-27T04:25:20.000Z">2015-11-27</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a> / 
    
        <a href="/tags/SQL/" title="SQL">SQL</a> / 
    
        <a href="/tags/排序/" title="排序">排序</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>1、普通排序</p>
<ol>
<li>select * from emp  order by empno   asc(desc);</li>
</ol>
<p>2、根据多字段排序</p>
<ol>
<li>select * from emp order by ename,job  asc(desc);</li>
</ol>
<p>3、按子串排序</p>
<p>Sql代码</p>
<ol>
<li>select * from emp order by substr(ename,length(ename)-2)</li>
<li>通过substr函数实现子串的截取，然后进行排序</li>
</ol>
<p>4、对于字母、数字混合的数据进行排序 通过translate或者replace替换掉数字或字符部分，然后排序 translate(string,from,to) 字符级别的替换； 如果to的长度小于from则在from中存在，在to中不存在的将被直接删掉； replace(string,from ,to) 字符串级别的替换 5、排序时的空值处理 a、使用case when对空值进行替换，例如空值替换为0，非空值替换为1，然后可以参与排序 b、oracle9i以后的版本提供了 nulls first  和nulls  last操作。 6、根据数据项的键排序 采用类似占位符的方式来实现排序</p>
<ol>
<li>select empno,ename,job,case when job=’SALESMAN’ then comm else sal end from emp order by 4;</li>
</ol>

            
            <p class="more">
                <a href="/2015/11/27/2019030500146/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/11/27/2019030500146/" title="Oracle-SQL-排序操作">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/7.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/Oracle/">Oracle</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/11/25/2019030500142/">
    		ORACLE遇到ORA-16038 错误处理
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-11-25T09:10:13.000Z">2015-11-25</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/Oracle/" title="Oracle">Oracle</a> / 
    
        <a href="/tags/ORA-16038/" title="ORA-16038">ORA-16038</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <ol>
<li>SQL&gt; shutdown</li>
<li><p>ORA-01507: database not mounted</p>
</li>
<li><p>ORACLE instance shut down.</p>
</li>
<li>SQL&gt; startup</li>
<li><p>ORACLE instance started.</p>
</li>
<li><p>Total System Global Area 2147483648 bytes</p>
</li>
<li>Fixed Size                  2022144 bytes</li>
<li>Variable Size            1560282368 bytes</li>
<li>Database Buffers          570425344 bytes</li>
<li>Redo Buffers               14753792 bytes</li>
<li>Database mounted.</li>
<li>ORA-16038: log 2 sequence# 391 cannot be archived</li>
<li>ORA-19809: limit exceeded for recovery files</li>
<li><p>ORA-00312: online log 2 thread 1: ‘/data1/oracle/oradata/xxdbse/redo02.log’</p>
<p> 解决：  </p>
</li>
<li><p>SQL&gt; select group#,sequence#,archived,status from v$log;</p>
</li>
<li><p>GROUP#  SEQUENCE# ARC STATUS</p>
</li>
<li><hr>
</li>
<li>1        394 NO  CURRENT</li>
<li>3        393 NO  INACTIVE</li>
<li><p>2        391 NO  INACTIVE</p>
</li>
<li><p>SQL&gt; alter database clear unarchived logfile group 3;</p>
</li>
<li><p>Database altered.</p>
</li>
<li><p>SQL&gt; alter database open;</p>
</li>
<li><p>Database altered.</p>
</li>
<li><p>SQL&gt; select group#,sequence#,archived,status from v$log;</p>
</li>
<li><p>GROUP#  SEQUENCE# ARC STATUS</p>
</li>
<li><hr>
</li>
<li>1        394 NO  INACTIVE</li>
<li>2        391 NO  INACTIVE</li>
<li>3        395 NO  CURRENT</li>
</ol>

            
            <p class="more">
                <a href="/2015/11/25/2019030500142/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/11/25/2019030500142/" title="ORACLE遇到ORA-16038 错误处理">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/5.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/11/24/2019030500111/">
    		MySQL 高可用架构在业务层面的分析研究
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-11-24T07:28:29.000Z">2015-11-24</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p><strong>前言：</strong> 相对于传统行业的相对服务时间9x9x6或者9x12x5，因为互联网电子商务以及互联网游戏的实时性，所以服务要求7<em>24小时，业务架构不管是应用还是数据库，都需要容灾互备，在mysql的体系中，最好通过在最开始阶段的数据库架构阶段来实现容灾系统。所以这里从业务宏观角度阐述下mysql架构的方方面面。 <strong>一. MySQL架构设计—业务分析</strong> （1）读多写少 虚线表示跨机房部署，比如电子商务系统，一个Master既有读也有些写，对读数据一致性需要比较重要的，读要放在Master上面。 M(R)仅仅是一个备库，只有M(WR)挂了之后，才会切换到M(R)上，这个时候M(R)就变成了读写库。比如游戏系统，有很多Salve会挂载后面一个M(R)上面。 （2）读多写少MMS-电商 如果是电子商务类型的，这种读多写少的，一般是1个master拖上4到6个slave，所有slave挂载在一个master也足够了。 切换的时候，把M1的读写业务切换到M2上面，然后把所有M1上的slave挂到M2上面去，如下所示：<img src="/uploads/2015/11/26230597_14125236608Q14.png" alt> （3）读多写少MMSS-游戏 如果是游戏行业的话，读非常多蛮明显的，会出现一般1个Master都会挂上10个以上的Slave的情况，所以这个时候，可以把一部分Slave挂载新的M(R)上面。至少会减少一些压力，这样至少服务器挂掉的时候，不会对所有的slave有影响，还有一部分在M(R)上的slave在继续，不会对所有的slave受到影响，见图3，<img src="/uploads/2015/11/26230597_14125236982QDx.png" alt> 图3 （4）读少写多 意味着读并不会影响写的效率，所以读写都可以放在一个M1(WR)，而另外一个不提供读也不提供写，只提供standby冗余异地容灾。<img src="/uploads/2015/11/26230597_1412523725kDa3.png" alt> 这个异地容灾是非常重要的，否则如果是单机的，单边的业务，万一idc机房故障了，一般就会影响在线业务的，这种 造成业务2小时无法应用，对于在线电子商务交易来说，影响是蛮大的，所以为了最大限度的保证7</em>24小时，必须要做到异地容灾，MM要跨idc机房。虽然对资源有一些要求，但是对HA来说是不可缺少的，一定要有这个MM机制。 做切换的时候，把所有的读写从M1直接切换到M2上就可以了。<img src="/uploads/2015/11/26230597_1412523759LF7F.png" alt> （5）读写平分秋色 读和写差不多，但是读不能影响写的能力，把读写放在M1(WR)上，然后把一部分读也放在M2(R)上面，当然M1和M2也是跨机房部署的。 切换的时候，把一部分读和全部写从M1切换到M2上就可以了。 <strong>二. MySQL架构设计—常见架构</strong> （1）强一致性 对读一致性的权衡，如果是对读写实时性要求非常高的话，就将读写都放在M1上面，M2只是作为standby，就是采取和上面的一（4）的读少写多的一样的架构模式。 比如，订单处理流程，那么对读需要强一致性，实时写实时读，类似这种涉及交易的或者动态实时报表统计的都要采用这种架构模式<img src="/uploads/2015/11/26230597_1412523786141I.png" alt> （2）弱一致性 如果是弱一致性的话，可以通过在M2上面分担一些读压力和流量，比如一些报表的读取以及静态配置数据的读取模块都可以放到M2上面。比如月统计报表，比如首页推荐商品业务实时性要求不是很高，完全可以采用这种弱一致性的设计架构模式。<img src="/uploads/2015/11/26230597_1412523811aApV.png" alt> （3）中间一致性 如果既不是很强的一致性又不是很弱的一致性，那么我们就采取中间的策略，就是在同机房再部署一个S1(R)，作为备库，提供读取服务，减少M1(WR)的压力，而另外一个idc机房的M2只做standby容灾方式的用途。 当然这里会用到3台数据库服务器，也许会增加采购压力，但是我们可以提供更好的对外数据服务的能力和途径，实际中尽可能两者兼顾。 <img src="/uploads/2015/11/26230597_1412523913ceoM.png" alt> （4）统计业务 比如PV、UV操作、页数的统计、流量的统计、数据的汇总等等，都可以划归为统计类型的业务。 数据库上做大查询的统计是非常消耗资源的。统计分为实时的统计和非实时的统计，由于mysql主从是逻辑sql的模式，所以不能达到100%的实时，如果是online要严格的非常实时的统计比如像火车票以及金融异地结算等的统计，mysql这块不是它的强项，就只有查询M1主库来实现了。 A，但是对于不是严格的实时性的统计，mysql有个很好的机制是binlog，我们可以通过binlog进行解析Parser，解析出来写入统计表进行统计或者发消息给应用端程序来进行统计。这种是准实时的统计操作，有一定的短暂的可接受的统计延迟现象，如果要100%实时性统计只有查询M1主库了。 通过binlog的方式实现统计，在互联网行业，尤其是电商和游戏这块，差不多可以解决90%以上的统计业务。有时候如果用户或者客户提出要实时read-time了，大家可以沟通一下为什么需要实时，了解具体的业务场景，有些可能真的不需要实时统计，需要有所权衡，需要跟用户和客户多次有效沟通，做出比较适合业务的统计架构模型。 B，还有一种offline统计业务，比如月份报表年报表统计等，这种完全可以把数据放到数据仓库里面或者第三方Nosql里面进行统计。 <img src="/uploads/2015/11/26230597_1412523957JKio.png" alt> （5）历史数据迁移 历史数据迁移，需要尽量不影响现在线上的业务，尽量不影响现在线上的查询写入操作，为什么要做历史数据迁移？因为有些业务的数据是有时效性的，比如电商中的已经完成的历史订单等，不会再有更新操作了，只有很简单的查询操作，而且查询也不会很频繁，甚至可能一天都不会查询一次。 如果这时候历史数据还在online库里面或者online表里面，那么就会影响online的性能，所以对于这种，可以把数据迁移到新的历史数据库上，这个历史数据库可以是mysql也可以是nosql，也可以是数据仓库甚至hbase大数据等。 实现途径是通过slave库查询出所有的数据，然后根据业务规则比如时间、某一个纬度等过滤筛选出数据，放入历史数据库(History Databases)里面。迁移完了，再回到主库M1上，删除掉这些历史数据。这样在业务层面，查询就要兼顾现在实时数据和历史数据，可以在filter上面根据迁移规则把online查询和history查询对接起来。比如说一个月之内的在online库查询一个月之前的在history库查询，可以把这个规则放在DB的迁移filter层和应用查询业务模块层。如果可以的话，还可以配置更细化，通过应用查询业务模块层来影响DB的迁移filter层，比如以前查询分为一个月为基准，现在查询业务变化了，以15天为基准，那么应用查询业务模块层变化会自动让DB的filter层也变化，实现半个自动化，更加智能一些。 <img src="/uploads/2015/11/26230597_1412524001L6F6.png" alt> （6）MySQL Sharding 像oracle这种基于rac基于共享存储的方式，不需要sharding只需要扩从rac存储就能实现了。但是这种代价相对会比较高一些，共享存储一般都比较贵，随着业务的扩展数据的爆炸式增长，你会不停累计你的成本，甚至达到一个天文数字。 目前这种share disk的方式，除了oracle的业务逻辑层做的非常完善之外其他的解决方案都还不是很完美。 Mysql的sharding也有其局限性，sharding之后的数据查询访问以及统计都会有很大的问题，mysql的sharding是解决share nothing的存储的一种分布式的方法，大体上分为垂直拆分和水平拆分。 （6.1）垂直拆分 可以横向拆分，可以纵向拆分，可以横向纵向拆分，还可以按照业务拆分。 6.1.1横向拆分 Mysql库里面的横向拆分是指，每一个数据库实例里面都有很多个db库，每一个db库里面都有A表B表，比如db1库有A表B表，db2库里也有A表和B表，那么我们把db1、db2库的A表B表拆分出来，把一个库分成2个，就拆分成db1、db2、db3、db4，其中db1库和db2库放A表数据，db3库和db4库放B表的数据，db1、db2库里面只有A表数据，db3、db4库里面只有B表的数据。 打个比方，作为电商来说，每个库里面都有日志表和订单表，假如A表是日志表log表，B表是订单表Order表，一般说来写日志和写订单没有强关联性，我们可以讲A表日志表和B表订单表拆分出来。那么这个时候就做了一次横向的拆分工作，将A表日志表和B表订单表拆分开来放在不同的库，当然A表和B表所在的数据库名也可以保持一致(PS：在不同的实例里面)，如下图所示： <img src="/uploads/2015/11/26230597_1412524048ma3Z.png" alt> PS：这种拆分主要针对于不同的业务对表的影响不大，表之间的业务关联很弱或者基本上没有业务关联。拆分的好处是不相关的数据表拆分到不同的实例里面，对数据库的容量扩展和性能提高的均衡来说，都是蛮有好处的。 6.1.2纵向拆分 把同一个实例上的不同的db库拆分出来，放入单独的不同实例中。这种拆分的适应场景和要求是db1和db2是没有多少业务联系的，类似6.1.2里面的A表和B表那样。如果你用到了跨库业务同时使用db1和db2的话，个人建议要重新考虑下业务，重新梳理下尽量把一个模块的表放在一个库里面，不要垮库操作。 这种库纵向拆分里面，单独的库db1，表A和表B是强关联的。如下图所示： <img src="/uploads/2015/11/26230597_1412524091tz9A.png" alt> PS：看到很多使用mysql的人，总是把很多没有业务关联性的表放在一个库里面，或者总是把很多个的db库放在同一个实例里面，就像使用oracle那样就一个instance的概念而已。Mysql的使用一大原则就是简单，尽量单一，简单的去使用mysql，库要严格的分开；表没有关系的，要严格拆分成库。这样的话扩展我们的业务就非常方便简单了，只需要把业务模块所在的db拆分出来，放入新的数据库服务器上即可。 6.1.3横向纵向拆分 有些刚起步的，开始为了快速出产品，就把所以的库所有的表都放在一个实例上，等业务发展后，就面临着数据拆分，这里就会把横向纵向拆分结合起来，一起实现，如下图所示： <img src="/uploads/2015/11/26230597_1412524129f4bF.png" alt> 6.1.4业务拆分 跟水平拆分有点类似，但是有不同的地方。比如一个供应商，可能整个网站上有10个供应商，一个网站上面每一个供应商都有一定的量，而且供应商之间的数据量规模都差不多的规模，那么这个时候就可以使用供应商的纬度来做拆分。 比如usern库中，a、b、c表都是强关联的，都有完整的业务逻辑存在，这里只有用户（供应商）纬度是没有关联的，那这个时候就可以把数据以用户的纬度来进行拆分。 就是用户1和用户2各自都有一套完整的业务逻辑，而且彼此之间不关联，所以就可以把用户1和用户2数据拆分到不同的数据库实例上面。目前很多互联网公司或者游戏公司有很多业务都是以用户纬度进行拆分的，比如qunaer、sohu game、sina等。 <img src="/uploads/2015/11/26230597_1412524160Vz9P.png" alt> （6.2） 水平拆分 水平拆分相对要简单一些，但是难度偏大，会导致分布式的情况、跨数据的情况、跨事务的情况可以分为大概三类，1是历史数据和实时数据拆分，2是单库多表拆分，3是多库多表拆分。 <strong>　　6.2.1实时数据历史数据的拆分</strong> 和历史数据迁移是一样的逻辑，就是要将online库的数据迁移到listory的数据库里面，对于实时的读写来说，数据是放在online db库里面，对于时间较远的数据来说，是放在历史History DB记录库里面的，这里的历史库可以是mysql也可以是别的nosql库等。 <img src="/uploads/2015/11/26230597_1412524200g5G6.png" alt> <strong>　　6.2.2单库多表拆分</strong> 主要不是解决容量问题，而是解决性能问题而扩展的，加入当前实例只有一个DB，有一个大表，一个大表就把整个实例占满了，这个时候就不能拆分db了，因为只有一个单表，这个时候我们就只能拆表了，拆表的方式主要是解决性能问题，因为单个表越大，对于mysql来说遍历表的树形结构遍历数据会消耗更多的资源，有时候一个简单的查询就可能会引起整个db的很多叶子节点都要变动。表的insert、update、delete操作都会引起几乎所有节点的变更，此时操作量会非常大，操作的时候读写性能都会很低，这个时候我们就可以考虑把大表拆分成多个小表，工作经历中是按照hash取模打散成16个小表，也有按照id主键/50取模打散到50个小表当中，下图实例是打散成2个小表。 <img src="/uploads/2015/11/26230597_1412524223NCxs.png" alt> <strong>　　6.2.3多库多表拆分</strong> 在单库多表的基础上，如果单库空间资源已经不足以提供业务支撑的话，可以考虑多库多表的方式来做，解决了空间问题和性能问题，不过会有一个问题就是跨库查询操作，查询就会有另外的策略，比如说加一个logic db层来实现跨库跨实例自动查询，简单如下图所示： <img src="/uploads/2015/11/26230597_1412524249tDq8.png" alt> <strong>　　6.2.4水平拆分小结</strong> 水平拆分原则： -- a.尽量均匀的拆分维度。 – b.尽量避免跨库事务。 – c.尽量避免跨库查询。 设计： –a根据拆分维度，做mod进行数据表拆分，大部分都是取模的拆分机制，比如hash的16模原则等。 –b根据数据容量，划分数据库拆分 数据操作 –a跨事务操作：分布式事务，通过预写日志的方式来间接地实现。 –b跨库查询：数据汇总or消息服务 <strong>　　6.2.5案例说明</strong> u 案例： – 按照用户维度进行拆分成64个分库，1024个分表 ?user_id%1024拆分到1024张分表中 ? 每个分库中存放1024/64张分表 ? 取模的时候，可以用id的最后4位数据或者3位数字来取模就可以了。 <img src="/uploads/2015/11/26230597_1412524295NgP6.png" alt> u 操作1：采用Configure DB – 拆分之后的查询操作，做一个Configure DB，这个DB存放的是所有实例的库表的映射关系，当我APP发来有一个请求查询user1的数据，那么这个user1的数据是存放在上千个实例中的哪一个库表呢？这个关联信息就在Configure DB里面，APP先去Configure DB里面取得user1的关联系信息(比如是存放在d_01库上的t_0016表里面)，然后APP根据关联信息直接去查询对应的d_01实例的t_0016表里面取得数据。 <img src="/uploads/2015/11/26230597_1412524329zfFY.png" alt> u 操作2：采用Proxy – 拆分之后的查询操作，做一个Proxy，APP访问Proxy，Proxy根据访问规则就可以直接路由到具体的db实例，生成新的sql去操作对应的db实例，然后通过Proxy协议进行操作把操作结果返回给APP。 – 优势是Proxy和db实例是在一个网段，这样Proxy与db实例的操作的时间是非常短的。 <img src="/uploads/2015/11/26230597_1412524367P848.png" alt> u 操作3：采用Data Engine – 拆分之后的查询操作，有一个Data Engine Service，这个DES里面配置了所有数据库实例的映射关系，需要在APP应用端安装一个Agent，是同步逻辑，在JDBC层实现，DES可以实现读写分离，原理可以参考TDDL的实现。 <img src="/uploads/2015/11/26230597_1412524397urm8.png" alt> <strong>　　6.3集群管理</strong> 纵向扩容：一个实例拆分成多个实例，纵向拆分比较简单，修改的东西比较少，拆分的时候要通知到Configure DB或者DES，以免拆分之后查询不到数据或者数据录入不到新的db上面，如下图所示： <img src="/uploads/2015/11/26230597_14125244398C03.png" alt> 横向扩容：比较复杂，在纵向扩容成2个库的基础之上，再一次对库的表进行扩容，所以需要及时通知Configure DB和DES更细库和表的路由连接信息。 <img src="/uploads/2015/11/26230597_1412524468uW2X.png" alt></p>

            
            <p class="more">
                <a href="/2015/11/24/2019030500111/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/11/24/2019030500111/" title="MySQL 高可用架构在业务层面的分析研究">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/4.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/11/24/2019030500006/">
    		CentOS7安装redis
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-11-24T07:09:26.000Z">2015-11-24</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/redis/" title="redis">redis</a> / 
    
        <a href="/tags/CentOS7/" title="CentOS7">CentOS7</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>本文介绍在CentOS7上安装redis数据库。 系统配置信息如下：  </p>
<p>C代码</p>
<ol>
<li>[linus@localhost ~]$ uname -r</li>
<li>3.10.0-229.20.1.el7.x86_64</li>
<li>[linus@localhost ~]$ more /etc/redhat-release</li>
<li>CentOS Linux release 7.1.1503 (Core)</li>
<li>[linus@localhost ~]$</li>
</ol>
<h2 id="Redis"><a href="#Redis" class="headerlink" title="Redis"></a>Redis</h2><p>1、下载Redis，当前最新版本是3.0.5，然后安装。</p>
<ol>
<li>[linus@localhost redis]$ wget <a href="http://download.redis.io/releases/redis-3.0.5.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-3.0.5.tar.gz</a></li>
<li>–2015-11-24 13:33:32–  <a href="http://download.redis.io/releases/redis-3.0.5.tar.gz" target="_blank" rel="noopener">http://download.redis.io/releases/redis-3.0.5.tar.gz</a></li>
<li>Resolving download.redis.io (download.redis.io)… 109.74.203.151</li>
<li>Connecting to download.redis.io (download.redis.io)|109.74.203.151|:80… connected.</li>
<li>HTTP request sent, awaiting response… 200 OK</li>
<li>Length: 1366160 (1.3M) [application/x-gzip]</li>
<li><p>Saving to: ‘redis-3.0.5.tar.gz’</p>
</li>
<li><p>100%[==============================================&gt;] 1,366,160   40.0KB/s   in 25s</p>
</li>
<li><p>2015-11-24 13:33:58 (54.1 KB/s) - ‘redis-3.0.5.tar.gz’ saved [1366160/1366160]</p>
</li>
<li><p>[linus@localhost redis]$</p>
</li>
<li>[linus@localhost redis]$ ls</li>
<li>redis-3.0.5.tar.gz</li>
<li>[linus@localhost redis]$ tar -zxf redis-3.0.5.tar.gz</li>
<li>[linus@localhost redis]$ cd redis-3.0.5/</li>
<li>[linus@localhost redis-3.0.5]$ make</li>
<li>cd src &amp;&amp; make all</li>
<li>make[1]: Entering directory `/home/linus/redis/redis-3.0.5/src’</li>
<li>rm -rf redis-server redis-sentinel redis-cli redis-benchmark redis-check-dump redis-check-aof <em>.o </em>.gcda <em>.gcno </em>.gcov redis.info lcov-html</li>
<li>(cd ../deps &amp;&amp; make distclean)</li>
<li>make[2]: Entering directory `/home/linus/redis/redis-3.0.5/deps’</li>
<li>(cd hiredis &amp;&amp; make clean) &gt; /dev/null || true</li>
<li>(cd linenoise &amp;&amp; make clean) &gt; /dev/null || true</li>
<li>(cd lua &amp;&amp; make clean) &gt; /dev/null || true</li>
<li>(cd jemalloc &amp;&amp; [ -f Makefile ] &amp;&amp; make distclean) &gt; /dev/null || true</li>
<li>(rm -f .make-*)</li>
<li>make[2]: Leaving directory `/home/linus/redis/redis-3.0.5/deps’</li>
<li>(rm -f .make-*)</li>
<li>echo STD=-std=c99 -pedantic &gt;&gt; .make-settings</li>
<li>echo WARN=-Wall -W &gt;&gt; .make-settings</li>
<li>echo OPT=-O2 &gt;&gt; .make-settings</li>
<li>echo MALLOC=jemalloc &gt;&gt; .make-settings</li>
<li>echo CFLAGS= &gt;&gt; .make-settings</li>
<li>echo LDFLAGS= &gt;&gt; .make-settings</li>
<li>echo REDIS_CFLAGS= &gt;&gt; .make-settings</li>
<li>echo REDIS_LDFLAGS= &gt;&gt; .make-settings</li>
<li>echo PREV_FINAL_CFLAGS=-std=c99 -pedantic -Wall -W -O2 -g -ggdb   -I../deps/hiredis -I../deps/linenoise -I../deps/lua/src -DUSE_JEMALLOC -I../deps/jemalloc/include &gt;&gt; .make-settings</li>
<li>echo PREV_FINAL_LDFLAGS=  -g -ggdb -rdynamic &gt;&gt; .make-settings</li>
<li>。。。</li>
<li>。。。</li>
<li>LINK redis-server</li>
<li>INSTALL redis-sentinel</li>
<li>CC redis-cli.o</li>
<li>LINK redis-cli</li>
<li>CC redis-benchmark.o</li>
<li>LINK redis-benchmark</li>
<li>CC redis-check-dump.o</li>
<li>LINK redis-check-dump</li>
<li>CC redis-check-aof.o</li>
<li><p>LINK redis-check-aof</p>
</li>
<li><p>Hint: It’s a good idea to run ‘make test’ ;)</p>
</li>
<li><p>make[1]: Leaving directory `/home/linus/redis/redis-3.0.5/src’</p>
</li>
</ol>
<p>然后执行make test进行验证，报如下错误，安装tcl之后就可以正常执行了：</p>
<ol>
<li>[linus@localhost redis-3.0.5]$ make test</li>
<li>cd src &amp;&amp; make test</li>
<li>make[1]: Entering directory `/home/linus/redis/redis-3.0.5/src’</li>
<li>You need tcl 8.5 or newer in order to run the Redis test</li>
<li>make[1]: *** [test] Error 1</li>
<li>make[1]: Leaving directory `/home/linus/redis/redis-3.0.5/src’</li>
<li>make: *** [test] Error 2</li>
<li>[linus@localhost redis-3.0.5]$ make test</li>
<li>…</li>
<li>…</li>
<li><p>The End</p>
</li>
<li><p>Execution time of different units:</p>
</li>
<li>1 seconds - unit/printver</li>
<li>2 seconds - unit/scan</li>
<li>2 seconds - unit/quit</li>
<li>3 seconds - unit/auth</li>
<li>3 seconds - unit/multi</li>
<li>5 seconds - unit/protocol</li>
<li>11 seconds - unit/expire</li>
<li>21 seconds - unit/type/list</li>
<li>35 seconds - unit/other</li>
<li>40 seconds - unit/type/list-2</li>
<li>19 seconds - integration/aof</li>
<li>41 seconds - unit/type/hash</li>
<li>42 seconds - unit/dump</li>
<li>3 seconds - integration/logging</li>
<li>2 seconds - unit/pubsub</li>
<li>8 seconds - integration/rdb</li>
<li>3 seconds - unit/slowlog</li>
<li>2 seconds - unit/introspection</li>
<li>6 seconds - integration/convert-zipmap-hash-on-load</li>
<li>2 seconds - unit/limits</li>
<li>12 seconds - unit/scripting</li>
<li>19 seconds - unit/bitops</li>
<li>67 seconds - unit/type/set</li>
<li>72 seconds - integration/replication-2</li>
<li>30 seconds - unit/memefficiency</li>
<li>77 seconds - unit/type/zset</li>
<li>79 seconds - unit/sort</li>
<li>79 seconds - unit/aofrw</li>
<li>84 seconds - unit/basic</li>
<li>42 seconds - unit/maxmemory</li>
<li>91 seconds - unit/type/list-3</li>
<li>117 seconds - integration/replication-4</li>
<li>67 seconds - unit/hyperloglog</li>
<li>122 seconds - integration/replication-3</li>
<li>137 seconds - integration/replication</li>
<li>134 seconds - integration/replication-psync</li>
<li><p>114 seconds - unit/obuf-limits</p>
</li>
<li><p>\o/ All tests passed without errors!</p>
</li>
<li><p>Cleanup: may take some time… OK</p>
</li>
<li>make[1]: Leaving directory `/home/linus/redis/redis-3.0.5/src’</li>
<li>[linus@localhost redis-3.0.5]$</li>
</ol>
<p>安装完成后，可以切换src目录下，执行redis-server命令启动redis服务器：  </p>
<ol>
<li>[linus@localhost src]$ ./redis-server &amp;</li>
<li>[1] 8921</li>
<li>[linus@localhost src]$ 8921:C 24 Nov 13:44:17.995 # Warning: no config file specified, using the default config. In order to specify a config file use ./redis-server /path/to/redis.conf</li>
<li>8921:M 24 Nov 13:44:17.997 # You requested maxclients of 10000 requiring at least 10032 max file descriptors.</li>
<li>8921:M 24 Nov 13:44:17.997 # Redis can’t set maximum open files to 10032 because of OS error: Operation not permitted.</li>
<li>8921:M 24 Nov 13:44:17.997 # Current maximum open files is 4096. maxclients has been reduced to 4064 to compensate for low ulimit. If you need higher maxclients increase ‘ulimit -n’.</li>
<li>_._</li>
<li><em>.-<code></code>__ ‘’-.</em></li>
<li><em>.-<code></code>    <code>.</code></em>.  ‘’-._           Redis 3.0.5 (00000000/0) 64 bit</li>
<li>.-<code>.-`</code>.  <code>`</code>\/    _.,_ ‘’-._</li>
<li>(    ‘      ,       .-<code>|</code>,    )     Running in standalone mode</li>
<li>|<code>-._</code>-…-<code>__...-.`</code>-._|’` _.-‘|     Port: 6379</li>
<li>|    <code>-._</code>._    /     _.-‘    |     PID: 8921</li>
<li><code>-._</code>-._  `-./  _.-‘    _.-‘</li>
<li>|<code>-._</code>-._    `-.__.-‘    <em>.-‘</em>.-‘|</li>
<li>|    <code>-._</code>-._        <em>.-‘</em>.-‘    |           <a href="http://redis.io" target="_blank" rel="noopener">http://redis.io</a>        </li>
<li><code>-._</code>-.<em>`-.__.-‘</em>.-‘    _.-‘</li>
<li>|<code>-._</code>-._    `-.__.-‘    <em>.-‘</em>.-‘|</li>
<li>|    <code>-._</code>-._        <em>.-‘</em>.-‘    |</li>
<li><code>-._</code>-.<em>`-.__.-‘</em>.-‘    _.-‘</li>
<li><code>-._</code>-.__.-‘    _.-‘</li>
<li>`-._        _.-‘</li>
<li><p>`-.__.-‘</p>
</li>
<li><p>8921:M 24 Nov 13:44:17.998 # WARNING: The TCP backlog setting of 511 cannot be enforced because /proc/sys/net/core/somaxconn is set to the lower value of 128.</p>
</li>
<li>8921:M 24 Nov 13:44:17.999 # Server started, Redis version 3.0.5</li>
<li>8921:M 24 Nov 13:44:17.999 # WARNING overcommit_memory is set to 0! Background save may fail under low memory condition. To fix this issue add ‘vm.overcommit_memory = 1’ to /etc/sysctl.conf and then reboot or run the command ‘sysctl vm.overcommit_memory=1’ for this to take effect.</li>
<li>8921:M 24 Nov 13:44:17.999 # WARNING you have Transparent Huge Pages (THP) support enabled in your kernel. This will create latency and memory usage issues with Redis. To fix this issue run the command ‘echo never &gt; /sys/kernel/mm/transparent_hugepage/enabled’ as root, and add it to your /etc/rc.local in order to retain the setting after a reboot. Redis must be restarted after THP is disabled.</li>
<li>8921:M 24 Nov 13:44:17.999 * DB loaded from disk: 0.000 seconds</li>
<li><p>8921:M 24 Nov 13:44:17.999 * The server is now ready to accept connections on port 6379</p>
<p>此时可以通过redis-cli命令连接该redis服务器，并且可以通过SHUTDOWN命令关闭服务器：</p>
</li>
<li><p>[linus@localhost src]$ ./redis-cli</p>
</li>
<li>127.0.0.1:6379&gt; INFO</li>
<li><h1 id="Server"><a href="#Server" class="headerlink" title="Server"></a>Server</h1></li>
<li>redis_version:3.0.5</li>
<li>redis_git_sha1:00000000</li>
<li>redis_git_dirty:0</li>
<li>redis_build_id:cdf25f7608cc4cbe</li>
<li>redis_mode:standalone</li>
<li>os:Linux 3.10.0-229.20.1.el7.x86_64 x86_64</li>
<li>arch_bits:64</li>
<li>multiplexing_api:epoll</li>
<li>gcc_version:4.8.3</li>
<li>process_id:8921</li>
<li>run_id:c4bf78bec7e54a517634bb62430406946c91733d</li>
<li>tcp_port:6379</li>
<li>uptime_in_seconds:104</li>
<li>uptime_in_days:0</li>
<li>hz:10</li>
<li>lru_clock:5503385</li>
<li><p>config_file:</p>
</li>
<li><h1 id="Clients"><a href="#Clients" class="headerlink" title="Clients"></a>Clients</h1></li>
<li>connected_clients:1</li>
<li>client_longest_output_list:0</li>
<li>client_biggest_input_buf:0</li>
<li><p>blocked_clients:0</p>
</li>
<li><h1 id="Memory"><a href="#Memory" class="headerlink" title="Memory"></a>Memory</h1></li>
<li>used_memory:508712</li>
<li>used_memory_human:496.79K</li>
<li>used_memory_rss:8024064</li>
<li>used_memory_peak:508712</li>
<li>used_memory_peak_human:496.79K</li>
<li>used_memory_lua:36864</li>
<li>mem_fragmentation_ratio:15.77</li>
<li><p>mem_allocator:jemalloc-3.6.0</p>
</li>
<li><h1 id="Persistence"><a href="#Persistence" class="headerlink" title="Persistence"></a>Persistence</h1></li>
<li>loading:0</li>
<li>rdb_changes_since_last_save:0</li>
<li>rdb_bgsave_in_progress:0</li>
<li>rdb_last_save_time:1448343857</li>
<li>rdb_last_bgsave_status:ok</li>
<li>rdb_last_bgsave_time_sec:-1</li>
<li>rdb_current_bgsave_time_sec:-1</li>
<li>aof_enabled:0</li>
<li>aof_rewrite_in_progress:0</li>
<li>aof_rewrite_scheduled:0</li>
<li>aof_last_rewrite_time_sec:-1</li>
<li>aof_current_rewrite_time_sec:-1</li>
<li>aof_last_bgrewrite_status:ok</li>
<li><p>aof_last_write_status:ok</p>
</li>
<li><h1 id="Stats"><a href="#Stats" class="headerlink" title="Stats"></a>Stats</h1></li>
<li>total_connections_received:1</li>
<li>total_commands_processed:0</li>
<li>instantaneous_ops_per_sec:0</li>
<li>total_net_input_bytes:14</li>
<li>total_net_output_bytes:0</li>
<li>instantaneous_input_kbps:0.00</li>
<li>instantaneous_output_kbps:0.00</li>
<li>rejected_connections:0</li>
<li>sync_full:0</li>
<li>sync_partial_ok:0</li>
<li>sync_partial_err:0</li>
<li>expired_keys:0</li>
<li>evicted_keys:0</li>
<li>keyspace_hits:0</li>
<li>keyspace_misses:0</li>
<li>pubsub_channels:0</li>
<li>pubsub_patterns:0</li>
<li>latest_fork_usec:0</li>
<li><p>migrate_cached_sockets:0</p>
</li>
<li><h1 id="Replication"><a href="#Replication" class="headerlink" title="Replication"></a>Replication</h1></li>
<li>role:master</li>
<li>connected_slaves:0</li>
<li>master_repl_offset:0</li>
<li>repl_backlog_active:0</li>
<li>repl_backlog_size:1048576</li>
<li>repl_backlog_first_byte_offset:0</li>
<li><p>repl_backlog_histlen:0</p>
</li>
<li><h1 id="CPU"><a href="#CPU" class="headerlink" title="CPU"></a>CPU</h1></li>
<li>used_cpu_sys:0.10</li>
<li>used_cpu_user:0.04</li>
<li>used_cpu_sys_children:0.00</li>
<li><p>used_cpu_user_children:0.00</p>
</li>
<li><h1 id="Cluster"><a href="#Cluster" class="headerlink" title="Cluster"></a>Cluster</h1></li>
<li><p>cluster_enabled:0</p>
</li>
<li><h1 id="Keyspace"><a href="#Keyspace" class="headerlink" title="Keyspace"></a>Keyspace</h1></li>
<li>127.0.0.1:6379&gt;</li>
<li>127.0.0.1:6379&gt; SHUTDOWN</li>
<li><p>not connected&gt;</p>
</li>
<li><p>服务器端会打印：</p>
</li>
<li>8921:M 24 Nov 13:46:52.838 # User requested shutdown…</li>
<li>8921:M 24 Nov 13:46:52.838 * Saving the final RDB snapshot before exiting.</li>
<li>8921:M 24 Nov 13:46:52.844 * DB saved on disk</li>
<li>8921:M 24 Nov 13:46:52.844 # Redis is now ready to exit, bye bye…</li>
</ol>
<p>服务器端配置：   最关键的配置以下选项：</p>
<ol>
<li><h1 id="By-default-Redis-does-not-run-as-a-daemon-Use-‘yes’-if-you-need-it"><a href="#By-default-Redis-does-not-run-as-a-daemon-Use-‘yes’-if-you-need-it" class="headerlink" title="By default Redis does not run as a daemon. Use ‘yes’ if you need it."></a>By default Redis does not run as a daemon. Use ‘yes’ if you need it.</h1></li>
<li><h1 id="Note-that-Redis-will-write-a-pid-file-in-var-run-redis-pid-when-daemonized"><a href="#Note-that-Redis-will-write-a-pid-file-in-var-run-redis-pid-when-daemonized" class="headerlink" title="Note that Redis will write a pid file in /var/run/redis.pid when daemonized."></a>Note that Redis will write a pid file in /var/run/redis.pid when daemonized.</h1></li>
<li>daemonize yes</li>
<li><h1 id="Specify-the-server-verbosity-level"><a href="#Specify-the-server-verbosity-level" class="headerlink" title="Specify the server verbosity level."></a>Specify the server verbosity level.</h1></li>
<li><h1 id="This-can-be-one-of"><a href="#This-can-be-one-of" class="headerlink" title="This can be one of:"></a>This can be one of:</h1></li>
<li><h1 id="debug-a-lot-of-information-useful-for-development-testing"><a href="#debug-a-lot-of-information-useful-for-development-testing" class="headerlink" title="debug (a lot of information, useful for development/testing)"></a>debug (a lot of information, useful for development/testing)</h1></li>
<li><h1 id="verbose-many-rarely-useful-info-but-not-a-mess-like-the-debug-level"><a href="#verbose-many-rarely-useful-info-but-not-a-mess-like-the-debug-level" class="headerlink" title="verbose (many rarely useful info, but not a mess like the debug level)"></a>verbose (many rarely useful info, but not a mess like the debug level)</h1></li>
<li><h1 id="notice-moderately-verbose-what-you-want-in-production-probably"><a href="#notice-moderately-verbose-what-you-want-in-production-probably" class="headerlink" title="notice (moderately verbose, what you want in production probably)"></a>notice (moderately verbose, what you want in production probably)</h1></li>
<li><h1 id="warning-only-very-important-critical-messages-are-logged"><a href="#warning-only-very-important-critical-messages-are-logged" class="headerlink" title="warning (only very important / critical messages are logged)"></a>warning (only very important / critical messages are logged)</h1></li>
<li>loglevel notice</li>
<li><h1 id="Specify-the-log-file-name-Also-the-empty-string-can-be-used-to-force"><a href="#Specify-the-log-file-name-Also-the-empty-string-can-be-used-to-force" class="headerlink" title="Specify the log file name. Also the empty string can be used to force"></a>Specify the log file name. Also the empty string can be used to force</h1></li>
<li><h1 id="Redis-to-log-on-the-standard-output-Note-that-if-you-use-standard"><a href="#Redis-to-log-on-the-standard-output-Note-that-if-you-use-standard" class="headerlink" title="Redis to log on the standard output. Note that if you use standard"></a>Redis to log on the standard output. Note that if you use standard</h1></li>
<li><h1 id="output-for-logging-but-daemonize-logs-will-be-sent-to-dev-null"><a href="#output-for-logging-but-daemonize-logs-will-be-sent-to-dev-null" class="headerlink" title="output for logging but daemonize, logs will be sent to /dev/null"></a>output for logging but daemonize, logs will be sent to /dev/null</h1></li>
<li>logfile /var/log/redis.log</li>
<li><h1 id="The-working-directory"><a href="#The-working-directory" class="headerlink" title="The working directory."></a>The working directory.</h1></li>
<li>#</li>
<li><h1 id="The-DB-will-be-written-inside-this-directory-with-the-filename-specified"><a href="#The-DB-will-be-written-inside-this-directory-with-the-filename-specified" class="headerlink" title="The DB will be written inside this directory, with the filename specified"></a>The DB will be written inside this directory, with the filename specified</h1></li>
<li><h1 id="above-using-the-‘dbfilename’-configuration-directive"><a href="#above-using-the-‘dbfilename’-configuration-directive" class="headerlink" title="above using the ‘dbfilename’ configuration directive."></a>above using the ‘dbfilename’ configuration directive.</h1></li>
<li>#</li>
<li><h1 id="The-Append-Only-File-will-also-be-created-inside-this-directory"><a href="#The-Append-Only-File-will-also-be-created-inside-this-directory" class="headerlink" title="The Append Only File will also be created inside this directory."></a>The Append Only File will also be created inside this directory.</h1></li>
<li>#</li>
<li><h1 id="Note-that-you-must-specify-a-directory-here-not-a-file-name"><a href="#Note-that-you-must-specify-a-directory-here-not-a-file-name" class="headerlink" title="Note that you must specify a directory here, not a file name."></a>Note that you must specify a directory here, not a file name.</h1></li>
<li><p>dir ./</p>
<p>添加启动脚本/etc/init.d/redis：</p>
</li>
<li><p>#!/bin/sh</p>
</li>
<li>#</li>
<li><h1 id="redis-Startup-script-for-Redis-Server"><a href="#redis-Startup-script-for-Redis-Server" class="headerlink" title="redis        Startup script for Redis Server"></a>redis        Startup script for Redis Server</h1></li>
<li>#</li>
<li><h1 id="chkconfig-90-10"><a href="#chkconfig-90-10" class="headerlink" title="chkconfig: - 90 10"></a>chkconfig: - 90 10</h1></li>
<li><h1 id="description-Redis-is-an-open-source-advanced-key-value-store"><a href="#description-Redis-is-an-open-source-advanced-key-value-store" class="headerlink" title="description: Redis is an open source, advanced key-value store."></a>description: Redis is an open source, advanced key-value store.</h1></li>
<li>#</li>
<li><h1 id="processname-redis-server"><a href="#processname-redis-server" class="headerlink" title="processname: redis-server"></a>processname: redis-server</h1></li>
<li><h1 id="config-etc-redis-conf"><a href="#config-etc-redis-conf" class="headerlink" title="config: /etc/redis.conf"></a>config: /etc/redis.conf</h1></li>
<li><h1 id="pidfile-var-run-redis-pid"><a href="#pidfile-var-run-redis-pid" class="headerlink" title="pidfile: /var/run/redis.pid"></a>pidfile: /var/run/redis.pid</h1></li>
<li><p>REDISPORT=6379</p>
</li>
<li><h1 id="下面的目录要看编译的目录，这两个文件会在编译目录的src目录下。"><a href="#下面的目录要看编译的目录，这两个文件会在编译目录的src目录下。" class="headerlink" title="下面的目录要看编译的目录，这两个文件会在编译目录的src目录下。"></a>下面的目录要看编译的目录，这两个文件会在编译目录的src目录下。</h1></li>
<li>EXEC=/usr/local/bin/redis-server</li>
<li><p>REDIS_CLI=/usr/local/bin/redis-cli</p>
</li>
<li><p>PIDFILE=/var/run/redis.pid</p>
</li>
<li><h1 id="下面的目录要看编译的目录，这个文件会在编译目录下。"><a href="#下面的目录要看编译的目录，这个文件会在编译目录下。" class="headerlink" title="下面的目录要看编译的目录，这个文件会在编译目录下。"></a>下面的目录要看编译的目录，这个文件会在编译目录下。</h1></li>
<li><p>CONF=”/usr/src/redis-2.8.13/redis.conf”</p>
</li>
<li><p>case “$1” in</p>
</li>
<li>start)</li>
<li>if [ -f $PIDFILE ]</li>
<li>then</li>
<li>echo “$PIDFILE exists, process is already running or crashed”</li>
<li>else</li>
<li>echo “Starting Redis server…”</li>
<li>$EXEC $CONF</li>
<li>fi</li>
<li>if [ “$?”=”0” ]</li>
<li>then</li>
<li>echo “Redis is running…”</li>
<li>fi</li>
<li>;;</li>
<li>stop)</li>
<li>if [ ! -f $PIDFILE ]</li>
<li>then</li>
<li>echo “$PIDFILE does not exist, process is not running”</li>
<li>else</li>
<li>PID=$(cat $PIDFILE)</li>
<li>echo “Stopping …”</li>
<li>$REDIS_CLI -p $REDISPORT SHUTDOWN</li>
<li>while [ -x ${PIDFILE} ]</li>
<li>do</li>
<li>echo “Waiting for Redis to shutdown …”</li>
<li>sleep 1</li>
<li>done</li>
<li>echo “Redis stopped”</li>
<li>fi</li>
<li>;;</li>
<li>restart|force-reload)</li>
<li>${0} stop</li>
<li>${0} start</li>
<li>;;</li>
<li>*)</li>
<li>echo “Usage: /etc/init.d/redis {start|stop|restart|force-reload}” &gt;&amp;2</li>
<li>exit 1</li>
<li><p>esac</p>
<p>添加redis为系统的服务：</p>
</li>
<li><p>[root@localhost redis]# ll /etc/init.d/redis</p>
</li>
<li>-rw-r–r–. 1 root root 1394 Nov 24 14:06 /etc/init.d/redis</li>
<li>[root@localhost redis]# chmod +x /etc/init.d/redis</li>
<li>[root@localhost redis]# ll /etc/init.d/redis</li>
<li>-rwxr-xr-x. 1 root root 1394 Nov 24 14:06 /etc/init.d/redis</li>
<li>[root@localhost redis]#</li>
<li>[root@localhost redis]# chkconfig –add redis</li>
<li>[root@localhost redis]# chkconfig redis on</li>
<li><p>[root@localhost redis]# chkconfig</p>
</li>
<li><p>Note: This output shows SysV services only and does not include native</p>
</li>
<li>systemd services. SysV configuration data might be overridden by native</li>
<li><p>systemd configuration.</p>
</li>
<li><p>If you want to list systemd services use ‘systemctl list-unit-files’.</p>
</li>
<li>To see services enabled on particular target use</li>
<li><p>‘systemctl list-dependencies [target]‘.</p>
</li>
<li><p>netconsole      0:off   1:off   2:off   3:off   4:off   5:off   6:off</p>
</li>
<li>network         0:off   1:off   2:on    3:on    4:on    5:on    6:off</li>
<li>redis           0:off   1:off   2:on    3:on    4:on    5:on    6:off</li>
<li>[root@localhost redis]#</li>
</ol>
<p>ok，现在就安装好了。启动redis使用<code>service redis start</code> 或者<code>/etc/init.d/redis start</code> ，停止redis的命令<code>service redis stop</code> 或者<code>/etc/init.d/redis stop。</code></p>

            
            <p class="more">
                <a href="/2015/11/24/2019030500006/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/11/24/2019030500006/" title="CentOS7安装redis">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/4.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/NOSQL/">NOSQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/11/24/2019030500153/">
    		redis数据类型
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-11-24T06:23:53.000Z">2015-11-24</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/redis/" title="redis">redis</a> / 
    
        <a href="/tags/数据类型/" title="数据类型">数据类型</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <h1 id="Redis-数据类型"><a href="#Redis-数据类型" class="headerlink" title="Redis - 数据类型"></a>Redis - 数据类型</h1><p>Redis支持5种类型的数据类型，它描述如下的：</p>
<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>Redis字符串是字节序列。Redis字符串是二进制安全的，这意味着他们有一个已知的长度没有任何特殊字符终止，所以你可以存储任何东西，512兆为上限。</p>
<h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><p>redis 127.0.0.1:6379&gt; SET name “yiibai”<br>OK<br>redis 127.0.0.1:6379&gt; GET name<br>“yiibai”</p>
<p>上面是Redis的set和get命令的例子，Redis名称为yiibai使用的key存储在Redis的字符串值。</p>
<h2 id="哈希"><a href="#哈希" class="headerlink" title="哈希"></a>哈希</h2><p>Redis的哈希是键值对的集合。 Redis的哈希值是字符串字段和字符串值之间的映射，因此它们被用来表示对象</p>
<h3 id="例子-1"><a href="#例子-1" class="headerlink" title="例子"></a>例子</h3><p>redis 127.0.0.1:6379&gt; HMSET user:1 username yiibai password yiibai points 200<br>OK<br>redis 127.0.0.1:6379&gt; HGETALL user:1<br> 1) “username”<br>2) “yiibai”<br>3) “password”<br>4) “yiibai”<br>5) “points”<br>6) “200” </p>
<p>在上面的例子中的哈希数据类型，用于存储其中包含的用户的基本信息用户的对象。这里HMSET，HEGTALL用户命令user:1是键。</p>
<h2 id="列表"><a href="#列表" class="headerlink" title="列表"></a>列表</h2><p>Redis的列表是简单的字符串列表，排序插入顺序。您可以添加元素到Redis的列表的头部或尾部。</p>
<h3 id="例子-2"><a href="#例子-2" class="headerlink" title="例子"></a>例子</h3><p>redis 127.0.0.1:6379&gt; lpush tutoriallist redis<br>(integer) 1<br>redis 127.0.0.1:6379&gt; lpush tutoriallist mongodb<br>(integer) 2<br>redis 127.0.0.1:6379&gt; lpush tutoriallist rabitmq<br>(integer) 3<br>redis 127.0.0.1:6379&gt; lrange tutoriallist 0 10<br> 1) “rabitmq”<br>2) “mongodb”<br>3) “redis” </p>
<p>列表的最大长度为 232 - 1 元素（4294967295，每个列表中可容纳超过4十亿的元素）。</p>
<h2 id="集合"><a href="#集合" class="headerlink" title="集合"></a>集合</h2><p>Redis的集合是字符串的无序集合。在Redis您可以添加，删除和测试文件是否存在，在成员O（1）的时间复杂度。</p>
<h3 id="例子-3"><a href="#例子-3" class="headerlink" title="例子"></a>例子</h3><p>redis 127.0.0.1:6379&gt; sadd tutoriallist redis<br>(integer) 1<br>redis 127.0.0.1:6379&gt; sadd tutoriallist mongodb<br>(integer) 1<br>redis 127.0.0.1:6379&gt; sadd tutoriallist rabitmq<br>(integer) 1<br>redis 127.0.0.1:6379&gt; sadd tutoriallist rabitmq<br>(integer) 0<br>redis 127.0.0.1:6379&gt; smembers tutoriallist<br> 1) “rabitmq”<br>2) “mongodb”<br>3) “redis” </p>
<p><strong>注意：</strong>在上面的例子中rabitmq集合添加加两次，但由于集合元素具有唯一属性。 集合中的元素最大数量为 232 - 1 （4294967295，可容纳超过4十亿元素）。</p>
<h2 id="有序集合"><a href="#有序集合" class="headerlink" title="有序集合"></a>有序集合</h2><p>Redis的有序集合类似于Redis的集合，字符串不重复的集合。不同的是，一个有序集合的每个成员用分数，以便采取有序set命令，从最小的到最大的成员分数有关。虽然成员具有唯一性，但分数可能会重复。</p>
<h3 id="例子-4"><a href="#例子-4" class="headerlink" title="例子"></a>例子</h3><p>redis 127.0.0.1:6379&gt; zadd tutoriallist 0 redis<br>(integer) 1<br>redis 127.0.0.1:6379&gt; zadd tutoriallist 0 mongodb<br>(integer) 1<br>redis 127.0.0.1:6379&gt; zadd tutoriallist 0 rabitmq<br>(integer) 1<br>redis 127.0.0.1:6379&gt; zadd tutoriallist 0 rabitmq<br>(integer) 0<br>redis 127.0.0.1:6379&gt; ZRANGEBYSCORE tutoriallist 0 1000<br> 1) “redis”<br>2) “mongodb”<br>3) “rabitmq” </p>
<h1 id="Redis-keys"><a href="#Redis-keys" class="headerlink" title="Redis - keys"></a>Redis - keys</h1><p>Redis keys命令用于在Redis的管理键。Redis keys命令使用语法如下所示：</p>
<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><p>redis 127.0.0.1:6379&gt; COMMAND KEY_NAME</p>
<h3 id="例子-5"><a href="#例子-5" class="headerlink" title="例子"></a>例子</h3><p>redis 127.0.0.1:6379&gt; SET yiibai redis<br>OK<br>redis 127.0.0.1:6379&gt; DEL yiibai<br>(integer) 1</p>
<p>在上面的例子中DEL是命令，而yiibai是key。如果key被删除，那么输出该命令将是（整数）1，否则它会是（整数）0</p>
<h1 id="Redis-Strings"><a href="#Redis-Strings" class="headerlink" title="Redis - Strings"></a>Redis - Strings</h1><p>Redis strings命令用于在Redis的管理字符串值。Redis strings命令的使用语法，如下所示：</p>
<h2 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h2><p>redis 127.0.0.1:6379&gt; COMMAND KEY_NAME</p>
<h2 id="例子-6"><a href="#例子-6" class="headerlink" title="例子"></a>例子</h2><p>redis 127.0.0.1:6379&gt; SET yiibai redis<br>OK<br>redis 127.0.0.1:6379&gt; GET yiibai<br>“redis”</p>
<p>在上面的例子SET和GET是命令，而yiibai是key。</p>
<h1 id="Redis-哈希"><a href="#Redis-哈希" class="headerlink" title="Redis - 哈希"></a>Redis - 哈希</h1><p>Redis的哈希值是字符串字段和字符串值之间的映射，所以他们是代表对象的完美数据类型 在Redis的哈希值，最多可存储超过400十亿字段 - 值对。</p>
<h2 id="例子-7"><a href="#例子-7" class="headerlink" title="例子"></a>例子</h2><p>redis 127.0.0.1:6379&gt; HMSET yiibai name “redis tutorial” description “redis basic commands for caching” likes 20 visitors 23000<br>OK<br>redis 127.0.0.1:6379&gt; HGETALL yiibai<br> 1) “name”<br>2) “redis tutorial”<br>3) “description”<br>4) “redis basic commands for caching”<br>5) “likes”<br>6) “20”<br>7) “visitors”<br>8) “23000” </p>
<p>在上面的例子中，已经在哈希命名yiibai的Redis集合名为tutorials（name, description, likes, visitors）</p>
<h1 id="Redis-列表"><a href="#Redis-列表" class="headerlink" title="Redis - 列表"></a>Redis - 列表</h1><p>Redis的列表是简单的字符串列表，排序插入顺序。您可以添加Redis元素在列表头部或列表的尾部。 列表的最大长度为 232 - 1 个元素（每个列表元素个数超过4294967295）。</p>
<h2 id="例子-8"><a href="#例子-8" class="headerlink" title="例子"></a>例子</h2><p>redis 127.0.0.1:6379&gt; LPUSH tutorials redis<br>(integer) 1<br>redis 127.0.0.1:6379&gt; LPUSH tutorials mongodb<br>(integer) 2<br>redis 127.0.0.1:6379&gt; LPUSH tutorials mysql<br>(integer) 3<br>redis 127.0.0.1:6379&gt; LRANGE tutorials 0 10<br> 1) “mysql”<br>2) “mongodb”<br>3) “redis” </p>
<p>在上述例子中的三个值被插入在redis列表名为LPUSH的命令教程。</p>
<h1 id="Redis-集合"><a href="#Redis-集合" class="headerlink" title="Redis - 集合"></a>Redis - 集合</h1><p>Redis的集合是唯一的字符串的无序集合。集合的唯一性不允许数据的重复的键。 在Redis的集合添加，删除和测试文件是否存在成员在O（1）（常数时间不管里面包含的元素集合的数量）。集合的最大长度为 232 - 1 个元素（每集合超过4294967295元素）。</p>
<h2 id="例子-9"><a href="#例子-9" class="headerlink" title="例子"></a>例子</h2><p>redis 127.0.0.1:6379&gt; SADD tutorials redis<br>(integer) 1<br>redis 127.0.0.1:6379&gt; SADD tutorials mongodb<br>(integer) 1<br>redis 127.0.0.1:6379&gt; SADD tutorials mysql<br>(integer) 1<br>redis 127.0.0.1:6379&gt; SADD tutorials mysql<br>(integer) 0<br>redis 127.0.0.1:6379&gt; SMEMBERS tutorials<br> 1) “mysql”<br>2) “mongodb”<br>3) “redis” </p>
<p>在上述例子中的三个值被命令SADD插入redis的集合名称tutorials。</p>
<h1 id="Redis有序集"><a href="#Redis有序集" class="headerlink" title="Redis有序集"></a>Redis有序集</h1><p>Redis的有序集合类似Redis的集合存储在设定值具有唯一性。不同的是，一个有序集合的每个成员用分数，以便采取有序set命令，从最小的到最大的分数有关。 在Redis的有序set添加，删除和测试存在成员O（1）（固定时间，无论里面包含集合元素的数量）。列表的最大长度为 232 - 1 个元素（每集合超过4294967295元素）。</p>
<h2 id="例子-10"><a href="#例子-10" class="headerlink" title="例子"></a>例子</h2><p>redis 127.0.0.1:6379&gt; ZADD tutorials 1 redis<br>(integer) 1<br>redis 127.0.0.1:6379&gt; ZADD tutorials 2 mongodb<br>(integer) 1<br>redis 127.0.0.1:6379&gt; ZADD tutorials 3 mysql<br>(integer) 1<br>redis 127.0.0.1:6379&gt; ZADD tutorials 3 mysql<br>(integer) 0<br>redis 127.0.0.1:6379&gt; ZADD tutorials 4 mysql<br>(integer) 0<br>redis 127.0.0.1:6379&gt; ZRANGE tutorials 0 10 WITHSCORES<br> 1) “redis”<br>2) “1”<br>3) “mongodb”<br>4) “2”<br>5) “mysql”<br>6) “4” </p>
<p>在上述例子中的三个值被命令ZADD插入其得分在redis的有序集命名为tutorials。</p>
<h1 id="Redis-HyperLogLog"><a href="#Redis-HyperLogLog" class="headerlink" title="Redis - HyperLogLog"></a>Redis - HyperLogLog</h1><p>Redis的HyperLogLog使用随机化，以提供唯一的元素数目近似的集合只使用一个常数，并且体积小，少量内存的算法。 HyperLogLog提供，即使每个使用了非常少量的内存（12千字节），标准误差为集合的基数非常近似，没有限制的条目数，可以指定，除非接近 264个条目。</p>
<h3 id="例子-11"><a href="#例子-11" class="headerlink" title="例子"></a>例子</h3><p>下面的示例说明Redis的HyperLogLog工作原理：</p>
<p>redis 127.0.0.1:6379&gt; PFADD tutorials “redis”<br> 1) (integer) 1<br>redis 127.0.0.1:6379&gt; PFADD tutorials “mongodb”<br> 1) (integer) 1<br>redis 127.0.0.1:6379&gt; PFADD tutorials “mysql”<br> 1) (integer) 1<br>redis 127.0.0.1:6379&gt; PFCOUNT tutorials<br> (integer) 3 </p>
<h1 id="Redis-订阅"><a href="#Redis-订阅" class="headerlink" title="Redis - 订阅"></a>Redis - 订阅</h1><p>Redis的订阅实现了邮件系统，发送者（在Redis的术语中被称为发布者）发送的邮件，而接收器（用户）接收它们。由该消息传送的链路被称为通道。 在Redis客户端可以订阅任何数目的通道。</p>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下举例说明如何发布用户的概念工作。在下面的例子给出一个客户端订阅一个通道名为redisChat</p>
<p>redis 127.0.0.1:6379&gt; SUBSCRIBE redisChat<br> Reading messages… (press Ctrl-C to quit)<br>1) “subscribe”<br>2) “redisChat”<br>3) (integer) 1 </p>
<p>现在，两个客户端都发布在同一个命名通道redisChat消息，并且以上订阅客户端接收消息。</p>
<p>redis 127.0.0.1:6379&gt; PUBLISH redisChat “Redis is a great caching technique”<br> (integer) 1<br>redis 127.0.0.1:6379&gt; PUBLISH redisChat “Learn redis by tutorials point”<br> (integer) 1<br> 1) “message”<br>2) “redisChat”<br>3) “Redis is a great caching technique”<br>1) “message”<br>2) “redisChat”<br>3) “Learn redis by tutorials point” </p>
<h1 id="Redis-事务"><a href="#Redis-事务" class="headerlink" title="Redis - 事务"></a>Redis - 事务</h1><p>Redis事务让一组命令在单个步骤执行。事务中有两个属性，说明如下：</p>
<ul>
<li>在一个事务中的所有命令按顺序执行作为单个隔离操作。通过另一个客户端发出的请求在Redis的事务的过程中执行，这是不可能的。</li>
<li>Redis的事务具有原子性。原子意味着要么所有的命令都执行或都不执行。</li>
</ul>
<h2 id="例子-12"><a href="#例子-12" class="headerlink" title="例子"></a>例子</h2><p>Redis的事务由指令多重发起，然后需要传递在事务，而且整个事务是通过执行命令EXEC执行命令列表。</p>
<p>redis 127.0.0.1:6379&gt; MULTI<br>OK<br>List of commands here<br>redis 127.0.0.1:6379&gt; EXEC</p>
<h3 id="例子-13"><a href="#例子-13" class="headerlink" title="例子"></a>例子</h3><p>以下举例说明Redis事务如何启动并执行。</p>
<p>redis 127.0.0.1:6379&gt; MULTI<br>OK<br>redis 127.0.0.1:6379&gt; SET tutorial redis<br>QUEUED<br>redis 127.0.0.1:6379&gt; GET tutorial<br>QUEUED<br>redis 127.0.0.1:6379&gt; INCR visitors<br>QUEUED<br>redis 127.0.0.1:6379&gt; EXEC<br> 1) OK<br>2) “redis”<br>3) (integer) 1 </p>
<h1 id="Redis-脚本"><a href="#Redis-脚本" class="headerlink" title="Redis - 脚本"></a>Redis - 脚本</h1><p>Redis脚本使用Lua解释脚本用于评估计算。它内置的Redis，从2.6.0版本开始使用脚本命令 eval。</p>
<h2 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h2><p>eval命令的基本语法如下：</p>
<p>redis 127.0.0.1:6379&gt; EVAL script numkeys key [key …] arg [arg …]</p>
<h3 id="例子-14"><a href="#例子-14" class="headerlink" title="例子"></a>例子</h3><p>以下举例说明Redis脚本的工作原理：</p>
<p>redis 127.0.0.1:6379&gt; EVAL “return {KEYS[1],KEYS[2],ARGV[1],ARGV[2]}” 2 key1 key2 first second<br> 1) “key1”<br>2) “key2”<br>3) “first”<br>4) “second” </p>
<h1 id="Redis-连接"><a href="#Redis-连接" class="headerlink" title="Redis - 连接"></a>Redis - 连接</h1><p>Redis的连接命令基本上都是用于管理与Redis的服务器客户端连接。</p>
<h3 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h3><p>下面的例子说明了一个客户如何通过Redis服务器验证自己，并检查服务器是否正在运行。</p>
<p>redis 127.0.0.1:6379&gt; AUTH “password”<br>OK<br>redis 127.0.0.1:6379&gt; PING<br>PONG</p>
<h1 id="Redis-备份"><a href="#Redis-备份" class="headerlink" title="Redis - 备份"></a>Redis - 备份</h1><p>Redis SAVE命令用来创建当前的 Redis 数据库备份。</p>
<h2 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h2><p>对Redis SAVE命令的基本语法如下所示：</p>
<p>127.0.0.1:6379&gt; SAVE</p>
<h3 id="例子-15"><a href="#例子-15" class="headerlink" title="例子"></a>例子</h3><p>下面的示例显示了 Redis 当前数据库如何创建备份。</p>
<p>127.0.0.1:6379&gt; SAVE<br> OK </p>
<p>这个命令将创建dump.rdb文件在Redis目录中。</p>
<h2 id="还原Redis数据"><a href="#还原Redis数据" class="headerlink" title="还原Redis数据"></a>还原Redis数据</h2><p>要恢复Redis的数据只需移动 Redis 的备份文件（dump.rdb）到 Redis 目录，然后启动服务器。为了得到你的 Redis 目录，使用配置命令如下所示：</p>
<p>127.0.0.1:6379&gt; CONFIG get dir<br> 1) “dir”<br>2) “/user/yiibai/redis-2.8.13/src” </p>
<p>在上述命令的输出在 /user/yiibai/redis-2.8.13/src 目录，在安装redis的服务器安装位置。</p>
<h2 id="Bgsave"><a href="#Bgsave" class="headerlink" title="Bgsave"></a>Bgsave</h2><p>要创建Redis的备份备用命令BGSAVE也可以。这个命令将开始执行备份过程，并在后台运行。</p>
<h3 id="例子-16"><a href="#例子-16" class="headerlink" title="例子"></a>例子</h3><p>127.0.0.1:6379&gt; BGSAVE<br> Background saving started </p>
<h1 id="Redis-安全"><a href="#Redis-安全" class="headerlink" title="Redis - 安全"></a>Redis - 安全</h1><p>可以Redis的数据库更安全，所以相关的任何客户端都需要在执行命令之前进行身份验证。客户端输入密码匹配需要使用Redis设置在配置文件中的密码。</p>
<h3 id="例子-17"><a href="#例子-17" class="headerlink" title="例子"></a>例子</h3><p>下面给出的例子显示的步骤，以确保您的Redis实例安全。</p>
<p>127.0.0.1:6379&gt; CONFIG get requirepass<br>1) “requirepass”<br>2) “”</p>
<p>默认情况下，此属性为空，表示没有设置密码，此实例。您可以通过执行以下命令来更改这个属性</p>
<p>127.0.0.1:6379&gt; CONFIG set requirepass “yiibai”<br>OK<br>127.0.0.1:6379&gt; CONFIG get requirepass<br>1) “requirepass”<br>2) “yiibai”</p>
<p>设置密码，如果客户端运行命令没有验证，会提示（错误）NOAUTH，需要通过验证。错误将返回客户端。因此，客户端需要使用AUTHcommand进行认证。</p>
<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3><p>AUTH命令的基本语法如下所示：</p>
<p>127.0.0.1:6379&gt; AUTH password</p>
<h1 id="Redis-基准"><a href="#Redis-基准" class="headerlink" title="Redis - 基准"></a>Redis - 基准</h1><p>Redis基准是公用工具同时运行Ñ命令检查Redis的性能。</p>
<h2 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h2><p>redis的基准的基本语法如下所示：</p>
<p>redis-benchmark [option] [option value]</p>
<h3 id="例子-18"><a href="#例子-18" class="headerlink" title="例子"></a>例子</h3><p>下面给出的例子检查redis调用100000命令。</p>
<p>redis-benchmark -n 100000<br> PING_INLINE: 141043.72 requests per second<br>PING_BULK: 142857.14 requests per second<br>SET: 141442.72 requests per second<br>GET: 145348.83 requests per second<br>INCR: 137362.64 requests per second<br>LPUSH: 145348.83 requests per second<br>LPOP: 146198.83 requests per second<br>SADD: 146198.83 requests per second<br>SPOP: 149253.73 requests per second<br>LPUSH (needed to benchmark LRANGE): 148588.42 requests per second<br>LRANGE_100 (first 100 elements): 58411.21 requests per second<br>LRANGE_300 (first 300 elements): 21195.42 requests per second<br>LRANGE_500 (first 450 elements): 14539.11 requests per second<br>LRANGE_600 (first 600 elements): 10504.20 requests per second<br>MSET (10 keys): 93283.58 requests per second </p>
<h1 id="Redis-客户端连接"><a href="#Redis-客户端连接" class="headerlink" title="Redis - 客户端连接"></a>Redis - 客户端连接</h1><p>Redis接受配置监听TCP端口和Unix套接字客户端的连接，如果启用。当一个新的客户端连接被接受以下操作进行：</p>
<ul>
<li>客户端套接字置于非阻塞状态，因为Redis使用复用和非阻塞I/O操作。</li>
<li>TCP_NODELAY选项设定是为了确保我们没有在连接时延迟。</li>
<li>创建一个可读的文件时，这样Redis能够尽快收集客户端的查询作为新的数据可供读取的套接字。</li>
</ul>
<h3 id="客户端的最大数量"><a href="#客户端的最大数量" class="headerlink" title="客户端的最大数量"></a>客户端的最大数量</h3><p>在Redis的配置（redis.conf）属性调用maxclients，它描述客户端可以连接到Redis的最大数量。命令的基本语法是：</p>
<p>config get maxclients<br> 1) “maxclients”<br>2) “10000” </p>
<p>默认情况下，此属性设置为10000（这取决于操作系统的文件描述符限制最大数量），但你可以改变这个属性。</p>
<h3 id="例子-19"><a href="#例子-19" class="headerlink" title="例子"></a>例子</h3><p>在下面给出的例子中，在启动服务器我们设置客户端的最大数量为10万。</p>
<p>redis-server –maxclients 100000</p>
<h1 id="Redis-管道传输"><a href="#Redis-管道传输" class="headerlink" title="Redis - 管道传输"></a>Redis - 管道传输</h1><p>Redis是一个TCP服务器，并支持请求/响应协议。在redis一个请求完成下面的步骤：</p>
<ul>
<li>客户端发送一个查询到服务器，并从套接字中读取，通常在阻塞的方式，对服务器的响应。</li>
<li>服务器处理命令并将响应返回给客户端。</li>
</ul>
<h3 id="管道传输的含义"><a href="#管道传输的含义" class="headerlink" title="管道传输的含义"></a>管道传输的含义</h3><p>管道的基本含义是，客户端可以发送多个请求给服务器，而无需等待答复所有，并最后读取在单个步骤中的答复。</p>
<h3 id="例子-20"><a href="#例子-20" class="headerlink" title="例子"></a>例子</h3><p>要检查redis的管道，只要启动Redis实例，然后在终端键入以下命令。</p>
<p>$(echo -en “PING\r\n SET tutorial redis\r\nGET tutorial\r\nINCR visitor\r\nINCR visitor\r\nINCR visitor\r\n”; sleep 10) | nc localhost 6379<br> +PONG<br>+OK<br>redis<br>:1<br>:2<br>:3 </p>
<p>在上述例子中，我们必须使用PING命令检查Redis的连接，之后，我们已经设定值的Redis字符串命名tutorial ，之后拿到key的值和增量访问量的三倍。在结果中，我们可以检查所有的命令都一次提交给Redis，Redis是在一个步骤给出所有命令的输出。</p>
<h3 id="管道的好处"><a href="#管道的好处" class="headerlink" title="管道的好处"></a>管道的好处</h3><p>这种技术的好处是极大地改善协议的性能。通过管道将慢互联网连接速度从5倍的连接速度提高到localhost至少达到百过倍。</p>
<h1 id="Redis-分区"><a href="#Redis-分区" class="headerlink" title="Redis - 分区"></a>Redis - 分区</h1><p>分区是一种将数据分成多个Redis的情况下，让每一个实例将只包含你的键字的子集的过程。</p>
<h3 id="分区的好处"><a href="#分区的好处" class="headerlink" title="分区的好处"></a>分区的好处</h3><ul>
<li>它允许更大的数据库，使用的多台计算机的存储器的总和。如果不分区，一台计算机的内存可支数量有限。</li>
<li>它允许以大规模的计算能力，以多个内核和多个计算机，以及网络带宽向多台计算机和网络适配器。</li>
</ul>
<h3 id="分区的缺点"><a href="#分区的缺点" class="headerlink" title="分区的缺点"></a>分区的缺点</h3><ul>
<li>通常不支持涉及多个键的操作。例如，不能两个集合之间执行交叉点，因为它们存储在被映射到不同Redis实例中的键。</li>
<li>涉及多个键的Redis事务不能被使用。</li>
<li>分区粒度是关键，所以它是不可能分片数据集用一个硕大的键是一个非常大的有序集合。</li>
<li>当分区时，数据处理比较复杂，比如要处理多个RDB/AOF文件，使数据备份需要从多个实例和主机聚集持久性文件。</li>
<li>添加和删除的能力可能很复杂。比如Redis的集群支持有添加，并在运行时删除节点不支持此功能的能力，但其他系统，如客户端的分区和代理的数据大多是透明的重新平衡。但是有一个叫Presharding技术有助于在这方面。</li>
</ul>
<h3 id="分区的类型"><a href="#分区的类型" class="headerlink" title="分区的类型"></a>分区的类型</h3><p>redis的提供有两种类型的分区。假设我们有四个Redis实例R0，R1，R2，R3和代表用户很多键如：user:1, user:2, … 等等</p>
<h3 id="范围分区"><a href="#范围分区" class="headerlink" title="范围分区"></a>范围分区</h3><p>范围分区被映射对象转化为具体的Redis实例的范围内实现。假定在本例中用户ID0〜ID10000将进入实例R0，而用户形成ID10001至20000号将进入实例R1等等。</p>
<h3 id="散列分区"><a href="#散列分区" class="headerlink" title="散列分区"></a>散列分区</h3><p>在这种类型的分区，一个散列函数（例如，模数函数）被用于转换键成数字，然后数据被存储在不同redis的实例。</p>

            
            <p class="more">
                <a href="/2015/11/24/2019030500153/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/11/24/2019030500153/" title="redis数据类型">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/4.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/MySQL/">MySQL</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/11/24/2019030500121/">
    		Mysql:is not allowed to connect to this MySQL server
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-11-24T06:22:41.000Z">2015-11-24</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/MySQL/" title="MySQL">MySQL</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>Mysql:is not allowed to connect to this MySQL server</p>
<p>如果你想连接你的mysql的时候发生这个错误： ERROR 1130: Host ‘192.168.1.1’ is not allowed to connect to this MySQL server 解决方法： 1。 改表法。可能是你的帐号不允许从远程登陆，只能在localhost。这个时候只要在localhost的那台电脑，登入mysql后，更改 “mysql” 数据库里的 “user” 表里的 “host” 项，从”localhost”改称”%” mysql -u root -pvmwaremysql&gt;use mysql;mysql&gt;update user set host = ‘%’ where user = ‘root’;mysql&gt;select host, user from user; 2. 授权法。例如，你想myuser使用mypassword从任何主机连接到mysql服务器的话。 GRANT ALL PRIVILEGES ON <em>.</em> TO ‘myuser‘@’%’ IDENTIFIED BY ‘mypassword’ WITH GRANT OPTION; 如果你想允许用户myuser从ip为192.168.1.1的主机连接到mysql服务器，并使用123456作为密码 GRANT ALL PRIVILEGES ON <em>.</em> TO ‘root‘@’192.168.1.1’ IDENTIFIED BY ‘123456’ WITH GRANT OPTION;</p>

            
            <p class="more">
                <a href="/2015/11/24/2019030500121/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/11/24/2019030500121/" title="Mysql:is not allowed to connect to this MySQL server">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/4.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    
        <!-- 文章列表 item -->
<article class="post">
    <header>
        <!-- 标签这有且只能显示一个 -->
        
        <a class="cat-link" href="/categories/开发语言/">开发语言</a>
        
        <!-- 文章标题 -->
        
    <h3 class="post-title">
    	<a href="/2015/11/23/2019030500049/">
    		java 中的断言assert的使用
    	</a>
    </h3>

    </header>
    <p class="post-meta">
        Jelon 发表于
        <time datetime="2015-11-23T12:17:44.000Z">2015-11-23</time>
        &nbsp;&nbsp;
        <span class="post-tags">
            标签：
            
    
        <a href="/tags/assert/" title="assert">assert</a> / 
    
        <a href="/tags/Java/" title="Java">Java</a> / 
    
        <a href="/tags/断言/" title="断言">断言</a>
    

        </span>
    </p>

    <div class="post-content">
        <div class="post-excerpt">
            
                <p>一、assertion的意义和用法 </p>
<p>J2SE 1.4在语言上提供了一个新特性，就是assertion功能，它是该版本在Java语言方面最大的革新。 </p>
<p>从理论上来说，通过 assertion方式可以证明程序的正确性，但是这是一项相当复杂的工作，目前还没有太多的实践意义。 </p>
<p>在实现中，assertion就是在程序中的一条语句，它对一个boolean表达式进行检查，一个正确程序必须保证这个boolean表达式的值为true；如果该值为false，说明程序已经处于不正确的状态下，系统将给出警告或退出。</p>
<p>一般来说，assertion用于保证程序最基本、关键的正确性。assertion检查通常在开发和测试时开启。为了提高性能，在软件发布后，assertion检查通常是关闭的。</p>
<p>1、语法表示 </p>
<p>在语法上，为了支持assertion，Java增加了一个关键字assert。它包括两种表达式，分别如下：<br>        assert  expression1;<br>        assert  expression1:expression2;</p>
<p>在两种表达式中，expression1表示一个boolean表达式， expression2表示一个基本类型或者是一个对象(Object)，基本类型包括boolean,char,double,float,int和 long。由于所有类都为Object的子类，因此这个参数可以用于所有对象。 </p>
<p>2、含义 </p>
<p>在运行时，如果关闭了assertion功能，这些语句将不起任何作用。如果打开了assertion功能，那么expression1的值将被计算，如果它的值为false，该语句强抛出一个AssertionError对象。</p>
<p>如果assertion语句包括expression2参数，程序将计算出 expression2的结果，然后将这个结果作为AssertionError的构造函数的参数，来创建AssertionError对象，并抛出该对 象；如果expression1值为true，expression2将不被计算。 </p>
<p>一种特殊情况是，如果在计算表达式时，表达式本身抛出Exception，那么assert将停止运行，而抛出这个Exception。 </p>
<p>3、编译 </p>
<p>由于assert是一个新关键字，使用老版本的JDK是无法编译带有assert的 源程序。因此，我们必须使用JDK1.4(或者更新)的Java编译器，在使用Javac命令时，我们必须加上-source 1.4作为参数。-source 1.4表示使用JDK 1.4版本的方式来编译源代码，否则编译就不能通过，因为缺省的Javac编译器使用JDK1.3的语法规则。 </p>
<p>大家在使用eclipse,jbuilder等IDE工具的时候,要注意编译器的版本,使用的jre,不等于是javac 的版本</p>
<p><strong>方法入参检测工具类</strong> Web 应用在接受表单提交的数据后都需要对其进行合法性检查，如果表单数据不合法，请求将被驳回。类似的，当我们在编写类的方法时，也常常需要对方法入参进行合法性检查，如果入参不符合要求，方法将通过抛出异常的方式拒绝后续处理。举一个例子：有一个根据文件名获取输入流的方法：InputStream getData(String file)，为了使方法能够成功执行，必须保证 file 入参不能为 null 或空白字符，否则根本无须进行后继的处理。这时方法的编写者通常会在方法体的最前面编写一段对入参进行检测的代码，如下所示： public InputStream getData(String file) { if (file == null || file.length() == 0|| file.replaceAll(“\\s”, “”).length() == 0) { throw new IllegalArgumentException(“file入参不是有效的文件地址”); } … } 类似以上检测方法入参的代码是非常常见，但是在每个方法中都使用手工编写检测逻辑的方式并不是一个好主意。阅读 Spring 源码，您会发现 Spring 采用一个 org.springframework.util.Assert 通用类完成这一任务。 Assert 翻译为中文为“断言”，使用过 JUnit 的读者都熟知这个概念，它断定某一个实际的运行值和预期想一样，否则就抛出异常。Spring 对方法入参的检测借用了这个概念，其提供的 Assert 类拥有众多按规则对方法入参进行断言的方法，可以满足大部分方法入参检测的要求。这些断言方法在入参不满足要求时就会抛出 IllegalArgumentException。下面，我们来认识一下 Assert 类中的常用断言方法： 断言方法 说明 <code>notNull(Object object)</code> 当 object 不为 null 时抛出异常，notNull(Object object, String message) 方法允许您通过 message 定制异常信息。和 notNull() 方法断言规则相反的方法是 isNull(Object object)/isNull(Object object, String message)，它要求入参一定是 null； <code>isTrue(boolean expression) / isTrue(boolean expression, String message)</code> 当 expression 不为 true 抛出异常； <code>notEmpty(Collection collection) / notEmpty(Collection collection, String message)</code> 当集合未包含元素时抛出异常。notEmpty(Map map) / notEmpty(Map map, String message) 和 notEmpty(Object[] array, String message) / notEmpty(Object[] array, String message) 分别对 Map 和 Object[] 类型的入参进行判断； <code>hasLength(String text) / hasLength(String text, String message)</code> 当 text 为 null 或长度为 0 时抛出异常； <code>hasText(String text) / hasText(String text, String message)</code> text 不能为 null 且必须至少包含一个非空格的字符，否则抛出异常； <code>isInstanceOf(Class clazz, Object obj) / isInstanceOf(Class type, Object obj, String message)</code> 如果 obj 不能被正确造型为 clazz 指定的类将抛出异常； <code>isAssignable(Class superType, Class subType) / isAssignable(Class superType, Class subType, String message)</code> subType 必须可以按类型匹配于 superType，否则将抛出异常； 使用 Assert 断言类可以简化方法入参检测的代码，如 InputStream getData(String file) 在应用 Assert 断言类后，其代码可以简化为以下的形式：</p>
<p>public InputStream getData(String file){ Assert.hasText(file,”file入参不是有效的文件地址”); 使用 Spring 断言类进行方法入参检测 … }</p>
<p>可见使用 Spring 的 Assert 替代自编码实现的入参检测逻辑后，方法的简洁性得到了不少的提高。Assert 不依赖于 Spring 容器，您可以大胆地在自己的应用中使用这个工具类。</p>

            
            <p class="more">
                <a href="/2015/11/23/2019030500049/">阅读剩下更多</a>
            </p>
        </div>
        <div class="post-thumbnail" data-img>
            <a href="/2015/11/23/2019030500049/" title="java 中的断言assert的使用">
                
                    <img class="thumbnail" src="/img/default.png" data-echo="/img/thumbnail/3.jpg" alt="默认配图">
                
            </a>
        </div>
    </div>
</article>

    

    
    <nav class="page-navigator">
        <span class="page-number current">1</span><a class="page-number" href="/archives/2015/11/page/2/">2</a><a class="extend next" rel="next" href="/archives/2015/11/page/2/">后一页</a>
    </nav>
    


            </div>

        </section>
        <!-- 侧栏部分 -->
<aside class="sidebar">
    <section class="widget">
        <h3 class="widget-hd"><strong>文章分类</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
    <li>
        <a href="/categories/MySQL/">MySQL</a>
        <span class="badge">(92)</span>
    </li>
    
    <li>
        <a href="/categories/开发语言/">开发语言</a>
        <span class="badge">(7)</span>
    </li>
    
    <li>
        <a href="/categories/Oracle/">Oracle</a>
        <span class="badge">(40)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/">NOSQL</a>
        <span class="badge">(17)</span>
    </li>
    
    <li>
        <a href="/categories/SQL-Server/">SQL Server</a>
        <span class="badge">(13)</span>
    </li>
    
    <li>
        <a href="/categories/其他数据库/">其他数据库</a>
        <span class="badge">(4)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/">Oracle</a>
        <span class="badge">(3)</span>
    </li>
    
    <li>
        <a href="/categories/MySQL/Oracle/SQL-Server/">SQL Server</a>
        <span class="badge">(1)</span>
    </li>
    
    <li>
        <a href="/categories/NOSQL/开发语言/">开发语言</a>
        <span class="badge">(1)</span>
    </li>
    
</ul>
    </section>

    
    <section class="widget">
        <h3 class="widget-hd"><strong>热门标签</strong></h3>
        <!-- 文章标签 -->
<div class="widget-bd tag-wrap">
  
    <a class="tag-item" href="/tags/MySQL/" title="MySQL">MySQL (71)</a>
  
    <a class="tag-item" href="/tags/位运算/" title="位运算">位运算 (0)</a>
  
    <a class="tag-item" href="/tags/allow/" title="allow">allow (1)</a>
  
    <a class="tag-item" href="/tags/Apache/" title="Apache">Apache (1)</a>
  
    <a class="tag-item" href="/tags/deny/" title="deny">deny (1)</a>
  
    <a class="tag-item" href="/tags/sqlplus/" title="sqlplus">sqlplus (1)</a>
  
    <a class="tag-item" href="/tags/CentOS/" title="CentOS">CentOS (2)</a>
  
    <a class="tag-item" href="/tags/druid/" title="druid">druid (1)</a>
  
    <a class="tag-item" href="/tags/心跳/" title="心跳">心跳 (1)</a>
  
    <a class="tag-item" href="/tags/redis/" title="redis">redis (6)</a>
  
    <a class="tag-item" href="/tags/分库/" title="分库">分库 (1)</a>
  
    <a class="tag-item" href="/tags/分库分表/" title="分库分表">分库分表 (1)</a>
  
    <a class="tag-item" href="/tags/分表/" title="分表">分表 (1)</a>
  
    <a class="tag-item" href="/tags/Oracle/" title="Oracle">Oracle (30)</a>
  
    <a class="tag-item" href="/tags/schedule-job/" title="schedule job">schedule job (1)</a>
  
    <a class="tag-item" href="/tags/事务/" title="事务">事务 (5)</a>
  
    <a class="tag-item" href="/tags/分布式/" title="分布式">分布式 (1)</a>
  
    <a class="tag-item" href="/tags/消息/" title="消息">消息 (1)</a>
  
    <a class="tag-item" href="/tags/KeepAlived/" title="KeepAlived">KeepAlived (1)</a>
  
    <a class="tag-item" href="/tags/数据库/" title="数据库">数据库 (7)</a>
  
    <a class="tag-item" href="/tags/结构同步/" title="结构同步">结构同步 (1)</a>
  
    <a class="tag-item" href="/tags/truncate/" title="truncate">truncate (1)</a>
  
    <a class="tag-item" href="/tags/FineReport/" title="FineReport">FineReport (1)</a>
  
    <a class="tag-item" href="/tags/SQL/" title="SQL">SQL (17)</a>
  
    <a class="tag-item" href="/tags/报表/" title="报表">报表 (1)</a>
  
    <a class="tag-item" href="/tags/数据集/" title="数据集">数据集 (1)</a>
  
    <a class="tag-item" href="/tags/Excel/" title="Excel">Excel (1)</a>
  
    <a class="tag-item" href="/tags/Sqlite/" title="Sqlite">Sqlite (1)</a>
  
    <a class="tag-item" href="/tags/批量/" title="批量">批量 (1)</a>
  
    <a class="tag-item" href="/tags/Linux/" title="Linux">Linux (2)</a>
  
    <a class="tag-item" href="/tags/Character-set/" title="Character set">Character set (1)</a>
  
    <a class="tag-item" href="/tags/NLS-LANG/" title="NLS_LANG">NLS_LANG (1)</a>
  
    <a class="tag-item" href="/tags/rowid/" title="rowid">rowid (2)</a>
  
    <a class="tag-item" href="/tags/重复/" title="重复">重复 (1)</a>
  
    <a class="tag-item" href="/tags/Hash索引/" title="Hash索引">Hash索引 (1)</a>
  
    <a class="tag-item" href="/tags/InnoDB/" title="InnoDB">InnoDB (3)</a>
  
    <a class="tag-item" href="/tags/MyISAM/" title="MyISAM">MyISAM (3)</a>
  
    <a class="tag-item" href="/tags/索引优化/" title="索引优化">索引优化 (1)</a>
  
    <a class="tag-item" href="/tags/mysqldump/" title="mysqldump">mysqldump (2)</a>
  
</div>
    </section>
    

    

    
    <!-- 友情链接 -->
    <section class="widget">
        <h3 class="widget-hd"><strong>友情链接</strong></h3>
        <!-- 文章分类 -->
<ul class="widget-bd">
    
        <li>
            <a href="http://www.devba.com" target="_blank" title="软件开发吧">软件开发吧</a>
        </li>
    
        <li>
            <a href="https://www.sqlyun.cn" target="_blank" title="SQL云笔记">SQL云</a>
        </li>
    
</ul>
    </section>
    
</aside>
<!-- / 侧栏部分 -->
    </div>

    <!-- 博客底部 -->
    <footer class="footer">
    &copy;
    
        2016-2019
    

    <a href="/">Jelon Loves You</a>
</footer>
<div class="back-to-top" id="JELON__backToTop" title="返回顶部">返回顶部</div>

    <!--博客js脚本 -->
    <!-- 这里放网站js脚本 -->
<script src="/js/main.js"></script>
</body>
</html>